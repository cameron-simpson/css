#!/bin/sh -u
#
# Quick attach to remote host.
#	- Cameron Simpson <cs@zip.com.au>
#

: ${RTERM_SSHOPTS:=''}
: ${TERM:=vt100}
: ${DISPLAY:=''}

cmd=`basename "$0"`
usage="Usage: $cmd [login@]host[,[login@host]...] [-v] [-n name] [-o opt] {-A | [-c sh-command] | [[--] command [args...]]}
	-A	Pop up terminals for all screens on the remote host.
	-ip +ip	Passed to term.
	-v	Verbose.
	-1	Use ssh protocol 1.
	-2	Use ssh protocol 2.
	-m msg	Log session with the supplied message.
	-T term	Remote terminal name to use.
		Default from \$TERM: $TERM
	-x	Ssh option: X11 forwarding off.
	-X	Ssh option: X11 forwarding on. NB: Turns on ForwardX11Trusted.
	-n name	Name for window and remote screen session."

badopts=

if [ $# -gt 0 ]
then
  targets=$1
  shift
else
  echo "$cmd: missing host[@systemid]" >&2
  badopts=1
fi

trace=:
name=
verbose=
farhost=
newflag=
sshopts=
sshx11opt=
##[ -n "$DISPLAY" ] && sshx11opt=-Y
termopts=
doscript=
doscreen=
allscreens=
msg=
nomsgopt=-M

gotargs=
while [ $# -gt 0 ]
do  case $1 in
	-A)	doscreen=1 allscreens=1 ;;
	-c)	shift; set -- sh -c "$1"; break ;;
	-e)	shift
		[ $# = 0 ] && { echo "$cmd: -e: missing command" >&2
				badopts=1
			      }
		break
		;;
	-m)	msg=$2; shift; nomsgopt=; doscript=1 ;;
	-n)	name=$2; shift ;;
	-v)	sshopts="$sshopts -v" verbose=1 ;;
	-T)	TERM=$2; shift ;;
	-[XY])	sshx11opt=$1 ;;
	+X)	sshx11opt=forwardx11=no ;;
	-[12])sshopts="$sshopts $1" ;;
	-ip|+ip)termopts="$termopts $1" ;;
	-s)	doscreen=1 ;;
	+s)	doscreen= ;;
	--)	shift; break ;;
	-?*)	echo "$cmd: unrecognised option: $1" >&2; badopts=1 ;;
	*)	break ;;
    esac
    shift
done

[ $allscreens ] \
 && { [ $# = 0 ] \
   || { echo "$cmd: a command may not be supplied with -A option" >&2
	badopts=1
      }
    }

[ $badopts ] && { echo "$usage" >&2; exit 2; }

xit=0

lastbase=
for target in `printf "%s\n" "$targets" | tr , ' '`
do
  case "$target" in
    [0-9])
      [ -n "$lastbase" ] \
      || { echo "$cmd: no previous hostN name, skipping: $target" >&2
	   xit=1
	   continue
	 }
      target=$lastbase$target
      ;;
    [a-z]*[0-9])
      lastbase=`expr "x$target" : 'x\(.*[^0-9]\)[0-9]*'` || xit=1
      ;;
  esac

  (
    [ -n "$name" ] || name=$target

    if [ $allscreens ]
    then
      envssh $RTERM_SSHOPTS $sshopts -- "$target" exec scr \
      | { xit=0
	  hit=
	  while read n title
	  do  
	    hit=1
	    term -n "$name: $title" -e sshto $RTERM_SSHOPTS $sshopts -- "$target" "$dflt_env; exec scr $n" \
		  || xit=1
	  done
	  [ $hit ] || { echo "$cmd: no remote screens on $target, starting new session" >&2
			set -x
			exec "$0" $sshopts $termopts "$target"
		      }
	  exit $xit
	}
      exit $?
    fi

    # no command? just run the preferred shell
    [ $# = 0 ] && set -- sh -c '[ -s /opt/css/env.sh ] && . /opt/css/env.sh; exec $SHELL'

    if [ $doscreen ]
    then
    case "$TERM" in
    rxvt*)
      oTERM=$TERM
      TERM=vt100
      export TERM
      echo "$cmd: warning: changing TERM from \"$oTERM\" to \"$TERM\" for screen" >&2
      ;;
    esac
    fi

    # pass envvars
    set -- env "TERM=$TERM" "$@"

    [ $doscreen ] && set -- scr -e "$@"
    qcmd="$dflt_env; exec "`shqstr "$@"`
    set -- sshto $RTERM_SSHOPTS $sshx11opt $sshopts -- "$target" "$qcmd"
    [ $doscript ] && set -- logscript -m "$name: $msg" $nomsgopt -- "$name" "$@"

    exec term $termopts -n "$name" -e "$@"
  ) || xit=1
done

exit $xit
