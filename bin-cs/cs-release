#!/usr/bin/env python3
#
# General release stuff for packages.
#   - Cameron Simpson <cs@zip.com.au> 28feb2009
#
# Redo in python; it is getting unmanagable in shell.
#   - Cameron Simpson <cs@zip.com.au> 23jul2015
#

from __future__ import print_function
import sys
import os.path
import re
from subprocess import Popen, PIPE, check_call
from contextlib import contextmanager
import importlib
from cs.app.lastvalue import LastValues
import cs.cmdutils
from cs.dateutils import isodate
from cs.distinfo import URL_PYPI_PROD, URL_PYPI_TEST, PyPI_Package
from cs.logutils import setup_logging, Pfx, exception, error, warning, info, X, XP
from cs.py.modules import module_files

PYLIBTOP = 'lib/python'

USAGE = '''Usage: %s [op [names...]]
  With no op, report all pypi and testpypi lastvalues.
  op:
    check       Check simple things about a module's DISTINFO map.
    last        Report last release issued.
    log         Changelog from last release to now.
    ls          List all release prefixes in use.
    next        Generate a new release number.
    pypi        Upload latest release to PyPI.
    release     Issue a new release tag with change summary.
    status      Report latest release tag and differing releases at pypi and testpypi.
    testpypi    Upload latest release to test PyPI.'''

##  export      Export release to temporary directory, report directory.
##  freshmeat-submit Announce last release to freshmeat.

def main(argv):
  cmd = os.path.basename(argv.pop(0))
  usage = USAGE % (cmd,)
  setup_logging(cmd)

  badopts = False
  xit = 0

  Ms = Modules()
  LV = LastValues()
  VCS = VCS_Hg()

  if not argv:
    for k in sorted(LV.keys()):
      if k.startswith("pypi-css-cs."):
        print(k[9:], LV[k])
  else:
    op = argv.pop(0)
    if argv:
      names = argv
    else:
      names = sorted(VCS.release_prefixes())
    check_map = {}
    for name in names:
      with Pfx(op):
        with Pfx(name):
          N = ReleaseName(name, Ms, VCS, LV)
          if op == 'check':
            if name.startswith('cs.'):
              if N.check(check_map=check_map):
                print(name, 'OK')
              else:
                print(name, 'NOT OK')
                xit = 1
            else:
              warning('skipped, not a "cs." module name')
          elif op == 'last':
            print(name, N.last_suffix())
          elif op == 'log':
            first = True
            for files, firstline in N.log_since():
              if first:
                print(name)
                first = False
              files = [ filename[11:] if filename.startswith('lib/python/') else filename for filename in files ]
              print(' ', ' '.join(files)+':', firstline)
          elif op == 'ls':
            for suffix in sorted(N.release_suffixes()):
              print(name, suffix)
          elif op == 'next':
            print(name, N.next_suffix())
          elif op == 'pypi':
            # upload latest release to testpypi
            N.submit_pypi()
          elif op == 'release':
            # issue new release tag
            print("new release for %s ..." % (name,))
            outstanding = N.uncommitted()
            if outstanding:
              print("Uncommited changes exist for these files:")
              for path in sorted(outstanding):
                print(' ', path)
              print("These changes will not be included in the release.")
              if not ask("Proceed with release anyway"):
                error("aborting release at user request")
                return 1
            changes = list(N.log_since())
            if not changes:
              error("no changes since last release, aborting")
              xit = 1
            else:
              print("Changes since the last release:")
              for files, firstline in changes:
                print(" ", ' '.join(files) + ': ' + firstline)
              print()
              with pipefrom('readdottext', keep_stdin=True) as dotfp:
                release_message = dotfp.read().rstrip()
              if not release_message:
                error("empty release message, aborting")
                xit = 1
              else:
                next_tag = N.next_release_tag()
                if not ask("Confirm new release for %r as %r" % (name, next_tag)):
                  error("aborting release at user request")
                  xit = 1
                else:
                  rel_dir = os.path.join('release', next_tag)
                  with Pfx("mkdir(%s)", rel_dir):
                    os.mkdir(rel_dir)
                  summary_filename = os.path.join(rel_dir, 'SUMMARY.txt')
                  with Pfx(summary_filename):
                    with open(summary_filename, 'w') as sfp:
                      print(release_message, file=sfp)
                  changes_filename = os.path.join(rel_dir, 'CHANGES.txt')
                  with Pfx(changes_filename):
                    with open(changes_filename, 'w') as cfp:
                      for files, firstline in changes:
                        print(" ", ' '.join(files) + ': ' + firstline, file=cfp)
                  VCS = N.vcs
                  VCS.add_files(summary_filename, changes_filename)
                  VCS.commit('Release information for %s.\nSummary:\n%s'
                             % (next_tag, release_message),
                             summary_filename, changes_filename)
                  VCS.tag(next_tag)
          elif op == 'status':
            tagged = N.last_suffix()
            result = [name, tagged]
            for pypi_flavour in 'testpypi', 'pypi':
              lvkey, last_upload = N.last_upload(pypi_flavour)
              if last_upload != tagged:
                result.append("%s:%s" % (pypi_flavour, last_upload))
            print(*result)
          elif op == 'testpypi':
            N.submit_testpypi()
          else:
            warning("unrecognised op")
            badopts = True

  if badopts:
    print(usage, file=sys.stderr)
    xit = 2
  return xit

def ask(message):
  ''' Prompt with yes/no question, return true if response is "y" or "yes".
  '''
  print(message, end='? ')
  sys.stdout.flush()
  response = sys.stdin.readline().rstrip().lower()
  return response in ('y', 'yes')

@contextmanager
def pipefrom(*argv, **kw):
  ''' Context manager returning the standard output of a command.
  '''
  P = cs.cmdutils.pipefrom(argv, trace=False, **kw)
  yield P.stdout
  if P.wait() != 0:
    pipecmd = ' '.join(argv)
    raise ValueError("%s: exit status %d" % (pipecmd, P.returncode,))

class Modules(object):

  def __init__(self):
    self.modules = {}

  def module(self, name):
    try:
      M = self.modules[name]
    except KeyError:
      M = Module(name, self)
      self.modules[name] = M
    return M

  __getitem__ = module

class Module(object):

  def __init__(self, name, modules):
    self.name = name
    self.modules = modules
    self._distinfo = None
    self._checking = False
    self._check_status = None
    try:
      self.module = importlib.import_module(name)
    except ImportError as e:
      warning("ImportError: %s", e)
      self.module = None
      self.check_status = True
    except SyntaxError as e:
      warning("SyntaxError: %s", e)
      self.module = None
      self.check_status = False

  @property
  def in_package(self):
    ''' Is this module part of a package?
    '''
    M = self.module
    if M is None:
      return False
    return hasattr(M, '__package__')

  @property
  def is_package(self):
    ''' Is this module a package?
    '''
    pkg_name = self.package_name
    return pkg_name is not None and pkg_name == self.name

  @property
  def package_name(self):
    M = self.module
    if M is None:
      X("%r.package_name: self.module is None", self.name)
      return None
    try:
      pkg_name = M.__package__
    except AttributeError:
      X("%r.package_name: self.module has no __package__: %r", self.name, sorted(dir(M)))
      return None
    return pkg_name

  @property
  def dirpath(self):
    M = self.module
    if M is None:
      return None
    if not self.is_package:
      return None
    return os.path.dirname(M.__file__)

  def paths(self):
    ''' Generator returning the .py filenames comprising this package.
    '''
    M = self.module
    if M is None:
      return
    filename = self.module.__file__
    if not self.is_package:
      yield filename
    else:
      moddir = os.path.dirname(filename)
      for dirpath, dirnames, filenames in os.walk(moddir):
        for basename in filenames:
          if basename.endswith('.py'):
            yield os.path.join(dirpath, basename)

  @property
  def DISTINFO(self):
    D = self._distinfo
    if D is None:
      with Pfx("%s.DISTINFO", self.name):
        D = {}
        M = self.module
        if M is None:
          warning("cannot load module")
        else:
          try:
            D = M.DISTINFO
          except AttributeError:
            pkg_name = self.package_name
            if pkg_name == self.name:
              warning("missing")
            else:
              # look in the package
              P = self.modules[pkg_name]
              PM = P.module
              try:
                D = PM.DISTINFO
              except AttributeError:
                warning("missing and also missing in package %r", pkg_name)
              else:
                ##warning("DISTINFO from package %r", pkg_name)
                pass
          else:
            ##warning("DISTINFO from this module")
            pass
        self._distinfo = D
    return D

  def check(self, silent=False):
    with Pfx("check %r", self.name):
      if self._check_status is not None:
        return self._check_status
      if not self._checking:
        self._checking = True
        self._check_status = self._check(silent)
        self._checking = False
      return self._check_status

  def _check(self, silent):
    with Pfx("check %s", self.name):
      ok = True
      distinfo = self.DISTINFO
      with Pfx('DISTINFO'):
        install_requires = distinfo.get('install_requires')
        if install_requires is None:
          silent or error("missing DISTINFO[install_requires]")
          ok = False
          install_requires = distinfo.get('requires')
          if install_requires is None:
            install_requires = ()
          else:
            silent or warning("working off DISTINFO[requires]=%r", install_requires)
        install_requires = set(install_requires)
        # check imports against install_requires
        subimports = set()
        # check the imports for every file in the package
        for pathname in sorted(self.paths()):
          if not self.is_package:
            module_name = self.name
          else:
            # compute module name from pathname
            relpath = os.path.relpath(pathname, self.dirpath)
            dirpart, basepart = os.path.split(relpath)
            if basepart == '__init__.py':
              module_name = dirpart.replace(os.sep, '.')
            else:
              mod_part, mod_ext = os.path.splitext(relpath)
              if mod_ext != '.py':
                warning("relpath %r does not end in '.py', computing module_name from %r", relpath, mod_part)
              module_name = mod_part.replace(os.sep, '.')
            module_name = self.package_name + '.' + module_name
          # check the file
          fok, fimports = self._check_imports(module_name, pathname, install_requires, silent, self.modules)
          subimports.update(fimports)
          if not fok:
            X("OK = FALSE from _check_imports")
            ok = False
        for required in sorted(install_requires - subimports):
          with Pfx("install_required[%s]", required):
            silent or warning("not imported")

    return ok

  def _check_imports(self, module_name, filename, install_requires, silent, Ms):
    ''' Scan the supplied filename for imports, check against `install_requires`.
        Returns (ok, subimports).
    '''
    with Pfx("check_imports(%r)", filename):
      ok = True
      subimports = set()
      with open(filename) as codefp:
        for lineno, line in enumerate(codefp, 1):
          with Pfx(lineno):
            if line.startswith('import ') or line.startswith('from '):
              words = line.strip().split()
              if not words:
                continue
              if words[0] == 'import' or words[0] == 'from':
                if len(words) < 2:
                  silent or warning("missing module name")
                  continue
                subimport = words[1]
                if subimport.startswith('.'):
                  # resolve relative import name
                  preparts = module_name.split('.')
                  while subimport.startswith('.'):
                    preparts.pop(-1)
                    subimport = subimport[1:]
                  if preparts:
                    if subimport:
                      preparts.append(subimport)
                    subimport = '.'.join(preparts)
                with Pfx("import %s", subimport):
                  if subimport in subimports:
                    ##silent or warning("repeated")
                    continue
                  subimports.add(subimport)
                  if subimport.startswith('cs.'):
                    subM = Ms[subimport]
                    if subM is None:
                      warning("NO IMPORT FOR %r", subimport)
                    if subimport not in install_requires:
                      subpkg_name = subM.package_name
                      if subpkg_name is None:
                        warning("no package name?")
                      elif subpkg_name != self.package_name:
                        silent or error("not mentioned in install_requires")
                        ok = False
                    subcheck = subM.check(True)
                    if subcheck is None:
                      # already in progress
                      ##silent or warning("subcheck(%r): None: already in progress?", subimport)
                      pass
                    elif not subcheck:
                      silent or error("module NOT OK")
                      ok = False
    return ok, subimports

#                              name       - YYYYMMDD                            [.n]
re_RELEASE_TAG = re.compile(r'([a-z][^-]*)-(2[0-9][0-9][0-9][01][0-9][0-3][0-9](\.[1-9]\d*)?)$')

class VCS(object):

  def release_tags(self):
    ''' Generator yielding the current release tags.
    '''
    for tag in self.tags():
      m = re_RELEASE_TAG.match(tag)
      if m:
        yield tag

  def release_prefixes(self):
    ''' Return a set of the existing release prefixes.
    '''
    tagpfxs = set()
    for tag in self.release_tags():
      tagpfx, _ = tag.split('-', 1)
      tagpfxs.add(tagpfx)
    return tagpfxs

class VCS_Hg(VCS):

  def _pipefrom(self, *hgargs):
    hgargv = ['hg'] + list(hgargs) + ['|']
    return pipefrom('hg', *hgargs)

  def _hgcmd(self, *hgargs):
    print('hg', *hgargs, file=sys.stderr)
    check_call(['hg'] + list(hgargs))

  def tags(self):
    ''' Generator yielding the current tags.
    '''
    with self._pipefrom('tags') as hgfp:
      tags = set()
      for tagline in hgfp:
        tag, _ = tagline.split(None, 1)
        yield tag

  def tag(self, tag_name, revision=None):
    ''' Tag a revision with the supplied `tag`, by default revision "tip".
    '''
    if revision is None:
      revision = 'tip'
    self._hgcmd('tag',  '-r', revision, '--', tag_name)

  def log_since(self, tag, paths):
    with self._pipefrom('log',
                     '-r', tag+':',
                     '--template', '{files}\t{desc|firstline}\n',
                     '--',
                     *paths) as hgfp:
      for hgline in hgfp:
        files, firstline = hgline.split('\t', 1)
        files = files.split()
        firstline = firstline.strip()
        yield files, firstline

  def add_files(self, *paths):
    ''' Add the specified paths to the repository.
    '''
    self._hgcmd('add', *paths)

  def commit(self, message, *paths):
    ''' Commit the specified `paths` with the specified `message`.
    '''
    self._hgcmd('commit', '-m', message, '--', *paths)

  def uncommitted(self):
    ''' Generator yielding uncommited but tracked paths.
    '''
    with self._pipefrom('status') as hgfp:
      for hgline in hgfp:
        s, path = hgline.rstrip().split(' ', 1)
        if s != '?':
          yield path

class ReleaseName(object):
  ''' State surrounding a particular release tag prefix.
  '''

  def __init__(self, prefix, Ms, VCS, LV):
    self.prefix = prefix
    self.modules = Ms
    self.vcs = VCS
    self.lv = LV

  def check(self, silent=False, check_map=None):
    ''' Perform various sanity checks on the named module, return true if all pass.
    '''
    return self.modules[self.prefix].check(silent)

  def tagname(self, suffix):
    tag = self.prefix + '-' + suffix
    m = re_RELEASE_TAG.match(tag)
    if not m:
      raise ValueError("invalid tag made from prefix %r and suffix %r" % (self.prefix, suffix))
    return tag

  def release_tags(self):
    ''' Generator yielding existing release tags.
    '''
    prefix = self.prefix
    prefix_ = prefix + '-'
    for tag in self.vcs.release_tags():
      if tag.startswith(prefix_):
        yield tag

  def release_suffixes(self):
    ''' Generator yielding existing suffixes.
    '''
    poffset = len(self.prefix) + 1
    for tag in self.release_tags():
      yield tag[poffset:]

  def last_suffix(self):
    ''' Return the last release suffix for the specified release prefix, or None.
    '''
    last = None
    for suffix in self.release_suffixes():
      if last is None or suffix > last:
        last = suffix
    return last

  def next_suffix(self):
    ''' Compute the next release suffix.
    '''
    prefix = self.prefix
    last_suffix = self.last_suffix()
    today = isodate(dashed=False)
    if last_suffix is None or last_suffix < today:
      next_suffix = today
    elif last_suffix == today:
      next_suffix = today + '.1'
    else:
      # last_suffix > today, therefore YYYYMMDD.n
      ordinal = last_suffix.split('.', 1)[1]
      if ordinal.startswith('0'):
        raise ValueError("expected last_suffix of the form YYYYMMDD.n, received %r" % (last_suffix,))
      ordinal = int(ordinal)
      next_suffix = today + '.' + str(ordinal + 1)
    return next_suffix

  def next_release_tag(self):
    return self.prefix + '-' + self.next_suffix()

  def paths(self):
    ''' List of paths relevant this name, for use with hg log.
    '''
    prefix = self.prefix
    base = os.path.join(PYLIBTOP, prefix.replace('.', '/'))
    basepy = base + '.py'
    readme = os.path.join(os.path.dirname(base), 'README-' + os.path.basename(base) + '.rst')
    return (base, basepy, readme)

  def log_since(self):
    ''' Generator yielding (files, line) tuples for log lines since the last release for the supplied `prefix`.
    '''
    suffix = self.last_suffix()
    if suffix is None:
      start_tag = ""
    else:
      start_tag = self.tagname(suffix)
    paths = self.paths()
    for files, firstline in self.vcs.log_since(start_tag, paths):
      files = [ filename for filename in files if filename in paths ]
      yield files, firstline

  def uncommitted(self):
    pathset = set(self.paths())
    changed = []
    for path in self.vcs.uncommitted():
      if path in pathset:
        changed.append(path)
    return changed

  def submit_pypi(self):
    return self._submit_pypi('pypi', URL_PYPI_PROD)

  def submit_testpypi(self):
    return self._submit_pypi('testpypi', URL_PYPI_TEST)

  def last_upload(self, pypi_flavour):
    lastvalue_key = "%s-css-%s" % (pypi_flavour, self.prefix)
    last_pypi_release = self.lv.get(lastvalue_key, "")
    return lastvalue_key, last_pypi_release

  def _submit_pypi(self, pypi_flavour, pypi_url):
    with Pfx(pypi_flavour):
      last_suffix = self.last_suffix()
      lastvalue_key, last_pypi_release = self.last_upload(pypi_flavour)
      if last_suffix == last_pypi_release:
        info("already released %r", last_suffix)
      else:
        with Pfx("%r->%r", last_pypi_release, last_suffix):
          PKG = PyPI_Package(pypi_url, self.prefix, last_suffix)
          PKG.check()
          PKG.register()
          PKG.upload()
          self.lv[lastvalue_key] = last_suffix

if __name__ == '__main__':
  sys.exit(main(sys.argv))
