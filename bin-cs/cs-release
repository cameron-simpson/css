#!/usr/bin/env python3
#
# General release stuff for packages.
#   - Cameron Simpson <cs@zip.com.au> 28feb2009
#
# Redo in python; it is getting unmanagable in shell.
#   - Cameron Simpson <cs@zip.com.au> 23jul2015
#

from __future__ import print_function
import sys
import os.path
import re
from subprocess import Popen, PIPE, check_call
from contextlib import contextmanager
from cs.app.lastvalue import LastValues
import cs.cmdutils
from cs.dateutils import isodate
from cs.distinfo import URL_PYPI_PROD, URL_PYPI_TEST, PyPI_Package
from cs.logutils import setup_logging, Pfx, error, warning, info, X

PYLIBTOP = 'lib/python'

USAGE = '''Usage: %s [op [names...]]
  With no op, report all pypi and testpypi lastvalues.
  op:
    last        Report last release issued.
    log         Changelog from last release to now.
    ls          List all release prefixes in use.
    next        Generate a new release number.
    pypi        Upload latest release to PyPI.
    release     Issue a new release tag with change summary.
    testpypi    Upload latest release to test PyPI.'''

##  export      Export release to temporary directory, report directory.
##  freshmeat-submit Announce last release to freshmeat.

def main(argv):
  cmd = os.path.basename(argv.pop(0))
  usage = USAGE % (cmd,)
  setup_logging(cmd)

  badopts = False
  xit = 0

  LV = LastValues()
  VCS = VCS_Hg()

  if not argv:
    for k in sorted(LV.keys()):
      if k.startswith("pypi-css-cs."):
        print(k[12:], LV[k])
  else:
    op = argv.pop(0)
    if argv:
      names = argv
    else:
      names = sorted(VCS.release_prefixes())
    for name in names:
      with Pfx(op):
        with Pfx(name):
          N = ReleaseName(name, VCS, LV)
          if op == 'last':
            print(name, N.last_suffix())
          elif op == 'log':
            first = True
            for files, firstline in N.log_since():
              if first:
                print(name)
                first = False
              files = [ filename[11:] if filename.startswith('lib/python/') else filename for filename in files ]
              print(' ', ' '.join(files)+':', firstline)
          elif op == 'ls':
            for suffix in sorted(N.release_suffixes()):
              print(name, suffix)
          elif op == 'next':
            print(name, N.next_suffix())
          elif op in 'pypi':
            # upload latest release to testpypi
            N.submit_pypi()
          elif op == 'release':
            # issue new release tag
            print("new release for %s ..." % (name,))
            outstanding = N.uncommitted()
            if outstanding:
              print("Uncommited changes exist for these files:")
              for path in sorted(outstanding):
                print(' ', path)
              print("These changes will not be included in the release.")
              if not ask("Proceed with release anyway"):
                error("aborting release at user request")
                return 1
            changes = list(N.log_since())
            if not changes:
              error("no changes since last release, aborting")
              xit = 1
            else:
              print("Changes since the last release:")
              for files, firstline in changes:
                print(" ", ' '.join(files) + ': ' + firstline)
              print()
              with pipefrom('readdottext', keep_stdin=True) as dotfp:
                release_message = dotfp.read().rstrip()
              if not release_message:
                error("empty release message, aborting")
                xit = 1
              else:
                next_tag = N.next_release_tag()
                if not ask("Confirm new release for %r as %r" % (name, next_tag)):
                  error("aborting release at user request")
                  xit = 1
                else:
                  rel_dir = os.path.join('release', next_tag)
                  with Pfx("mkdir(%s)", rel_dir):
                    os.mkdir(rel_dir)
                  summary_filename = os.path.join(rel_dir, 'SUMMARY.txt')
                  with Pfx(summary_filename):
                    with open(summary_filename, 'w') as sfp:
                      print(release_message, file=sfp)
                  changes_filename = os.path.join(rel_dir, 'CHANGES.txt')
                  with Pfx(changes_filename):
                    with open(changes_filename, 'w') as cfp:
                      for files, firstline in changes:
                        print(" ", ' '.join(files) + ': ' + firstline, file=cfp)
                  VCS = N.vcs
                  VCS.add_files(summary_filename, changes_filename)
                  VCS.commit('Release information for %s.\nSummary:\n%s'
                             % (next_tag, release_message),
                             summary_filename, changes_filename)
                  VCS.tag(next_tag)
          elif op in 'testpypi':
            N.submit_testpypi()
          else:
            warning("unrecognised op")
            badopts = True

  if badopts:
    print(usage, file=sys.stderr)
    xit = 2
  return xit

def ask(message):
  ''' Prompt with yes/no question, return true if response is "y" or "yes".
  '''
  print(message, end='? ')
  sys.stdout.flush()
  response = sys.stdin.readline().rstrip().lower()
  return response in ('y', 'yes')

@contextmanager
def pipefrom(*argv, **kw):
  ''' Context manager returning the standard output of a command.
  '''
  P = cs.cmdutils.pipefrom(argv, trace=False, **kw)
  yield P.stdout
  if P.wait() != 0:
    pipecmd = ' '.join(argv)
    raise ValueError("%s: exit status %d" % (pipecmd, P.returncode,))

#                              name       - YYYYMMDD                            [.n]
re_RELEASE_TAG = re.compile(r'([a-z][^-]*)-(2[0-9][0-9][0-9][01][0-9][0-3][0-9](\.[1-9]\d*)?)$')

class VCS(object):

  def release_tags(self):
    ''' Generator yielding the current release tags.
    '''
    for tag in self.tags():
      m = re_RELEASE_TAG.match(tag)
      if m:
        yield tag

  def release_prefixes(self):
    ''' Return a set of the existing release prefixes.
    '''
    tagpfxs = set()
    for tag in self.release_tags():
      tagpfx, _ = tag.split('-', 1)
      tagpfxs.add(tagpfx)
    return tagpfxs

class VCS_Hg(VCS):

  def _pipefrom(self, *hgargs):
    hgargv = ['hg'] + list(hgargs) + ['|']
    return pipefrom('hg', *hgargs)

  def _hgcmd(self, *hgargs):
    print('hg', *hgargs, file=sys.stderr)
    check_call(['hg'] + list(hgargs))

  def tags(self):
    ''' Generator yielding the current tags.
    '''
    with self._pipefrom('tags') as hgfp:
      tags = set()
      for tagline in hgfp:
        tag, _ = tagline.split(None, 1)
        yield tag

  def tag(self, tag_name, revision=None):
    ''' Tag a revision with the supplied `tag`, by default revision "tip".
    '''
    if revision is None:
      revision = 'tip'
    self._hgcmd('tag',  '-r', revision, '--', tag_name)

  def log_since(self, tag, paths):
    with self._pipefrom('log',
                     '-r', tag+':',
                     '--template', '{files}\t{desc|firstline}\n',
                     '--',
                     *paths) as hgfp:
      for hgline in hgfp:
        files, firstline = hgline.split('\t', 1)
        files = files.split()
        firstline = firstline.strip()
        yield files, firstline

  def add_files(self, *paths):
    ''' Add the specified paths to the repository.
    '''
    self._hgcmd('add', *paths)

  def commit(self, message, *paths):
    ''' Commit the specified `paths` with the specified `message`.
    '''
    self._hgcmd('commit', '-m', message, '--', *paths)

  def uncommitted(self):
    ''' Generator yielding uncommited but tracked paths.
    '''
    with self._pipefrom('status') as hgfp:
      for hgline in hgfp:
        s, path = hgline.rstrip().split(' ', 1)
        if s != '?':
          yield path

class ReleaseName(object):
  ''' State surrounding a particular release tag prefix.
  '''

  def __init__(self, prefix, VCS, LV):
    self.prefix = prefix
    self.vcs = VCS
    self.lv = LV

  def tagname(self, suffix):
    tag = self.prefix + '-' + suffix
    m = re_RELEASE_TAG.match(tag)
    if not m:
      raise ValueError("invalid tag made from prefix %r and suffix %r" % (self.prefix, suffix))
    return tag

  def release_tags(self):
    ''' Generator yielding existing release tags.
    '''
    prefix = self.prefix
    prefix_ = prefix + '-'
    for tag in self.vcs.release_tags():
      if tag.startswith(prefix_):
        yield tag

  def release_suffixes(self):
    ''' Generator yielding existing suffixes.
    '''
    poffset = len(self.prefix) + 1
    for tag in self.release_tags():
      yield tag[poffset:]

  def last_suffix(self):
    ''' Return the last release suffix for the specified release prefix, or None.
    '''
    last = None
    for suffix in self.release_suffixes():
      if last is None or suffix > last:
        last = suffix
    return last

  def next_suffix(self):
    ''' Compute the next release suffix.
    '''
    prefix = self.prefix
    last_suffix = self.last_suffix()
    today = isodate(dashed=False)
    if last_suffix is None or last_suffix < today:
      next_suffix = today
    elif last_suffix == today:
      next_suffix = today + '.1'
    else:
      # last_suffix > today, therefore YYYYMMDD.n
      ordinal = last_suffix.split('.', 1)[1]
      if ordinal.startswith('0'):
        raise ValueError("expected last_suffix of the form YYYYMMDD.n, received %r" % (last_suffix,))
      ordinal = int(ordinal)
      next_suffix = today + '.' + str(ordinal + 1)
    return next_suffix

  def next_release_tag(self):
    return self.prefix + '-' + self.next_suffix()

  def paths(self):
    ''' List of paths relevant this name, for use with hg log.
    '''
    prefix = self.prefix
    base = os.path.join(PYLIBTOP, prefix.replace('.', '/'))
    basepy = base + '.py'
    readme = os.path.join(os.path.dirname(base), 'README-' + os.path.basename(base) + '.rst')
    return (base, basepy, readme)

  def log_since(self):
    ''' Generator yielding (files, line) tuples for log lines since the last release for the supplied `prefix`.
    '''
    suffix = self.last_suffix()
    if suffix is None:
      start_tag = ""
    else:
      start_tag = self.tagname(suffix)
    paths = self.paths()
    for files, firstline in self.vcs.log_since(start_tag, paths):
      files = [ filename for filename in files if filename in paths ]
      yield files, firstline

  def uncommitted(self):
    pathset = set(self.paths())
    changed = []
    for path in self.vcs.uncommitted():
      if path in pathset:
        changed.append(path)
    return changed

  def submit_pypi(self):
    return self._submit_pypi('pypi', URL_PYPI_PROD)

  def submit_testpypi(self):
    return self._submit_pypi('testpypi', URL_PYPI_TEST)

  def _submit_pypi(self, pypi_flavour, pypi_url):
    with Pfx(pypi_flavour):
      last_suffix = self.last_suffix()
      lastvalue_key = "%s-css-%s" % (pypi_flavour, self.prefix)
      last_pypi_release = self.lv[lastvalue_key]
      if last_suffix == last_pypi_release:
        info("already released %r", last_suffix)
      else:
        with Pfx("%r->%r", last_pypi_release, last_suffix):
          PKG = PyPI_Package(pypi_url, self.prefix, last_suffix)
          PKG.check()
          PKG.register()
          PKG.upload()
          self.lv[lastvalue_key] = last_suffix

if __name__ == '__main__':
  sys.exit(main(sys.argv))
