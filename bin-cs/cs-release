#!/usr/bin/env python3
#
# General release stuff for packages.
#   - Cameron Simpson <cs@zip.com.au> 28feb2009
#
# Redo in python; it is getting unmanagable in shell.
#   - Cameron Simpson <cs@zip.com.au> 23jul2015
#

from __future__ import print_function
import sys
import os.path
import re
from subprocess import Popen, PIPE, check_call
from contextlib import contextmanager
import importlib
from cs.app.lastvalue import LastValues
import cs.cmdutils
from cs.dateutils import isodate
from cs.distinfo import URL_PYPI_PROD, URL_PYPI_TEST, PyPI_Package
from cs.logutils import setup_logging, Pfx, exception, error, warning, info, X, XP

PYLIBTOP = 'lib/python'

USAGE = '''Usage: %s [op [names...]]
  With no op, report all pypi and testpypi lastvalues.
  op:
    check       Check simple things about a module's DISTINFO map.
    last        Report last release issued.
    log         Changelog from last release to now.
    ls          List all release prefixes in use.
    next        Generate a new release number.
    pypi        Upload latest release to PyPI.
    release     Issue a new release tag with change summary.
    status      Report latest release tag and differing releases at pypi and testpypi.
    testpypi    Upload latest release to test PyPI.'''

##  export      Export release to temporary directory, report directory.
##  freshmeat-submit Announce last release to freshmeat.

def main(argv):
  cmd = os.path.basename(argv.pop(0))
  usage = USAGE % (cmd,)
  setup_logging(cmd)

  badopts = False
  xit = 0

  LV = LastValues()
  VCS = VCS_Hg()

  if not argv:
    for k in sorted(LV.keys()):
      if k.startswith("pypi-css-cs."):
        print(k[9:], LV[k])
  else:
    op = argv.pop(0)
    if argv:
      names = argv
    else:
      names = sorted(VCS.release_prefixes())
    check_map = {}
    for name in names:
      with Pfx(op):
        with Pfx(name):
          N = ReleaseName(name, VCS, LV)
          if op == 'check':
            if name.startswith('cs.'):
              if N.check(check_map=check_map):
                print(name, 'OK')
              else:
                print(name, 'NOT OK')
                xit = 1
            else:
              warning('skipped, not a "cs." module name')
          elif op == 'last':
            print(name, N.last_suffix())
          elif op == 'log':
            first = True
            for files, firstline in N.log_since():
              if first:
                print(name)
                first = False
              files = [ filename[11:] if filename.startswith('lib/python/') else filename for filename in files ]
              print(' ', ' '.join(files)+':', firstline)
          elif op == 'ls':
            for suffix in sorted(N.release_suffixes()):
              print(name, suffix)
          elif op == 'next':
            print(name, N.next_suffix())
          elif op == 'pypi':
            # upload latest release to testpypi
            N.submit_pypi()
          elif op == 'release':
            # issue new release tag
            print("new release for %s ..." % (name,))
            outstanding = N.uncommitted()
            if outstanding:
              print("Uncommited changes exist for these files:")
              for path in sorted(outstanding):
                print(' ', path)
              print("These changes will not be included in the release.")
              if not ask("Proceed with release anyway"):
                error("aborting release at user request")
                return 1
            changes = list(N.log_since())
            if not changes:
              error("no changes since last release, aborting")
              xit = 1
            else:
              print("Changes since the last release:")
              for files, firstline in changes:
                print(" ", ' '.join(files) + ': ' + firstline)
              print()
              with pipefrom('readdottext', keep_stdin=True) as dotfp:
                release_message = dotfp.read().rstrip()
              if not release_message:
                error("empty release message, aborting")
                xit = 1
              else:
                next_tag = N.next_release_tag()
                if not ask("Confirm new release for %r as %r" % (name, next_tag)):
                  error("aborting release at user request")
                  xit = 1
                else:
                  rel_dir = os.path.join('release', next_tag)
                  with Pfx("mkdir(%s)", rel_dir):
                    os.mkdir(rel_dir)
                  summary_filename = os.path.join(rel_dir, 'SUMMARY.txt')
                  with Pfx(summary_filename):
                    with open(summary_filename, 'w') as sfp:
                      print(release_message, file=sfp)
                  changes_filename = os.path.join(rel_dir, 'CHANGES.txt')
                  with Pfx(changes_filename):
                    with open(changes_filename, 'w') as cfp:
                      for files, firstline in changes:
                        print(" ", ' '.join(files) + ': ' + firstline, file=cfp)
                  VCS = N.vcs
                  VCS.add_files(summary_filename, changes_filename)
                  VCS.commit('Release information for %s.\nSummary:\n%s'
                             % (next_tag, release_message),
                             summary_filename, changes_filename)
                  VCS.tag(next_tag)
          elif op == 'status':
            tagged = N.last_suffix()
            result = [name, tagged]
            for pypi_flavour in 'testpypi', 'pypi':
              lvkey, last_upload = N.last_upload(pypi_flavour)
              if last_upload != tagged:
                result.append("%s:%s" % (pypi_flavour, last_upload))
            print(*result)
          elif op == 'testpypi':
            N.submit_testpypi()
          else:
            warning("unrecognised op")
            badopts = True

  if badopts:
    print(usage, file=sys.stderr)
    xit = 2
  return xit

def ask(message):
  ''' Prompt with yes/no question, return true if response is "y" or "yes".
  '''
  print(message, end='? ')
  sys.stdout.flush()
  response = sys.stdin.readline().rstrip().lower()
  return response in ('y', 'yes')

@contextmanager
def pipefrom(*argv, **kw):
  ''' Context manager returning the standard output of a command.
  '''
  P = cs.cmdutils.pipefrom(argv, trace=False, **kw)
  yield P.stdout
  if P.wait() != 0:
    pipecmd = ' '.join(argv)
    raise ValueError("%s: exit status %d" % (pipecmd, P.returncode,))

def check_module(name, silent, check_map):
  ''' Perform various sanity checks on a module.
      Actually a caching wrapper for the _check_module function.
  '''
  if check_map is None:
    check_map = {}
  try:
    checked = check_map[name]
  except KeyError:
    # never checked: run check now with slot markered None ==> in progress
    check_map[name] = None
    checked = _check_module(name, silent, check_map)
    check_map[name] = checked
  else:
    # already in progress?
    if checked is None:
      error("recursion: already checking %r", name)
      return False
    # return cached result if silent
    if silent:
      return checked
    # not silent: preform check regardless
    check_map[name] = None
    checked = _check_module(name, silent, check_map)
    check_map[name] = checked
  return checked

def _check_module(name, silent, check_map):
  ''' Real module check.
  '''
  ok = True
  try:
    M = importlib.import_module(name)
  except ImportError as e:
    silent or error("import_module: %s", e)
    return False
  except SyntaxError as e:
    silent or exception("import_module: %s", e)
    return False
  try:
    D = getattr(M, 'DISTINFO')
  except AttributeError:
    silent or error("no DISTINFO")
    D = {}
  with Pfx('DISTINFO'):
    install_requires = D.get('install_requires')
    if install_requires is None:
      silent or error("missing DISTINFO[install_requires]")
      ok = False
      install_requires = D.get('requires')
      if install_requires is None:
        install_requires = ()
      else:
        silent or warning("working off DISTINFO[requires]=%r", install_requires)
    install_requires = set(install_requires)
  filename = M.__file__
  with Pfx(filename):
    with open(filename) as codefp:
      for lineno, line in enumerate(codefp, 1):
        with Pfx(lineno):
          if line.startswith('import ') or line.startswith('from '):
            words = line.strip().split()
            if not words:
              continue
            if words[0] == 'import' or words[0] == 'from':
              if len(words) < 2:
                silent or warning("missing module name")
                continue
              subimport = words[1]
              if subimport.startswith('cs.'):
                if not check_module(subimport, True, check_map):
                  silent or error("depends on NOT OK module %r", subimport)
                  ok = False
  return ok

#                              name       - YYYYMMDD                            [.n]
re_RELEASE_TAG = re.compile(r'([a-z][^-]*)-(2[0-9][0-9][0-9][01][0-9][0-3][0-9](\.[1-9]\d*)?)$')

class VCS(object):

  def release_tags(self):
    ''' Generator yielding the current release tags.
    '''
    for tag in self.tags():
      m = re_RELEASE_TAG.match(tag)
      if m:
        yield tag

  def release_prefixes(self):
    ''' Return a set of the existing release prefixes.
    '''
    tagpfxs = set()
    for tag in self.release_tags():
      tagpfx, _ = tag.split('-', 1)
      tagpfxs.add(tagpfx)
    return tagpfxs

class VCS_Hg(VCS):

  def _pipefrom(self, *hgargs):
    hgargv = ['hg'] + list(hgargs) + ['|']
    return pipefrom('hg', *hgargs)

  def _hgcmd(self, *hgargs):
    print('hg', *hgargs, file=sys.stderr)
    check_call(['hg'] + list(hgargs))

  def tags(self):
    ''' Generator yielding the current tags.
    '''
    with self._pipefrom('tags') as hgfp:
      tags = set()
      for tagline in hgfp:
        tag, _ = tagline.split(None, 1)
        yield tag

  def tag(self, tag_name, revision=None):
    ''' Tag a revision with the supplied `tag`, by default revision "tip".
    '''
    if revision is None:
      revision = 'tip'
    self._hgcmd('tag',  '-r', revision, '--', tag_name)

  def log_since(self, tag, paths):
    with self._pipefrom('log',
                     '-r', tag+':',
                     '--template', '{files}\t{desc|firstline}\n',
                     '--',
                     *paths) as hgfp:
      for hgline in hgfp:
        files, firstline = hgline.split('\t', 1)
        files = files.split()
        firstline = firstline.strip()
        yield files, firstline

  def add_files(self, *paths):
    ''' Add the specified paths to the repository.
    '''
    self._hgcmd('add', *paths)

  def commit(self, message, *paths):
    ''' Commit the specified `paths` with the specified `message`.
    '''
    self._hgcmd('commit', '-m', message, '--', *paths)

  def uncommitted(self):
    ''' Generator yielding uncommited but tracked paths.
    '''
    with self._pipefrom('status') as hgfp:
      for hgline in hgfp:
        s, path = hgline.rstrip().split(' ', 1)
        if s != '?':
          yield path

class ReleaseName(object):
  ''' State surrounding a particular release tag prefix.
  '''

  def __init__(self, prefix, VCS, LV):
    self.prefix = prefix
    self.vcs = VCS
    self.lv = LV

  def check(self, silent=False, check_map=None):
    ''' Perform various sanity checks on the named module, return true if all pass.
    '''
    return check_module(self.prefix, silent, check_map)

  def tagname(self, suffix):
    tag = self.prefix + '-' + suffix
    m = re_RELEASE_TAG.match(tag)
    if not m:
      raise ValueError("invalid tag made from prefix %r and suffix %r" % (self.prefix, suffix))
    return tag

  def release_tags(self):
    ''' Generator yielding existing release tags.
    '''
    prefix = self.prefix
    prefix_ = prefix + '-'
    for tag in self.vcs.release_tags():
      if tag.startswith(prefix_):
        yield tag

  def release_suffixes(self):
    ''' Generator yielding existing suffixes.
    '''
    poffset = len(self.prefix) + 1
    for tag in self.release_tags():
      yield tag[poffset:]

  def last_suffix(self):
    ''' Return the last release suffix for the specified release prefix, or None.
    '''
    last = None
    for suffix in self.release_suffixes():
      if last is None or suffix > last:
        last = suffix
    return last

  def next_suffix(self):
    ''' Compute the next release suffix.
    '''
    prefix = self.prefix
    last_suffix = self.last_suffix()
    today = isodate(dashed=False)
    if last_suffix is None or last_suffix < today:
      next_suffix = today
    elif last_suffix == today:
      next_suffix = today + '.1'
    else:
      # last_suffix > today, therefore YYYYMMDD.n
      ordinal = last_suffix.split('.', 1)[1]
      if ordinal.startswith('0'):
        raise ValueError("expected last_suffix of the form YYYYMMDD.n, received %r" % (last_suffix,))
      ordinal = int(ordinal)
      next_suffix = today + '.' + str(ordinal + 1)
    return next_suffix

  def next_release_tag(self):
    return self.prefix + '-' + self.next_suffix()

  def paths(self):
    ''' List of paths relevant this name, for use with hg log.
    '''
    prefix = self.prefix
    base = os.path.join(PYLIBTOP, prefix.replace('.', '/'))
    basepy = base + '.py'
    readme = os.path.join(os.path.dirname(base), 'README-' + os.path.basename(base) + '.rst')
    return (base, basepy, readme)

  def log_since(self):
    ''' Generator yielding (files, line) tuples for log lines since the last release for the supplied `prefix`.
    '''
    suffix = self.last_suffix()
    if suffix is None:
      start_tag = ""
    else:
      start_tag = self.tagname(suffix)
    paths = self.paths()
    for files, firstline in self.vcs.log_since(start_tag, paths):
      files = [ filename for filename in files if filename in paths ]
      yield files, firstline

  def uncommitted(self):
    pathset = set(self.paths())
    changed = []
    for path in self.vcs.uncommitted():
      if path in pathset:
        changed.append(path)
    return changed

  def submit_pypi(self):
    return self._submit_pypi('pypi', URL_PYPI_PROD)

  def submit_testpypi(self):
    return self._submit_pypi('testpypi', URL_PYPI_TEST)

  def last_upload(self, pypi_flavour):
    lastvalue_key = "%s-css-%s" % (pypi_flavour, self.prefix)
    last_pypi_release = self.lv.get(lastvalue_key, "")
    return lastvalue_key, last_pypi_release

  def _submit_pypi(self, pypi_flavour, pypi_url):
    with Pfx(pypi_flavour):
      last_suffix = self.last_suffix()
      lastvalue_key, last_pypi_release = self.last_upload(pypi_flavour)
      if last_suffix == last_pypi_release:
        info("already released %r", last_suffix)
      else:
        with Pfx("%r->%r", last_pypi_release, last_suffix):
          PKG = PyPI_Package(pypi_url, self.prefix, last_suffix)
          PKG.check()
          PKG.register()
          PKG.upload()
          self.lv[lastvalue_key] = last_suffix

if __name__ == '__main__':
  sys.exit(main(sys.argv))
