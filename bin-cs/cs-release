#!/usr/bin/env python3
#
# General release stuff for packages.
#   - Cameron Simpson <cs@cskk.id.au> 28feb2009
#
# Redo in python; it is getting unmanagable in shell.
#   - Cameron Simpson <cs@cskk.id.au> 23jul2015
#

from __future__ import print_function
from collections import defaultdict
from contextlib import contextmanager
from getopt import GetoptError
import importlib
import os
import os.path
from os.path import (
    basename,
    dirname,
    isdir as isdirpath,
    isfile as isfilepath,
    join as joinpath,
    exists as pathexists,
)
import re
import sys
from tempfile import TemporaryDirectory
from cs.app.lastvalue import LastValues
from cs.cmdutils import BaseCommand
from cs.dateutils import isodate
from cs.deco import cachedmethod
from cs.distinfo import (
    URL_PYPI_PROD, PyPI_Package, tag_version as vcstag_version,
    version_tag as version_vcstag
)
from cs.fstags import TagFile
from cs.lex import cutsuffix
from cs.logutils import error, warning, info, status
from cs.pfx import Pfx, pfx_method, XP
import cs.psutils
from cs.py.func import prop
from cs.py.modules import direct_imports
from cs.upd import Upd
from cs.vcs.hg import VCS_Hg
from icontract import require

from cs.x import X

def main(argv=None, cmd=None):
  ''' Main command line.
  '''
  return CSReleaseCommand().run(argv, cmd=cmd)

# the top level TagFile containing package state information
PKG_TAGS = 'pkg_tags'

# the path from the top level to the package files
PYLIBTOP = 'lib/python'

# the prefix of interesting packages
MODULE_PREFIX = 'cs.'

TAG_PYPI_RELEASE = 'pypi.release'

# defaults for packages without their own specifics
DISTINFO_DEFAULTS = {
    'url': 'https://bitbucket.org/cameron_simpson/css/commits/all',
}

re_RELEASE_TAG = re.compile(
    #  name       - YYYYMMDD                            [.n]
    r'([a-z][^-]*)-(2[0-9][0-9][0-9][01][0-9][0-3][0-9](\.[1-9]\d*)?)$'
)

class CSReleaseCommand(BaseCommand):

  GETOPT_SPEC = 'fqv'
  USAGE_FORMAT = '''Usage: {cmd} [-f] subcommand [subcommand-args...]
      -f  Force. Sanity checks that would stop some actions normally
          will not prevent them.
      -q  Quiet. Not verbose.
      -v  Verbose.
  '''

  @classmethod
  def apply_defaults(cls, options):
    cmd = basename(options.cmd)
    if cmd.endswith('.py'):
      cmd = 'cs-release'
    options.cmd = cmd
    # verbose if stderr is a tty
    try:
      options.verbose = sys.stderr.isatty()
    except AttributeError:
      options.verbose = False
    # TODO: get from cs.logutils?
    options.verbose = sys.stderr.isatty()
    options.force = False
    options.vcs = VCS_Hg()
    options.pkg_tagsets = TagFile(joinpath(options.vcs.get_topdir(), PKG_TAGS))
    options.last_values = LastValues()
    options.modules = Modules()
    options.modules.options = options

  @staticmethod
  def apply_opts(opts, options):
    ''' Apply the command line options mapping `opts` to `options`.
    '''
    for opt, val in opts:
      if opt == '-f':
        options.force = True
      elif opt == '-q':
        options.verbose = False
      elif opt == '-v':
        options.verbose = True
      else:
        raise RuntimeError("unhandled option: %s" % (opt,))

  ##  export      Export release to temporary directory, report directory.
  ##  freshmeat-submit Announce last release to freshmeat.

  @staticmethod
  def cmd_check(argv, options):
    ''' Usage: {cmd} pkg_name...
          Perform sanity checks on the names packages.
    '''
    if not argv:
      raise GetoptError("missing package names")
    xit = 0
    with Upd(sys.stderr):
      for pkg_name in argv:
        with Pfx(pkg_name):
          status("...")
          pkg = options.modules[pkg_name]
          problems = pkg.problems()
          status('')
          if problems:
            xit = 1
            for problem in problems:
              if isinstance(problem, str):
                warning(problem)
              elif isinstance(problem, list):
                label, *values = problem
                warning("%s:", label)
                for subproblem in values:
                  warning("  %s", subproblem)
              else:
                for subpkg, subproblems in sorted(problem.items()):
                  warning(
                      "%s: %s", subpkg, ', '.join(
                          subproblem
                          if isinstance(subproblem, str) else repr(subproblem)
                          for subproblem in subproblems
                      )
                  )
    return xit

  @staticmethod
  def cmd_checkout(argv, options):
    ''' Usage: {cmd} pkg_name [revision]
          Check out the named package.
    '''
    if not argv:
      raise GetoptError("missing package name")
    pkg = options.modules[argv.pop(0)]
    if argv:
      revision = argv.pop(0)
    else:
      revision = pkg.latest_release_vcstag or "tip"
    if argv:
      raise GetoptError("extra arguments: %r" % (argv,))
    info("checking out revision %r", revision)
    checkout_dir = pkg.name + '--' + revision
    pkg.checkout(revision, checkout_dir)
    print(checkout_dir)

  @staticmethod
  def cmd_last(argv, options):
    ''' Usage: {cmd} pkg_names...
          Print the latest release tags for the names packages.
    '''
    if not argv:
      raise GetoptError("missing package names")
    for pkg_name in argv:
      with Pfx(pkg_name):
        pkg = options.modules[pkg_name]
        tag = pkg.latest_release_vcstag
        if tag is None:
          suffix = "NONE"
        else:
          prefix, suffix = tag.split('-', 1)
        print(pkg.name, suffix)

  @staticmethod
  def cmd_log(argv, options):
    ''' Usage: {cmd} pkg_name
          Print the commit log since the latest release.
    '''
    if not argv:
      raise GetoptError("missing package name")
    pkg_name = argv.pop(0)
    if argv:
      raise GetoptError("extra arguments: %r", argv)
    pkg = options.modules[pkg_name]
    for files, firstline in pkg.log_since():
      files = [
          filename[11:] if filename.startswith('lib/python/') else filename
          for filename in files
      ]
      print(' '.join(files) + ':', firstline)

  @staticmethod
  def cmd_ls(argv, options):
    ''' Usage: {cmd}
          List package names and their latst PyPI releases.
    '''
    if argv:
      raise GetoptError("extra arguments: %r" % (argv,))
    tagsets = options.pkg_tagsets
    for pkg_name in sorted(tagsets.keys()):
      if pkg_name.startswith(MODULE_PREFIX):
        pypi_release = tagsets[pkg_name].get(TAG_PYPI_RELEASE)
        if pypi_release is not None:
          print(pkg_name, pypi_release)
    return 0

  @staticmethod
  def cmd_export(argv, options):
    ''' Usage: export pkg_name
          Export the package contents.
    '''
    if not argv:
      raise GetoptError("missing package name")
    pkg_name = argv.pop(0)
    if argv:
      raise GetoptError("extra arguments: %r", argv)
    pkg = options.modules[pkg_name]
    path = pkg.export()
    print(path)

  @staticmethod
  def cmd_next(argv, options):
    ''' Usage: next pkg_names...
          Print package names and their next release tag.
    '''
    if not argv:
      raise GetoptError("missing package names")
    for pkg_name in argv:
      with Pfx(pkg_name):
        pkg = options.modules[pkg_name]
        next_version = pkg.next_release_version()
        print(pkg.name, next_version)

  @staticmethod
  def cmd_pypi(argv, options):
    ''' Usage: {cmd} pkg_names...
          Push the named packages to PyPI.
    '''
    if not argv:
      raise GetoptError("missing package names")
    for pkg_name in argv:
      with Pfx(pkg_name):
        pkg = options.modules[pkg_name]
        # upload latest release to pypi
        vcs_tag = pkg.latest_release_vcstag
        pypi_version = pkg.latest_release_version
        pkg.submit_pypi(
            force=options.force, vcs_tag=vcs_tag, pypi_version=pypi_version
        )

  @staticmethod
  def cmd_release(argv, options):
    ''' Usage: {cmd} pkg_name
          Issue a new release for the named package.
    '''
    if not argv:
      raise GetoptError("missing package name")
    pkg_name = argv.pop(0)
    if argv:
      raise GetoptError("extra arguments: %r" % (argv,))
    pkg = options.modules[pkg_name]
    vcs = options.vcs
    xit = 0
    # issue new release tag
    print("new release for %s ..." % (pkg.name,))
    outstanding = list(pkg.uncommitted_paths())
    if outstanding:
      print("uncommitted changes exist for these files:")
      for path in sorted(outstanding):
        print(' ', path)
      error("Aborting release; please commit or shelve/stash these changes.")
      return 1
    changes = list(pkg.log_since())
    if not changes:
      if options.force:
        warning("no commits since last release, making release anyway")
      else:
        error("no changes since last release, not making new release")
        return 1
    print("Changes since the last release:")
    for files, firstline in changes:
      print(" ", ' '.join(files) + ': ' + firstline)
    print()
    with pipefrom('readdottext', keep_stdin=True) as dotfp:
      release_message = dotfp.read().rstrip()
    if not release_message:
      error("empty release message, not making new release")
      xit = 1
    else:
      next_tag = pkg.next_release_tag()
      _, tag_version = next_tag.split('-')
      if not ask("Confirm new release for %r as %r" % (pkg.name, next_tag)):
        error("aborting release at user request")
        xit = 1
      else:
        rel_dir = joinpath('release', next_tag)
        with Pfx("mkdir(%s)", rel_dir):
          os.mkdir(rel_dir)
        summary_filename = joinpath(rel_dir, 'SUMMARY.txt')
        with Pfx(summary_filename):
          with open(summary_filename, 'w') as sfp:
            print(release_message, file=sfp)
        changes_filename = joinpath(rel_dir, 'CHANGES.txt')
        with Pfx(changes_filename):
          with open(changes_filename, 'w') as cfp:
            for files, firstline in changes:
              print(' '.join(files) + ': ' + firstline, file=cfp)
        pkg.patch__version__(tag_version)
        vcs.add_files(summary_filename, changes_filename)
        vcs.commit(
            'Release information for %s.\nSummary:\n%s' %
            (next_tag, release_message), summary_filename, changes_filename
        )
        vcs.tag(next_tag)
    return xit

def release_tags(vcs):
  ''' Generator yielding the current release tags.
  '''
  for tag in vcs.tags():
    m = re_RELEASE_TAG.match(tag)
    if m:
      yield tag

def release_prefixes(vcs):
  ''' Return a set of the existing release prefixes.
  '''
  tagpfxs = set()
  for tag in release_tags(vcs):
    tagpfx, _ = tag.split('-', 1)
    tagpfxs.add(tagpfx)
  return tagpfxs

def clean_release_entry(entry):
  lines = filter(
      lambda line: (
          line and line != 'Summary:' and not line.
          startswith('Release information for ')
      ),
      entry.strip().split('\n')
  )
  if len(lines) > 1:
    # Multiple lines become a MarkDown bullet list.
    lines = ['* ' + line for line in lines]
  return '\n'.join(lines)

def pypipkg(pkgname, vcs, pypi_url=None):
  ''' Return a `PyPI_Package` for `pkgname`.
  '''
  if pypi_url is None:
    pypi_url = URL_PYPI_PROD
  release_log = list(vcs.release_log(pkgname))
  release_vcs_tag, release_entry = release_log[0]
  package_release_version = vcstag_version(release_vcs_tag)
  release_entry = clean_release_entry(release_entry)
  preamble_md = f'*Latest release {package_release_version}*:\n{release_entry}'
  postamble_parts = []
  for vcs_tag, entry in release_log:
    release_number = vcs_tag.split('-', 1)[1]
    release_entry = clean_release_entry(entry)
    postamble_parts.append(f'*Release {release_number}*:\n{release_entry}')
  postamble_md = '\n\n# Release Log\n\n' + '\n\n'.join(postamble_parts)
  return PyPI_Package(
      pypi_url,
      pkgname,
      package_release_version,
      defaults=dict(DISTINFO_DEFAULTS),
      preamble_md=preamble_md,
      postamble_md=postamble_md
  )

def ask(message, fin=None, fout=None):
  ''' Prompt with yes/no question, return true if response is "y" or "yes".
  '''
  if fin is None:
    fin = sys.stdin
  if fout is None:
    fout = sys.stderr
  print(message, end='? ', file=fout)
  fout.flush()
  response = fin.readline().rstrip().lower()
  return response in ('y', 'yes')

@contextmanager
def pipefrom(*argv, **kw):
  ''' Context manager returning the standard output file object of a command.
  '''
  P = cs.psutils.pipefrom(argv, trace=False, **kw)
  yield P.stdout
  if P.wait() != 0:
    pipecmd = ' '.join(argv)
    raise ValueError("%s: exit status %d" % (
        pipecmd,
        P.returncode,
    ))

class Modules(defaultdict):
  ''' An autopopulating dict of mod_name->Module.
  '''

  def __missing__(self, mod_name):
    assert isinstance(mod_name, str), "mod_name=%r" % (mod_name,)
    M = Module(mod_name, self.options)
    self[mod_name] = M
    return M

class Module(object):
  ''' Metadata about a Python module.
  '''

  @pfx_method(use_str=True)
  def __init__(self, name, options):
    self.name = name
    self._module = None
    self.options = options
    self._distinfo = None
    self._checking = False
    self._module_problems = None

  def __str__(self):
    return "%s(%r)" % (type(self).__name__, self.name)
  @prop
  def modules(self):
    ''' The modules from `self.options`.
    '''
    return self.options.modules

  @prop
  def vcs(self):
    ''' The VCS from `self.options`.
    '''
    return self.options.vcs

  @prop
  def module(self):
    ''' The Module for this package name.
    '''
    M = self._module
    if M is None:
      with Pfx("import %r", self.name):
        try:
          M = importlib.import_module(self.name)
        except ImportError as e:
          warning("ImportError: %s", e)
          M = None
        except SyntaxError as e:
          warning("SyntaxError: %s", e)
          M = None
      self._module = M
    return M

  def __str__(self):
    return "%s[%r]" % (type(self).__name__, self.name)

  @pfx_method(use_str=True)
  def isthirdparty(self):
    return '/site-packages/' in getattr(self, '__file__', '')

  @pfx_method(use_str=True)
  def isstdlib(self):
    ''' Test if this module exists in the stdlib.
    '''
    if self.name.startswith(MODULE_PREFIX):
      return False
    if self.isthirdparty():
      return False
    return True

  @prop
  @cachedmethod
  @pfx_method(use_str=True)
  def package_name(self):
    ''' The name of the package containing this module,
        or `None` if this is not inside a package.
    '''
    M = self.module
    if M is None:
      error("self.module is None")
      return None
    tested_name = cutsuffix(self.name, '_tests')
    if tested_name is not self.name:
      # foo_tests is considers part of foo
      return self.modules[tested_name].package_name
    try:
      pkg_name = M.__package__
    except AttributeError:
      warning("self.module has no __package__: %r", sorted(dir(M)))
      return None
    return pkg_name

  @prop
  @pfx_method(use_str=True)
  def package(self):
    name = self.package_name
    if name is None:
      raise ValueError("self.package_name is None")
    return self.modules[name]

  @prop
  def in_package(self):
    ''' Is this module part of a package?
    '''
    return self.package_name != self.name

  @prop
  def is_package(self):
    ''' Is this module a package?
    '''
    pkg_name = self.package_name
    return pkg_name is not None and pkg_name == self.name

  @property
  def pkg_tags(self):
    ''' The `TagSet` for this package.
    '''
    return self.options.pkg_tagsets[self.name]

  @cachedmethod
  def release_tags(self):
    ''' Return the release tags for this package.
    '''
    prefix = self.name + '-'
    return [
        vcs_tag for vcs_tag in release_tags(self.vcs)
        if vcs_tag.startswith(prefix)
    ]

  def release_log(self):
    ''' Generator yielding `cs.vcs.ReleaseLogEntry` instances
        for our release tags in reverse tag order (most recent first).
    '''
    return self.vcs.release_log(self.name)

  @property
  def latest_release_vcstag(self):
    ''' The latest VCS release tag or `None`.
    '''
    tags = self.release_tags()
    if not tags:
      return None
    return max(tags)

  def latest_release_version(self):
    vcs_tag = self.latest_release_vcstag
    if vcs_tag is None:
      return None
    return vcs_tag.split('-', 1)[1]

  def next_release_version(self):
    ''' Compute the next release version.
    '''
    vcs_tag = self.latest_release_vcstag
    today = isodate(dashed=False)
    if vcs_tag:
      with Pfx(vcs_tag):
        current_version = vcstag_version(vcs_tag)
        if current_version == today:
          next_version = today + '.1'
        elif current_version < today:
          next_version = today
        else:
          # current_version > today: compute next .n extension
          base_version, numerator = current_version.split('.')
          if base_version > today:
            warning(
                "issuing a future version: today=%r, base version=%r", today,
                base_version
            )
          next_version = base_version + '.' + str(int(numerator) + 1)
    else:
      next_version = today + '.1'
    return next_version

  def next_release_vcs_tag(self):
    ''' Compute the next release VCS tag.
    '''
    return version_vcstag(self.name, self.next_release_version())

  @property
  def latest_pypi_version(self):
    return self.pkg_tags.get(TAG_PYPI_RELEASE)

  @latest_pypi_version.setter
  def latest_pypi_version(self, new_suffix):
    self.pkg_tags.set(TAG_PYPI_RELEASE, new_suffix)
    self.pkg_tags.save()

  @require(lambda pypi_flavour: isinstance(pypi_flavour, str))
  @require(lambda pypi_url: isinstance(pypi_url, str))
  @require(lambda force: force is True or force is False)
  def submit_pypi(
      self,
      pypi_flavour='pypi',
      pypi_url=URL_PYPI_PROD,
      force=False,
      vcs_tag=None,
      pypi_version=None
  ):
    ''' Submit the latest release of this package to PyPI.

        Parameters:
        * `pypi_flavour`: the PyPI instance to use, default `'pypi'`
        * `pypi_url`: the PyPI base URL to use, default `URL_PYPI_PROD`
        * `force`: optional force setting, defauult `False`.
          If true, do the upload even if the up to date checks fail.
        * `vcs_tag`: the VCS release tag to use for the upload,
          default from `self.latest_release_vcstag`
        * `pypi_version`: the PyPI version to upload as,
          default from `self.latest_release_version`
    '''
    if vcs_tag is None:
      vcs_tag = self.latest_release_vcstag
    vcs_version = self.tag_version(vcs_tag)
    if pypi_version is None:
      pypi_version = vcs_version
    if not self.check_uptodate():
      warning("check fails")
      if force:
        warning("submitting anyway")
      else:
        return
    with Pfx(pypi_flavour):
      with self.checkout(vcs_tag) as checkout_path:
        self.prepare_package(checkout_path)
      if vcs_tag == self.latest_release_vcstag:
        latest_version = self.latest_release_version
        latest_pypi_version = self.latest_pypi_version
      if latest_version == latest_pypi_version:
        info("already released %r", latest_pypi_version)
        if force:
          warning("submitting anyway")
        else:
          return
      with Pfx("%s->%r",
               repr(latest_pypi_version) if latest_pypi_version else '',
               latest_version):
        PKG = pypipkg(self.name, self.vcs)
        PKG.upload()
        self.latest_pypi_version = latest_version

  def export(self):
    latest_version = self.latest_release_version
    pkg_dir = "%s-%s" % (self.name, latest_version)
    print('create %s ...' % (pkg_dir,))
    with Pfx("mkdir(%s)", pkg_dir):
      os.mkdir(pkg_dir)
    PKG = pypipkg(self.name, self.vcs)
    PKG.make_package(pkg_dir)
    return pkg_dir

  @prop
  def basename(self):
    ''' The last component of the package name.
    '''
    return self.name.split('.')[-1]

  @prop
  def basepath(self):
    ''' The base path for this package.
    '''
    return os.sep.join([PYLIBTOP] + self.name.split('.'))

  @prop
  def toppath(self):
    ''' The top file of the package:
        basepath/__init__.py for packages
        and basepath.py for modules.
    '''
    basepath = self.basepath
    if isdirpath(basepath):
      return joinpath(basepath, '__init__.py')
    return basepath + '.py'

  @cachedmethod
  def paths(self):
    ''' Yield the paths associated with this package.

        Note: this is based on the current checkout state instead
        of some revision because "hg archive" complains if globs
        match no paths, and aborts.
    '''
    pathlist = []
    basepath = self.basepath
    if isdirpath(basepath):
      for subpath, dirnames, filenames in os.walk(basepath):
        if not subpath.startswith(basepath):
          info("SKIP %s", subpath)
          continue
        for filename in sorted(filenames):
          if not (filename.endswith('.pyc') or filename.endswith('.o')):
            pathlist.append(joinpath(subpath, filename))
    else:
      base = self.basename
      updir = dirname(basepath)
      for filename in sorted(os.listdir(updir)):
        filepath = joinpath(updir, filename)
        if ((filename.startswith(base + '.')
             or filename.startswith(base + '_'))
            and not (filename.endswith('.pyc') or filename.endswith('.o'))
            and isfilepath(filepath)):
          if isfilepath(filepath):
            pathlist.append(filepath)
          else:
            info("ignore %r, not a file", filepath)
    return pathlist

  def checkout(self, revision, dirpath):
    ''' Check out the specified `revision` to the directory `dirpath`.
    '''
    with Pfx("checkout %r ==> %r", revision, dirpath):
      if pathexists(dirpath):
        raise ValueError("already exists")
      hg_argv = ['archive', '-r', revision]
      hg_argv.extend(self.vcs.hg_include(self.paths()))
      hg_argv.extend(['--', dirpath])
      return self.vcs.hg_cmd(*hg_argv)

  @pfx_method(use_str=True)
  def log_since(self, vcstag=None):
    ''' Generator yielding (files, line) tuples
        for log lines since the last release for the supplied `prefix`.
    '''
    if vcstag is None:
      vcstag = self.latest_release_vcstag
      if vcstag is None:
        vcstag = "0"
        warning(f"no release tags, starting from revision {vcstag}")
    paths = self.paths()
    return (
        ([filename
          for filename in files
          if filename in paths], firstline)
        for files, firstline in self.vcs.log_since(vcstag, paths)
    )

  def uncommitted_paths(self):
    ''' Generator yielding paths relevant to this package
        with uncommitted changes.
    '''
    return self.vcs.uncommitted(self.paths())

  @pfx_method(use_str=True)
  def patch__version__(self, version):
    version_line = '__version__ = ' + repr(version) + '\n'
    toppath = self.toppath
    with Pfx(toppath):
      if toppath in self.uncommitted_paths():
        raise ValueError("has uncommited changes")
      with open(toppath) as tf:
        lines = tf.readlines()
      patched = False
      distinfo_index = None
      for i, line in enumerate(lines):
        if line.startswith('DISTINFO = '):
          distinfo_index = i
        elif line.startswith('__version__ = '):
          lines[i] = version_line
          patched = True
          break
      if not patched:
        if distinfo_index is None:
          raise ValueError("no __version__ line and no DISTINFO line")
        lines[distinfo_index:distinfo_index] = version_line, '\n'
      with Pfx("rewrite %r", toppath):
        with open(toppath, 'w') as tf:
          for line in lines:
            tf.write(line)
      self.vcs.commit(
          self.name + ': set __version__ to ' + repr(version), toppath
      )

  @prop
  def dirpath(self):
    M = self.module
    if M is None:
      return None
    if not self.is_package:
      return None
    return os.path.dirname(M.__file__)

  @prop
  def DISTINFO(self):
    D = self._distinfo
    if D is None:
      with Pfx("%s.DISTINFO", self.name):
        D = {}
        M = self.module
        if M is None:
          warning("cannot load module")
        else:
          try:
            D = M.DISTINFO
          except AttributeError:
            pkg_name = self.package_name
            if pkg_name is None or pkg_name == self.name:
              warning("missing DISTINFO")
            else:
              # look in the package
              P = self.modules[pkg_name]
              PM = P.module
              try:
                D = PM.DISTINFO
              except AttributeError:
                warning("missing and also missing from package %r", pkg_name)
              else:
                ##warning("DISTINFO from package %r", pkg_name)
                pass
          else:
            ##warning("DISTINFO from this module")
            pass
        self._distinfo = D
    return D

  @prop
  def requires(self):
    ''' Return other nonstdlib packages required by this module.
    '''
    return self.DISTINFO.get('install_requires', [])

  @pfx_method(use_str=True)
  def problems(self):
    ''' Sanity check of this module.

        This is a list of problems,
        each of which is either a string
        or a mapping of required package name to its problems.
    '''
    problems = self._module_problems
    if problems is not None:
      return problems
    problems = self._module_problems = []
    subproblems = defaultdict(list)
    pkg_name = self.package_name
    if pkg_name is None:
      pkg_prefix = None
    else:
      pkg_prefix = pkg_name + '.'
    M = self.module
    import_names = []
    for import_name in direct_imports(M.__file__, self.name):
      if self.modules[import_name].isstdlib():
        continue
      if import_name.endswith('_tests'):
        continue
      if import_name == pkg_name:
        # tests usually import the package - this is not a dependency
        continue
      if pkg_prefix and import_name.startswith(pkg_prefix):
        # package components are not a dependency
        continue
      import_names.append(import_name)
    import_names = sorted(set(import_names))
    # check the DISTINFO
    distinfo = getattr(M, 'DISTINFO', None)
    if not distinfo:
      problems.append("missing DISTINFO")
    else:
      distinfo_requires = distinfo.get('install_requires')
      if distinfo_requires is None:
        problems.append("missing DISTINFO[install_requires]")
      else:
        if sorted(distinfo_requires) != import_names:
          problems.append(
              "DISTINFO[install_requires=%r] != direct_imports=%r" %
              (distinfo_requires, sorted(import_names))
          )
        for import_name in import_names:
          if not import_name.startswith(MODULE_PREFIX):
            continue
          import_problems = self.modules[import_name].problems()
          if import_problems:
            subproblems[import_name] = import_problems
    for required_name in sorted(self.requires):
      if required_name not in self.imported_names:
        problems.append("requirement %r not imported" % (required_name,))
    # check that this package has files
    if not self.paths():
      problems.append("no files")
    # check for unrelease commit logs
    unreleased_logs = list(self.log_since())
    if unreleased_logs:
      problems.append(['unreleased commits']+unreleased_logs)
    # check for uncommited changes
    paths = self.paths()
    changed_paths = [
        changed_path for changed_path in self.vcs.uncommitted()
        if changed_path in paths
    ]
    if changed_paths:
      problems.append("%d modified files", len(changed_paths))
    # append submodule problems if present
    if subproblems:
      problems.append(subproblems)
    return problems

  @prop
  @cachedmethod
  def imported_names(self):
    ''' Return a set containing the module names imported by this module
        both directly and indirectly.
    '''
    subnames = set()
    for path in self.paths():
      subimports = direct_imports(path, self.name)
      subnames.update(subimports)
    return subnames

  def imported_modules(self, prefix=MODULE_PREFIX):
    ''' Generator yielding directly imported Modules.
    '''
    for name in sorted(self.imported_names):
      if name.startswith(prefix) and name != self.name:
        yield self.modules[name]

if __name__ == '__main__':
  sys.exit(main(sys.argv))
