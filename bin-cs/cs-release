#!/usr/bin/env python3
#
# General release stuff for packages.
#   - Cameron Simpson <cs@cskk.id.au> 28feb2009
#
# Redo in python; it is getting unmanagable in shell.
#   - Cameron Simpson <cs@cskk.id.au> 23jul2015
#

from __future__ import print_function
from collections import defaultdict
from getopt import GetoptError
import sys
import os
import os.path
import re
from subprocess import Popen, PIPE, check_call
from contextlib import contextmanager
import importlib
from cs.app.lastvalue import LastValues
import cs.cmdutils
from cs.dateutils import isodate
from cs.deco import cached
from cs.distinfo import URL_PYPI_PROD, URL_PYPI_TEST, PyPI_Package
from cs.logutils import setup_logging, exception, error, warning, info
from cs.pfx import Pfx, XP
from cs.py.func import prop
from cs.py.modules import module_files
from cs.x import X

PYLIBTOP = 'lib/python'

# defaults for packages without their own specifics
DISTINFO_DEFAULTS = {
    'url': 'https://bitbucket.org/cameron_simpson/css/commits/all',
}

USAGE = '''Usage: %s [-f] [op [names...]]
  -f  Force. Sanity checks that would stop some actions will not prevent them.
  With no op, report all pypi and testpypi lastvalues.
  op:
    check       Check simple things about a module's DISTINFO map.
    last        Report last release issued.
    log         Changelog from last release to now.
    ls          List all release prefixes in use.
    next        Generate a new release number.
    pypi        Upload latest release to PyPI.
    release     Issue a new release tag with change summary.
    status      Report latest release tag and differing releases at pypi and testpypi.
    testpypi    Upload latest release to test PyPI.'''

##  export      Export release to temporary directory, report directory.
##  freshmeat-submit Announce last release to freshmeat.

def main(argv):
  cmd = os.path.basename(argv.pop(0))
  usage = USAGE % (cmd,)
  setup_logging(cmd)

  force = False

  xit = 0
  badopts = False

  if argv and argv[0] == '-f':
    argv.pop(0)
    force = True
  modules = Modules()
  LV = LastValues()
  VCS = VCS_Hg()

  if not argv:
    for k in sorted(LV.keys()):
      if k.startswith("pypi-css-cs."):
        print(k[9:], LV[k])
    return 0

  op = argv.pop(0)
  with Pfx(op):
    if argv:
      names = argv
    else:
      # all the release tags starting with "cs."
      names = [
          name
          for name in sorted(VCS.release_prefixes())
          if name.startswith('cs.')
      ]
    for name in names:
      if xit != 0:
        break
      with Pfx(name):
        N = ReleaseName(name, modules, VCS, LV)
        if op == 'check':
          if name.startswith('cs.'):
            if N.check():
              print(name, 'OK')
            else:
              print(name, 'NOT OK')
              xit = 1
          else:
            warning('not a "cs." module name')
            xit = 1
        elif op == 'last':
          print(name, N.last_suffix())
        elif op == 'log':
          first = True
          for files, firstline in N.log_since():
            if first:
              print(name)
              first = False
            files = [ filename[11:] if filename.startswith('lib/python/') else filename for filename in files ]
            print(' ', ' '.join(files)+':', firstline)
        elif op == 'ls':
          for suffix in sorted(N.release_suffixes()):
            print(name, suffix)
        elif op == 'next':
          print(name, N.next_suffix())
        elif op == 'pypi':
          # upload latest release to pypi
          N.submit_pypi(force=force)
        elif op == 'release':
          # issue new release tag
          print("new release for %s ..." % (name,))
          outstanding = N.uncommitted()
          if outstanding:
            print("Uncommited changes exist for these files:")
            for path in sorted(outstanding):
              print(' ', path)
            print("These changes will not be included in the release.")
            if not ask("Proceed with release anyway"):
              error("aborting release at user request")
              return 1
          changes = list(N.log_since())
          if not changes:
            error("no changes since last release, not making new release")
            xit = 1
          else:
            print("Changes since the last release:")
            for files, firstline in changes:
              print(" ", ' '.join(files) + ': ' + firstline)
            print()
            with pipefrom('readdottext', keep_stdin=True) as dotfp:
              release_message = dotfp.read().rstrip()
            if not release_message:
              error("empty release message, not making new release")
              xit = 1
            else:
              next_tag = N.next_release_tag()
              if not ask("Confirm new release for %r as %r" % (name, next_tag)):
                error("aborting release at user request")
                xit = 1
              else:
                rel_dir = os.path.join('release', next_tag)
                with Pfx("mkdir(%s)", rel_dir):
                  os.mkdir(rel_dir)
                summary_filename = os.path.join(rel_dir, 'SUMMARY.txt')
                with Pfx(summary_filename):
                  with open(summary_filename, 'w') as sfp:
                    print(release_message, file=sfp)
                changes_filename = os.path.join(rel_dir, 'CHANGES.txt')
                with Pfx(changes_filename):
                  with open(changes_filename, 'w') as cfp:
                    for files, firstline in changes:
                      print(" ", ' '.join(files) + ': ' + firstline, file=cfp)
                VCS = N.vcs
                VCS.add_files(summary_filename, changes_filename)
                VCS.commit('Release information for %s.\nSummary:\n%s'
                           % (next_tag, release_message),
                           summary_filename, changes_filename)
                VCS.tag(next_tag)
        elif op == 'status':
          tagged = N.last_suffix()
          result = [name, tagged]
          for pypi_flavour in 'testpypi', 'pypi':
            lvkey, last_upload = N.last_upload(pypi_flavour)
            if last_upload != tagged:
              result.append("%s:%s" % (pypi_flavour, last_upload))
          print(*result)
        elif op == 'testpypi':
          N.submit_testpypi(force=force)
        else:
          warning("unrecognised op %r", op)
          badopts = True
          break
  if badopts:
    print(usage, file=sys.stderr)
    xit = 2
  return xit

def ask(message):
  ''' Prompt with yes/no question, return true if response is "y" or "yes".
  '''
  print(message, end='? ')
  sys.stdout.flush()
  response = sys.stdin.readline().rstrip().lower()
  return response in ('y', 'yes')

@contextmanager
def pipefrom(*argv, **kw):
  ''' Context manager returning the standard output of a command.
  '''
  P = cs.cmdutils.pipefrom(argv, trace=False, **kw)
  yield P.stdout
  if P.wait() != 0:
    pipecmd = ' '.join(argv)
    raise ValueError("%s: exit status %d" % (pipecmd, P.returncode,))

class Modules(defaultdict):
  ''' An autopopulating dict of mod_name->Module.
  '''
  def __missing__(self, mod_name):
    return Module(mod_name, self)

class Module(object):
  ''' Metadata about a Python module.
  '''

  def __init__(self, name, modules):
    self.name = name
    self.modules = modules
    self._distinfo = None
    self._checking = False
    self._check_status = None
    try:
      self.module = importlib.import_module(name)
    except ImportError as e:
      warning("ImportError: %s", e)
      self.module = None
      self.check_status = True
    except SyntaxError as e:
      warning("SyntaxError: %s", e)
      self.module = None
      self.check_status = False

  @prop
  def package_name(self):
    ''' The name of the package containing this module, or None if this is not inside a package.
    '''
    M = self.module
    if M is None:
      X("%r.package_name: self.module is None", self.name)
      return None
    try:
      pkg_name = M.__package__
    except AttributeError:
      X("%r.package_name: self.module has no __package__: %r", self.name, sorted(dir(M)))
      return None
    return pkg_name

  @prop
  def in_package(self):
    ''' Is this module part of a package?
    '''
    M = self.module
    if M is None:
      return False
    return hasattr(M, '__package__')

  @prop
  def is_package(self):
    ''' Is this module a package?
    '''
    pkg_name = self.package_name
    return pkg_name is not None and pkg_name == self.name

  @prop
  def dirpath(self):
    M = self.module
    if M is None:
      return None
    if not self.is_package:
      return None
    return os.path.dirname(M.__file__)

  def paths(self):
    ''' Generator yield the .py filenames comprising this package.
    '''
    M = self.module
    if M is None:
      warning("paths: no module found")
      return
    filename = self.module.__file__
    if not self.is_package:
      yield filename
    else:
      moddir = os.path.dirname(filename)
      for dirpath, dirnames, filenames in os.walk(moddir):
        for basename in filenames:
          if basename.endswith('.py'):
            yield os.path.join(dirpath, basename)

  @prop
  def DISTINFO(self):
    D = self._distinfo
    if D is None:
      with Pfx("%s.DISTINFO", self.name):
        D = {}
        M = self.module
        if M is None:
          warning("cannot load module")
        else:
          try:
            D = M.DISTINFO
          except AttributeError:
            pkg_name = self.package_name
            if pkg_name == self.name:
              warning("missing")
            else:
              # look in the package
              P = self.modules[pkg_name]
              PM = P.module
              try:
                D = PM.DISTINFO
              except AttributeError:
                warning("missing and also missing from package %r", pkg_name)
              else:
                ##warning("DISTINFO from package %r", pkg_name)
                pass
          else:
            ##warning("DISTINFO from this module")
            pass
        self._distinfo = D
    return D

  @prop
  def requires(self):
    ''' Return other nonstdlib packages required by this module.
    '''
    return self.DISTINFO.get('install_requires')

  def check(self, silent=False):
    ''' Sanity check a package.
    '''
    if self._check_status is not None:
      return self._check_status
    if not self._checking:
      self._checking = True
      self._check_status = self._check(silent)
      self._checking = False
    return self._check_status

  def _check(self, silent):
    ok = True
    distinfo = self.DISTINFO
    install_requires = self.requires
    if install_requires is None:
      silent or error("missing DISTINFO[install_requires]")
      ok = False
      install_requires = distinfo.get('requires')
      if install_requires is None:
        install_requires = ()
      else:
        silent or warning("working off DISTINFO[requires]=%r", install_requires)
    install_requires = set(install_requires)
    pkg_name = self.package_name
    if pkg_name is None:
      pkg_prefix = None
    else:
      pkg_prefix = pkg_name + '.'
    # check imports against install_requires
    for name in sorted(self.imports):
      if not name.startswith('cs.'):
        continue
      if pkg_prefix and name.startswith(pkg_prefix):
        continue
      if name not in install_requires:
        silent or warning("import %r not mentioned in install_requires", name)
        ok = False
    for name in sorted(install_requires):
      if name not in self.imports:
        silent or warning("requirement %r not imported", name)
        ok = False
    return ok

  @prop
  @cached
  def imports(self):
    subnames = set()
    for path in self.paths():
      for name in self._direct_imports(self.name, path):
        if name in subnames:
          continue
        subnames.add(name)
    return subnames

  def _direct_imports(self, module_name, filename, silent=False):
    with Pfx(filename):
      with open(filename) as codefp:
        for lineno, line in enumerate(codefp, 1):
          with Pfx(lineno):
            if line.startswith('import ') or line.startswith('from '):
              words = line.strip().split()
              if not words:
                continue
              if words[0] == 'import' or words[0] == 'from':
                if len(words) < 2:
                  silent or warning("missing module name")
                  continue
                subimport0 = subimport = words[1]
                if subimport == '.':
                  # don't recurse into ourself
                  pkg_name = self.package_name
                  if pkg_name is None:
                    silent or warning("import of '.' from non-package")
                    continue
                  subimport = pkg_name
                elif subimport.startswith('.'):
                  # resolve relative import name
                  preparts = module_name.split('.')
                  subimport = subimport[1:]
                  while subimport.startswith('.'):
                    preparts.pop(-1)
                    subimport = subimport[1:]
                  if preparts:
                    if subimport:
                      preparts.append(subimport)
                  subimport = '.'.join(preparts)
                yield subimport

#                              name       - YYYYMMDD                            [.n]
re_RELEASE_TAG = re.compile(r'([a-z][^-]*)-(2[0-9][0-9][0-9][01][0-9][0-3][0-9](\.[1-9]\d*)?)$')

class VCS(object):

  def release_tags(self):
    ''' Generator yielding the current release tags.
    '''
    for tag in self.tags():
      m = re_RELEASE_TAG.match(tag)
      if m:
        yield tag

  def release_prefixes(self):
    ''' Return a set of the existing release prefixes.
    '''
    tagpfxs = set()
    for tag in self.release_tags():
      tagpfx, _ = tag.split('-', 1)
      tagpfxs.add(tagpfx)
    return tagpfxs

class VCS_Hg(VCS):

  def _pipefrom(self, *hgargs):
    hgargv = ['hg'] + list(hgargs) + ['|']
    return pipefrom('hg', *hgargs)

  def _hgcmd(self, *hgargs):
    print('hg', *hgargs, file=sys.stderr)
    check_call(['hg'] + list(hgargs))

  def tags(self):
    ''' Generator yielding the current tags.
    '''
    with self._pipefrom('tags') as hgfp:
      tags = set()
      for tagline in hgfp:
        tag, _ = tagline.split(None, 1)
        yield tag

  def tag(self, tag_name, revision=None):
    ''' Tag a revision with the supplied `tag`, by default revision "tip".
    '''
    if revision is None:
      revision = 'tip'
    self._hgcmd('tag',  '-r', revision, '--', tag_name)

  def log_since(self, tag, paths):
    with self._pipefrom('log',
                     '-r', tag+':',
                     '--template', '{files}\t{desc|firstline}\n',
                     '--',
                     *paths) as hgfp:
      for hgline in hgfp:
        files, firstline = hgline.split('\t', 1)
        files = files.split()
        firstline = firstline.strip()
        yield files, firstline

  def add_files(self, *paths):
    ''' Add the specified paths to the repository.
    '''
    self._hgcmd('add', *paths)

  def commit(self, message, *paths):
    ''' Commit the specified `paths` with the specified `message`.
    '''
    self._hgcmd('commit', '-m', message, '--', *paths)

  def uncommitted(self):
    ''' Generator yielding uncommited but tracked paths.
    '''
    with self._pipefrom('status') as hgfp:
      for hgline in hgfp:
        s, path = hgline.rstrip().split(' ', 1)
        if s != '?':
          yield path

class ReleaseName(object):
  ''' State surrounding a particular release tag prefix.
  '''

  def __init__(self, prefix, modules, VCS, LV):
    self.prefix = prefix
    self.modules = modules
    self.vcs = VCS
    self.lv = LV

  def check(self, silent=False):
    ''' Perform various sanity checks on the named module, return true if all pass.
    '''
    ok = True
    if not self.modules[self.prefix].check(silent):
      ok = False
    unreleased_changes = list(self.log_since())
    if unreleased_changes:
      show_log = not silent and ok
      ok = False
      if not silent:
        error("unreleased changes")
        if show_log:
          for files, firstline in unreleased_changes:
            files = [
                filename[11:] if filename.startswith('lib/python/') else filename
                for filename in files
            ]
            info("  %s: %s", ' '.join(files)+':', firstline)
    return ok

  def tagname(self, suffix):
    ''' Compute a tag name for this release with the supplied `suffix`.
    '''
    tag = self.prefix + '-' + suffix
    m = re_RELEASE_TAG.match(tag)
    if not m:
      raise ValueError("invalid tag made from prefix %r and suffix %r" % (self.prefix, suffix))
    return tag

  def release_tags(self):
    ''' Generator yielding existing release tags.
    '''
    prefix = self.prefix
    prefix_ = prefix + '-'
    for tag in self.vcs.release_tags():
      if tag.startswith(prefix_):
        yield tag

  def release_suffixes(self):
    ''' Generator yielding existing suffixes.
    '''
    poffset = len(self.prefix) + 1
    for tag in self.release_tags():
      yield tag[poffset:]

  def last_suffix(self):
    ''' Return the last release suffix for the specified release prefix, or None.
    '''
    last = None
    for suffix in self.release_suffixes():
      if last is None or suffix > last:
        last = suffix
    return last

  def next_suffix(self):
    ''' Compute the next release suffix.
    '''
    prefix = self.prefix
    last_suffix = self.last_suffix()
    today = isodate(dashed=False)
    if last_suffix is None or last_suffix < today:
      next_suffix = today
    elif last_suffix == today:
      next_suffix = today + '.1'
    else:
      # last_suffix > today, therefore YYYYMMDD.n
      ordinal = last_suffix.split('.', 1)[1]
      if ordinal.startswith('0'):
        raise ValueError("expected last_suffix of the form YYYYMMDD.n, received %r" % (last_suffix,))
      ordinal = int(ordinal)
      next_suffix = today + '.' + str(ordinal + 1)
    return next_suffix

  def next_release_tag(self):
    ''' Compute the next release tag.
    '''
    return self.prefix + '-' + self.next_suffix()

  def paths(self):
    ''' List of paths relevant this name, for use with hg log.
    '''
    prefix = self.prefix
    base = os.path.join(PYLIBTOP, prefix.replace('.', os.sep))
    basepy = base + '.py'
    readme = os.path.join(os.path.dirname(base), 'README-' + os.path.basename(base) + '.rst')
    return base, basepy, readme

  def log_since(self):
    ''' Generator yielding (files, line) tuples for log lines since the last release for the supplied `prefix`.
    '''
    suffix = self.last_suffix()
    if suffix is None:
      start_tag = ""
    else:
      start_tag = self.tagname(suffix)
    paths = self.paths()
    for files, firstline in self.vcs.log_since(start_tag, paths):
      files = [ filename for filename in files if filename in paths ]
      yield files, firstline

  def uncommitted(self):
    ''' List of paths relevant to this release with uncommited changes.
    '''
    pathset = set(self.paths())
    changed = []
    for path in self.vcs.uncommitted():
      if path in pathset:
        changed.append(path)
    return changed

  def submit_pypi(self, force=False):
    return self._submit_pypi('pypi', URL_PYPI_PROD, force=force)

  def submit_testpypi(self, force=False):
    return self._submit_pypi('testpypi', URL_PYPI_TEST, force=force)

  def last_upload(self, pypi_flavour):
    lastvalue_key = "%s-css-%s" % (pypi_flavour, self.prefix)
    last_pypi_release = self.lv.get(lastvalue_key, "")
    return lastvalue_key, last_pypi_release

  def _submit_pypi(self, pypi_flavour, pypi_url, force=False):
    ''' Submit the latest release of this package to PyPI.
    '''
    if not self.check():
      warning("check fails")
      if force:
        warning("submitting anyway")
      else:
        return
    with Pfx(pypi_flavour):
      last_suffix = self.last_suffix()
      lastvalue_key, last_pypi_release = self.last_upload(pypi_flavour)
      if last_suffix == last_pypi_release:
        info("already released %r", last_suffix)
        if force:
          warning("submitting anyway")
        else:
          return
      with Pfx("%r->%r", last_pypi_release, last_suffix):
        defaults = dict(DISTINFO_DEFAULTS)
        PKG = PyPI_Package(pypi_url, self.prefix, last_suffix, defaults=defaults)
        PKG.upload()
        self.lv[lastvalue_key] = last_suffix

if __name__ == '__main__':
  sys.exit(main(sys.argv))
