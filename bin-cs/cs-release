#!/usr/bin/python
#
# General release stuff for packages.
#   - Cameron Simpson <cs@zip.com.au> 28feb2009
#
# Redo in python; it is getting unmanagable in shell.
#   - Cameron Simpson <cs@zip.com.au> 23jul2015
#

from __future__ import print_function
import sys
import os.path
import re
from subprocess import Popen, PIPE
from contextlib import contextmanager
from cs.dateutils import isodate
from cs.logutils import setup_logging, Pfx, warning, X

URL_PYPI_PROD = 'https://pypi.python.org/pypi'
URL_PYPI_TEST = 'https://testpypi.python.org/pypi'

PYLIBTOP = 'lib/python'

USAGE = '''Usage: %s name [op [args...]]
  name          Prefix for new release tag names.
  op:
    ls          List all release prefixes in use.
    add         Issue a new release.
    last        Report last release issued.
    next        Generate a new release number.
    update-tag  Update a release tag.
    log         Changelog from last release to now.
    export      Export release to temporary directory, report directory.
    freshmeat-submit
                Announce last release to freshmeat.
    pypi [prod] Release python package to PyPI.'''

def main(argv):
  cmd = os.path.basename(argv.pop(0))
  usage = USAGE % (cmd,)
  setup_logging(cmd)

  badopts = False
  xit = 0

  if not argv:
    warning('missing name')
    badopts = True
  else:
    name = argv.pop(0)
    with Pfx(name):
      if not argv:
        warning('missing op')
        badopts = True
      else:
        op = argv.pop(0)
        with Pfx(op):
          N = ReleaseName(name, VCS_Hg())
          if op == 'last':
            print(N.last_suffix())
          elif op == 'log':
            for files, firstline in N.log_since():
              print(' '.join(files)+':', firstline)
          elif op == 'ls':
            for suffix in sorted(N.release_suffixes()):
              print(suffix)
          elif op == 'next':
            print(N.next_suffix())
  if badopts:
    print(usage, file=sys.stderr)
    xit = 2
  return xit
##  if op == "release":
##    next_suffix = self.next_release_suffix(prefix)
##
##
##        add)
##          uncommited=$( $trace hg status | grep -v '^?' || : )
##          if [ -n "$uncommited" ]
##          then
##            echo "Uncommited changes exist:"
##            printf "%s\n" "$uncommited"
##            echo "These changes will not be included in the release."
##            ask "Proceed anyway" || exit 1
##          fi
##          lastrelease=$relpfx-$( self last ) || lastrelease=0
##          if [ "x$lastrelease" != x0 ]
##          then
##            log=$( self log )
##            if [ -z "$log" ]
##            then
##              echo "$cmd: no changes since last release tag, aborting" >&2
##              exit 1
##            fi
##            echo "Changes since $lastrelease:"
##            printf "%s\n" "$log"
##          fi
##          echo
##          echo "Enter short change summary since $lastrelease."
##          changefile=$TMPDIR/$cmd.$$.changes
##          readdottext >"$changefile"
##          [ -s "$changefile" ] || exit 1
##          while echo
##                cat "$changefile"
##                echo
##                ask "Edit the changes"
##          do
##            "$EDITOR" "$changefile"
##          done
##          if [ ! -s "$changefile" ]
##          then
##            echo "$cmd: empty changefile, aborting" >&2
##            exit 1
##          fi
##          newrelease=$( self next ) \
##          || { echo "$cmd: cannot generate next tag" >&2; exit 1; }
##          echo
##          newtag=$relpfx-$newrelease
##          ask "Ok to mark release as $newtag" || exit 1
##          if [ "x$relpfx" = xrelease ]
##          then reldir=release/$newrelease
##          else reldir=release/$relpfx-$newrelease
##          fi
##          $trace mkdir "$reldir"
##          printf "%s\n" "$newtag" >"$reldir/release-tag.txt"
##          $trace mv "$changefile" "$reldir/SUMMARY.txt"
##          [ "x$lastrelease" == x0 ] \
##          || printf '%s\n' "$log" >"$reldir/CHANGES.txt"
##          $trace hg add "$reldir"
##          summary_text=$( cat "$reldir/SUMMARY.txt" )
##          $trace hg commit -m "Release information for $newtag.
##      Summary:
##      $summary_text" "$reldir"
##          $trace hg tag "$newtag"
##          ;;
##
##        export)
##          exec 3>&1 1>&2
##          rev=
##          usage="Usage: $cmd $op [-r rev]"
##          badopts=
##          while [ $# -gt 0 ]
##          do
##            case $1 in
##              -r) rev=$2; shift ;;
##              --) shift; break ;;
##              -?*)echo "$cmd: $op: unrecognised option: $1" >&2
##                  badopts=1
##                  ;;
##              *)  break ;;
##            esac
##            shift
##          done
##
##          [ $# = 0 ] || { echo "$cmd: extra arguments: $*" >&2
##                          badopts=1
##                        }
##
##          [ $badopts ] && { echo "$usage" >&2; exit 2; }
##
##          if [ -z "$rev" ]
##          then
##            rev=$( self last )
##            rev=$relpfx-$rev
##          fi
##
##          xit=0
##
##          set -ue
##
##          unset tmpdir
##          trap '[ ! -d "$tmpdir" ] || rm -rf $tmpdir; exit 1' 1 2 13 15
##          tmpdir=$( mkdirn "$TMPDIR/$cmd" )
##
##          dstdir=$tmpdir
##          echo archive revision $rev ...
##          hg archive -t files -r "'$rev'" "$dstdir"
##          echo update file timestamps ...
##          hg-apply-manifest-dates -r "'$rev'" "$dstdir"
##
##          echo "$dstdir" >&3
##          exit $xit
##          ;;
##
##        freshmeat-submit)
##          unset fm_project \
##                fm_url_home \
##                fm_url_tarball \
##                fm_url_changelog
##          cf=.freshmeatrc
##          [ -s "$cf" ] || { echo "$cmd: missing $cf" >&2; exit 1; }
##          eval $( winclausevars "$cf" freshmeat fm )
##          self update-tag
##          lastrelease=$( self last )
##          [ -n "$lastrelease" ] || exit 1
##          summary=$( $trace cat release/$lastrelease/SUMMARY.txt )
##          [ -n "$summary" ] || exit 1
##          printf "%s\n" "$summary"
##          ask "Confirm freshmeat-submit of release $lastrelease to project $fm_project"
##          ( echo "Project: $fm_project"
##            echo "Version: $lastrelease"
##            echo "Release-Focus: Minor feature enhancements"
##            echo "Hide: N"
##            echo "Website-URL: $fm_url_home"
##            echo "Tar/GZ-URL: $fm_url_tarball"
##            echo "Changelog-URL: $fm_url_changelog"
##            echo
##            printf "%s\n" "$summary"
##          ) \
##          | $trace freshmeat-submit
##          ;;
##
##        update-tag)
##          if lastrelease=$( self last )
##          then
##            log=$( self log )
##            printf "%s\n" "$log"
##            if [ -n "$log" ] && ask "Issue new tag for $relpfx"
##            then
##              self add || exit 1
##            fi
##          else
##            ask "Issue first tag for $relpfx" || exit 1
##            self add || exit 1
##          fi
##          ;;
##
##        pypi)
##          if [ $# -gt 0 ] && [ "x$1" = xprod ]
##          then  shift; pypi_test_mode=
##          else  pypi_test_mode=1
##          fi
##          pypi_setup
##          if [ "$relpfx" = ALL ]
##          then
##            for relpfx in $( self ls | grep '^cs\.' )
##            do
##              pkg=$relpfx
##              lastlabel=$pypi_pfx-css-$pkg
##              lastrelease=$( self last ) || exit 1
##              lastpypirelease=$( $trace lastvalue "$lastlabel" 2>/dev/null || : )
##              if [ "x$lastrelease" = "x$lastpypirelease" ]
##              then
##                echo "OK $relpfx: $pypi_pfx up to date at $lastpypirelease"
##              else
##                if [ -n "$lastpypirelease" ]
##                then
##                  echo "NEWER $relpfx: $lastrelease, but $pypi_pfx has $lastpypirelease"
##                else
##                  echo "NEWER $relpfx: $lastrelease, but $pypi_pfx has nothing"
##                fi
##              fi
##              log=$( self log )
##              if [ -n "$log" ]
##              then
##                echo "  has untagged changes"
##              fi
##            done
##          else
##            pkg=$relpfx
##            lastlabel=$pypi_pfx-css-$pkg
##            case "$pkg" in
##              cs.*) ;;
##              *)  echo "$cmd: $op: invalid package name, expected cs.*: $pkg" >&2
##                  exit 2
##                  ;;
##            esac
##            self update-tag
##            lastrelease=$( self last )
##            [ -n "$lastrelease" ] || exit 1
##            $trace python -m cs.distinfo "$pkg" check
##            $trace python -m cs.distinfo "$pkg" register
##            $trace python -m cs.distinfo "$pkg" upload
##            $trace lastvalue "$lastlabel" "$lastrelease"
##          fi
##          ;;
##
##        *)echo "$cmd: unimplemented op \"$op\"" >&2
##          exit 2
##          ;;
##
##      esac
##          else:
##            warning("unknown operator")
##            badopts = True
##  if badopts:
##    print(usage, file=sys.stderr)
##    xit = 2
##  return xit
##
##    pypi_setup(){
##      if [ $pypi_test_mode ]
##      then
##        pypi_url=$testpypi_url
##        pypi_pfx=testpypi
##      else
##        pypi_url=$prodpypi_url
##        pypi_pfx=pypi
##      fi
##      PYPI_URL=$pypi_url
##      export PYPI_URL
##    }

@contextmanager
def pipefrom(*argv):
  ''' Context manager returning standard output of command.
  '''
  P = Popen(argv, stdout=PIPE)
  yield P.stdout
  if P.wait() != 0:
    pipecmd = ' '.join(argv)
    raise ValueError("%s: exit status %d" % (pipecmd, P.returncode,))

#                               name        -  YYYYMMDD[.n]
re_RELEASE_TAG = re.compile(r'([a-z][^-]*)-(2[0-9][0-9][0-9][01][0-9][0-3][0-9](\.[1-9]\d*)?)$')

class VCS(object):

  def release_tags(self):
    ''' Generator yielding the current release tags.
    '''
    for tag in self.tags():
      m = re_RELEASE_TAG.match(tag)
      if m:
        yield tag

  def release_prefixes(self):
    ''' Return a set of the existing release prefixes.
    '''
    tagpfxs = set()
    for tag in self.release_tags():
      tagpfx, _ = tag.split('-', 1)
      tags.add(tagpfx)
    return tagpfxs

class VCS_Hg(VCS):

  def _pipefrom(self, *hgargs):
    return pipefrom('hg', *hgargs)

  def tags(self):
    ''' Generator yielding the current tags.
    '''
    with self._pipefrom('tags') as hgfp:
      tags = set()
      for tagline in hgfp:
        tag, _ = tagline.split(None, 1)
        yield tag

  def log_since(self, tag, paths):
    with self._pipefrom('log',
                     '-r', tag+':',
                     '--template', '{files}\t{desc|firstline}\n',
                     '--',
                     *paths) as hgfp:
      for hgline in hgfp:
        files, firstline = hgline.split('\t', 1)
        files = files.split()
        firstline = firstline.strip()
        yield files, firstline

class ReleaseName(object):
  ''' State surrounding a particular release tag prefix.
  '''

  def __init__(self, prefix, vcs):
    self.prefix = prefix
    self.vcs = vcs

  def tagname(self, suffix):
    tag = self.prefix + '-' + suffix
    m = re_RELEASE_TAG.match(tag)
    if not m:
      raise ValueError("invalid tag made from prefix %r and suffix %r" % (self.prefix, suffix))
    return tag

  def release_tags(self):
    ''' Generator yielding existing release tags.
    '''
    prefix = self.prefix
    prefix_ = prefix + '-'
    for tag in self.vcs.release_tags():
      if tag.startswith(prefix_):
        yield tag

  def release_suffixes(self):
    ''' Generator yielding existing suffixes.
    '''
    poffset = len(self.prefix) + 1
    for tag in self.release_tags():
      yield tag[poffset:]

  def last_suffix(self):
    ''' Return the last release suffix for the specified release prefix, or None.
    '''
    last = None
    for suffix in self.release_suffixes():
      if last is None or suffix > last:
        last = suffix
    return last

  def next_suffix(self):
    ''' Compute the next release suffix.
    '''
    prefix = self.prefix
    last_suffix = self.last_suffix()
    today = isodate(dashed=False)
    if last_suffix is None or last_suffix < today:
      next_suffix = today
    elif last_suffix == today:
      next_suffix = today + '.1'
    else:
      # last_suffix > today, therefore YYYYMMDD.n
      ordinal = last_suffix.split('.', 1)[1]
      if ordinal.startswith('0'):
        raise ValueError("expected last_suffix of the form YYYYMMDD.n, received %r" % (last_suffix,))
      ordinal = int(ordinal)
      next_suffix = today + '.' + str(ordinal + 1)
    return next_suffix

  def next_release_tag(self):
    return self.prefix + '-' + self.next_suffix()

  def paths(self):
    ''' List of paths relevant this name, for use with hg log.
    '''
    prefix = self.prefix
    base = os.path.join(PYLIBTOP, prefix.replace('.', '/'))
    basepy = base + '.py'
    readme = os.path.join(os.path.dirname(base), 'README-' + os.path.basename(base) + '.rst')
    return (base, basepy, readme)

  def log_since(self):
    ''' Generator yielding (files, line) tuples for log lines since the last release for the supplied `prefix`.
    '''
    suffix = self.last_suffix()
    if suffix is None:
      return
    return self.vcs.log_since(self.tagname(suffix), self.paths())

if __name__ == '__main__':
  sys.exit(main(sys.argv))
