#!/bin/sh -ue
#
# General release stuff for packages.
#       - Cameron Simpson <cs@zip.com.au> 28feb2009
#

set -ue

: ${TMPDIR:=/tmp}

trace=  ##set-x
relpfx=release

pypi_url='https://pypi.python.org/pypi'
testpypi_url='https://testpypi.python.org/pypi'
pypi_test_mode=1

cmd=$( basename "$0" )
usage="Usage: $cmd [-x] op [relpfx [args...]]
  -x            Trace command execution.
  relpfx        Prefix for new release tag names. Default: $relpfx
  op:
    ls          List all release prefixes in use.
    add         Issue a new release.
    last        Report last release issued.
    next        Generate a new release number.
    update-tag  Update a release tag.
    log         Changelog from last release to now.
    export      Export release to temporary directory, report directory.
    freshmeat-submit
                Announce last release to freshmeat.
    pypi [prod] Release python package to PyPI."

badopts=

while [ $# -gt 0 ]
do
  case $1 in
    -x) trace=set-x ;;
    --) shift; break ;;
    -?*)echo "$cmd: unrecognised option: $1" >&2; badopts=1 ;;
    *)  break ;;
  esac
  shift
done

if [ $# = 0 ]
then
  echo "$cmd: missing op" >&2
  badopts=1
else
  op=$1
  shift
  [ $# = 0 ] || { relpfx=$1; shift; }
fi

case "$relpfx" in
  release)
    subtree=.
    ;;
  [a-z]*)
    subtree=lib/python/$( echo "$relpfx" | tr . / )
    if [ ! -d "$subtree" ]
    then
      if [ -f "$subtree.py" ]
      then
        subtree=$subtree.py
      else
        echo "$cmd: neither subdir $subtree nor file $subtree.py" >&2
        badopts=1
      fi
    fi
    ;;
  *)echo "$cmd: invalid relpfx, must start with a lowercase letter, got: $relpfx" >&2
    badopts=1
    ;;
esac

[ $badopts ] && { echo "$usage" >&2; exit 2; }

# self invoke, passing tunable settings
self(){
  _self_op=$1; shift
  $trace "$0" "$_self_op" "$relpfx" ${1+"$@"}
}

case $op in
  ls)
    hg tags \
    | sed -n 's/^\([a-z][^-]*\)-\(2[0-9][0-9][0-9][0-9][0-9][0-9][0-9][^ ]*\) .*/\1/p' \
    | sort -u
    ;;

  last)
    if [ "$relpfx" = ALL ]
    then
      for relpfx in $( self ls )
      do
        lastrelease=$( self last )
        echo "$relpfx $lastrelease"
      done
    else
      lastrelease=$( $trace hg tags | sed -n "/^$relpfx-[1-9][01][0-9][0-9][01][0-9][0-3][0-9]/{s/^$relpfx-//; s/ .*//; p; q;}" )
      if [ -z "$lastrelease" ]
      then
        echo "$cmd: no last release for prefix \"$relpfx\"" >&2
        exit 1
      fi
      printf "%s\n" "$lastrelease"
      exit 0
    fi
    ;;

  next)
    lastrelease=$( self last ) || lastrelease=
    today=$( date +%Y%m%d )
    if [ -z "$lastrelease" ]
    then
      release=$today
    else
      if [ "x$lastrelease" '<' "x$today" ]
      then
        release=$today
      else 
        if [ "x$lastrelease" = "x$today" ]
        then
          release=${today}.2
        else
          case "$lastrelease" in
            "$today".[1-9] )
              sfx=$( expr "x$lastrelease" : "x$today".'\([1-9][0-9]*\).*' )
              release=$today.$( expr "$sfx" + 1 )
              ;;
            *)
              echo "$cmd: can't compute next release from \"$lastrelease\"" >&2
              exit 1
              ;;
          esac
        fi
      fi
    fi
    printf "%s\n" "$release"
    exit 0
    ;;

  log)
    lastrelease=$relpfx-$( self last ) || lastrelease=0
    if [ "x$lastrelease" = x0 ]
    then
      echo "$cmd: no log because no previous release tag" >&2
      exit 1
    else
      $trace hg log -r "'$lastrelease':" \
                    --template '{files}: {desc|firstline}\n' \
                    "$subtree" \
      | $trace sed "/^\\.hg/d; /^CHANGELOG/d; /^$relpfx-/d"
    fi
    ;;

  add)
    uncommited=$( $trace hg status | grep -v '^?' || : )
    if [ -n "$uncommited" ]
    then
      echo "Uncommited changes exist:"
      printf "%s\n" "$uncommited"
      echo "These changes will not be included in the release."
      ask "Proceed anyway" || exit 1
    fi
    lastrelease=$relpfx-$( self last ) || lastrelease=0
    if [ "x$lastrelease" != x0 ]
    then
      log=$( self log )
      if [ -z "$log" ]
      then
        echo "$cmd: no changes since last release tag, aborting" >&2
        exit 1
      fi
      echo "Changes since $lastrelease:"
      printf "%s\n" "$log"
    fi
    echo
    echo "Enter short change summary since $lastrelease."
    changefile=$TMPDIR/$cmd.$$.changes
    readdottext >"$changefile"
    [ -s "$changefile" ] || exit 1
    while echo
          cat "$changefile"
          echo
          ask "Edit the changes"
    do
      "$EDITOR" "$changefile"
    done
    if [ ! -s "$changefile" ]
    then
      echo "$cmd: empty changefile, aborting" >&2
      exit 1
    fi
    newrelease=$( self next ) \
    || { echo "$cmd: cannot generate next tag" >&2; exit 1; }
    echo
    newtag=$relpfx-$newrelease
    ask "Ok to mark release as $newtag" || exit 1
    if [ "x$relpfx" = xrelease ]
    then reldir=release/$newrelease
    else reldir=release/$relpfx-$newrelease
    fi
    $trace mkdir "$reldir"
    printf "%s\n" "$newtag" >"$reldir/release-tag.txt"
    $trace mv "$changefile" "$reldir/SUMMARY.txt"
    [ "x$lastrelease" == x0 ] \
    || printf '%s\n' "$log" >"$reldir/CHANGES.txt"
    $trace hg add "$reldir"
    summary_text=$( cat "$reldir/SUMMARY.txt" )
    $trace hg commit -m "Release information for $newtag.
Summary:
$summary_text" "$reldir"
    $trace hg tag "$newtag"
    ;;

  export)
    exec 3>&1 1>&2
    rev=
    usage="Usage: $cmd $op [-r rev]"
    badopts=
    while [ $# -gt 0 ]
    do
      case $1 in
        -r) rev=$2; shift ;;
        --) shift; break ;;
        -?*)echo "$cmd: $op: unrecognised option: $1" >&2
            badopts=1
            ;;
        *)  break ;;
      esac
      shift
    done

    [ $# = 0 ] || { echo "$cmd: extra arguments: $*" >&2
                    badopts=1
                  }

    [ $badopts ] && { echo "$usage" >&2; exit 2; }

    if [ -z "$rev" ]
    then
      rev=$( self last )
      rev=$relpfx-$rev
    fi

    xit=0

    set -ue

    unset tmpdir
    trap '[ ! -d "$tmpdir" ] || rm -rf $tmpdir; exit 1' 1 2 13 15
    tmpdir=$( mkdirn "$TMPDIR/$cmd" )

    dstdir=$tmpdir
    echo archive revision $rev ...
    hg archive -t files -r "'$rev'" "$dstdir"
    echo update file timestamps ...
    hg-apply-manifest-dates -r "'$rev'" "$dstdir"

    echo "$dstdir" >&3
    exit $xit
    ;;

  freshmeat-submit)
    unset fm_project \
          fm_url_home \
          fm_url_tarball \
          fm_url_changelog
    cf=.freshmeatrc
    [ -s "$cf" ] || { echo "$cmd: missing $cf" >&2; exit 1; }
    eval $( winclausevars "$cf" freshmeat fm )
    self update-tag
    lastrelease=$( self last )
    [ -n "$lastrelease" ] || exit 1
    summary=$( $trace cat release/$lastrelease/SUMMARY.txt )
    [ -n "$summary" ] || exit 1
    printf "%s\n" "$summary"
    ask "Confirm freshmeat-submit of release $lastrelease to project $fm_project"
    ( echo "Project: $fm_project"
      echo "Version: $lastrelease"
      echo "Release-Focus: Minor feature enhancements"
      echo "Hide: N"
      echo "Website-URL: $fm_url_home"
      echo "Tar/GZ-URL: $fm_url_tarball"
      echo "Changelog-URL: $fm_url_changelog"
      echo
      printf "%s\n" "$summary"
    ) \
    | $trace freshmeat-submit
    ;;

  update-tag)
    if lastrelease=$( self last )
    then
      log=$( self log )
      printf "%s\n" "$log"
      if [ -n "$log" ] && ask "Issue new tag for $relpfx"
      then
        self add || exit 1
      fi
    else
      ask "Issue first tag for $relpfx" || exit 1
      self add || exit 1
    fi
    ;;

  pypi)
    if [ $# -gt 0 ] && [ "x$1" = xprod ]
    then  shift; pypi_test_mode=
    else  pypi_test_mode=1
    fi
    if [ $pypi_test_mode ]
    then PYPI_URL=$testpypi_url pypipfx=testpypi
    else PYPI_URL=$pypi_url pypipfx=pypi
    fi
    export PYPI_URL
    if [ "$relpfx" = ALL ]
    then
      for relpfx in $( self ls | grep '^cs\.' )
      do
        pkg=$relpfx
        lastlabel=$pypipfx-css-$pkg
        lastrelease=$( self last ) || exit 1
        lastpypirelease=$( $trace lastvalue "$lastlabel" 2>/dev/null || : )
        if [ "x$lastrelease" = "x$lastpypirelease" ]
        then
          echo "$relpfx: pypi up to date at $lastpypirelease"
        else
          if [ -n "$lastpypirelease" ]
          then
            echo "$relpfx: $lastrelease, but pypi has $lastpypirelease"
          else
            echo "$relpfx: $lastrelease, but pypi has nothing"
          fi
        fi
      done
    else
      pkg=$relpfx
      lastlabel=$pypipfx-css-$pkg
      case "$pkg" in
        cs.*) ;;
        *)  echo "$cmd: $op: invalid package name, expected cs.*: $pkg" >&2
            exit 2
            ;;
      esac
      self update-tag
      lastrelease=$( self last )
      [ -n "$lastrelease" ] || exit 1
      $trace python -m cs.distinfo "$pkg" check
      $trace python -m cs.distinfo "$pkg" register
      $trace python -m cs.distinfo "$pkg" upload
      $trace lastvalue "$lastlabel" "$lastrelease"
    fi
    ;;

  *)echo "$cmd: unimplemented op \"$op\"" >&2
    exit 2
    ;;

esac
