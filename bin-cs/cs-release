#!/usr/bin/env python3
#
# General release stuff for packages.
#   - Cameron Simpson <cs@cskk.id.au> 28feb2009
#
# Redo in python; it is getting unmanagable in shell.
#   - Cameron Simpson <cs@cskk.id.au> 23jul2015
#

from __future__ import print_function
from collections import defaultdict
from contextlib import contextmanager
import errno
from getopt import GetoptError
import importlib
import os
import os.path
from os.path import (
    basename, dirname,
    isdir as isdirpath,
    isfile as isfilepath,
    join as joinpath,
    exists as pathexists,
)
import re
from subprocess import check_call
import sys
from types import SimpleNamespace as NS
from cs.app.lastvalue import LastValues
from cs.dateutils import isodate
from cs.deco import cached
from cs.distinfo import URL_PYPI_PROD, URL_PYPI_TEST, PyPI_Package
from cs.logutils import setup_logging, error, warning, info
from cs.pfx import Pfx
import cs.psutils
from cs.py.func import prop
from cs.x import X

PYLIBTOP = 'lib/python'

# defaults for packages without their own specifics
DISTINFO_DEFAULTS = {
    'url': 'https://bitbucket.org/cameron_simpson/css/commits/all',
}

USAGE = '''Usage: %s [-f] cs.module [op]
  -f  Force. Sanity checks that would stop some actions normally  will not prevent them.
  The default op is "check".
  Supported ops:
    check       Check simple things about a module's DISTINFO map.
    last        Report last release issued.
    log         Changelog from last release to now.
    ls          List latest release prefixes.
    next        Generate a new release number.
    pypi        Upload latest release to PyPI.
    release     Issue a new release tag with change summary.
'''

##  export      Export release to temporary directory, report directory.
##  freshmeat-submit Announce last release to freshmeat.

def main(argv):
  argv = list(argv)
  cmd = os.path.basename(argv.pop(0))
  usage = USAGE % (cmd,)
  setup_logging(cmd)

  force = False
  op = None

  xit = 0
  badopts = False

  if argv and argv[0] == '-f':
    argv.pop(0)
    force = True

  vcs = VCS_Hg()
  lv = LastValues()
  state = NS(
      modules=Modules(),
      packages=Packages(),
      last_values=lv,
      vcs=vcs,
  )
  state.modules.state = state
  state.packages.state = state

  if not argv:
    op = "check"
    name = None
  else:
    name = argv.pop(0)
    if name in ("ls", "check"):
      op = name
      name = None
    elif not name.startswith('cs.'):
      error("invalid module name, should start with 'cs.': %r", name)
      badopts = True

  if badopts:
    print(usage, file=sys.stderr)
    return 2

  if op is None:
    if not argv:
      op = 'check'
    else:
      op = argv.pop(0)

  if name is None:
    # All the release tag prefixes which commence with "cs.".
    names = [
        name
        for name in sorted(vcs.release_prefixes())
        if name.startswith('cs.')
    ]
  else:
    names = (name,)

  with Pfx(op):
    for name in names:
      with Pfx(name):
        pkg = state.packages[name]
        if op == 'check':
          if argv and argv[0] == '-v':
            argv.pop(0)
            verbose = True
          else:
            verbose = False
          if not name.startswith('cs.'):
            warning('skipping, not a "cs." module name')
          else:
            ok = False
            if not pkg.check_basic(quiet=not verbose):
              status = 'FLAWED'
            elif not pkg.check_uptodate(quiet=not verbose):
              status = 'RELEASE OUT OF DATE'
            elif pkg.check_needs_release(quiet=not verbose):
              status = 'NEEDS NEW RELEASE'
            else:
              rel_tag = pkg.latest_release_tag()
              if rel_tag is None:
                status = 'NEVER RELEASED'
              else:
                rel_pfx, rel_suffix = rel_tag.split('-', 1)
                upload_suffix = pkg.last_upload_suffix()
                if rel_suffix != upload_suffix:
                  status = (
                      'RELEASE:%s DOES NOT MATCH UPLOAD:%s'
                      % (rel_suffix, upload_suffix))
                else:
                  status = 'OK'
                  ok = True
            print(name, status)
            if not ok:
              xit = 1
        elif op == 'checkout':
          if argv:
            revision = argv.pop(0)
          else:
            revision = pkg.latest_release_tag() or "tip"
            info("checking out revision %r", revision)
          checkout_dir = pkg.name + '--' + revision
          pkg.checkout(revision, checkout_dir)
        elif op == 'last':
          tag = pkg.latest_release_tag()
          if tag is None:
            suffix = "NONE"
          else:
            prefix, suffix = tag.split('-', 1)
          print(name, suffix)
        elif op == 'log':
          first = True
          for files, firstline in pkg.log_since():
            if first:
              print(name)
              first = False
            files = [
                filename[11:]
                if filename.startswith('lib/python/')
                else filename for filename in files ]
            print(' ', ' '.join(files)+':', firstline)
        elif op == 'ls':
          for k in sorted(lv.keys()):
            if k.startswith("pypi-css-cs."):
              print(k[9:], lv[k])
          return 0
        elif op == 'next':
          next_prefix, next_suffix = pkg.next_release_tag().split('-')
          assert next_prefix == pkg.name
          print(name, next_suffix)
        elif op == 'pypi':
          # upload latest release to pypi
          N.submit_pypi(force=force)
        elif op == 'release':
          # issue new release tag
          print("new release for %s ..." % (name,))
          outstanding = N.uncommitted()
          if outstanding:
            print("uncommitted changes exist for these files:")
            for path in sorted(outstanding):
              print(' ', path)
            print("These changes will not be included in the release.")
            if not ask("Proceed with release anyway"):
              error("aborting release at user request")
              return 1
          changes = list(N.log_since())
          if not changes:
            if force:
              warning("no changes since last release, making release anyway")
            else:
              error("no changes since last release, not making new release")
              return 1
          print("Changes since the last release:")
          for files, firstline in changes:
            print(" ", ' '.join(files) + ': ' + firstline)
          print()
          with pipefrom('readdottext', keep_stdin=True) as dotfp:
            release_message = dotfp.read().rstrip()
          if not release_message:
            error("empty release message, not making new release")
            xit = 1
          else:
            next_tag = N.next_release_tag()
            if not ask("Confirm new release for %r as %r" % (name, next_tag)):
              error("aborting release at user request")
              xit = 1
            else:
              rel_dir = os.path.join('release', next_tag)
              with Pfx("mkdir(%s)", rel_dir):
                os.mkdir(rel_dir)
              summary_filename = os.path.join(rel_dir, 'SUMMARY.txt')
              with Pfx(summary_filename):
                with open(summary_filename, 'w') as sfp:
                  print(release_message, file=sfp)
              changes_filename = os.path.join(rel_dir, 'CHANGES.txt')
              with Pfx(changes_filename):
                with open(changes_filename, 'w') as cfp:
                  for files, firstline in changes:
                    print(" ", ' '.join(files) + ': ' + firstline, file=cfp)
              vcs.add_files(summary_filename, changes_filename)
              vcs.commit('Release information for %s.\nSummary:\n%s'
                         % (next_tag, release_message),
                         summary_filename, changes_filename)
              vcs.tag(next_tag)
        else:
          warning("unrecognised op %r", op)
          badopts = True

  if badopts:
    print(usage, file=sys.stderr)
    xit = 2
  return xit

class Packages(defaultdict):
  ''' An autopopulating dict of pkg_name->Package.
  '''
  def __missing__(self, pkg_name):
    P = Package(pkg_name, self.state)
    self[pkg_name] = P
    return P

class Package:
  ''' Facilities to work with a package.
  '''

  def __init__(self, name, state):
    if name.endswith('_tests'):
      raise ValueError("Package(%r): unexpected _tests package" % (name,))
    self.name = name
    self.state = state              # shared state
    self.vcs = state.vcs            # convenience
    self.modules = state.modules    # convenience
    self.packages = state.packages  # convenience

  def __str__(self):
    return "%s[%r]" % (type(self).__name__, self.name)

  @cached
  def release_tags(self):
    ''' Return the release tags for this package.
    '''
    prefix = self.name + '-'
    return [ tag for tag in self.vcs.release_tags() if tag.startswith(prefix) ]

  def latest_release_tag(self):
    ''' Return the latest release tag or None.
    '''
    tags = self.release_tags()
    if not tags:
      return None
    return max(tags)

  def next_release_tag(self):
    ''' Compute the next release suffix.
    '''
    last_tag = self.latest_release_tag()
    today = isodate(dashed=False)
    if last_tag:
      with Pfx(last_tag):
        prefix, suffix = last_tag.split('-')
        assert prefix == self.name, (
            "last_tag %r prefix does not match package name %r"
            % (prefix, self.name))
        if suffix == today:
          next_suffix = today + '.1'
        elif suffix < today:
          next_suffix = today
        else:
          # suffix > today: compute next .n extension
          base_suffix, numerator = suffix.split('.')
          if base_suffix > today:
            warning(
                "issuing a future suffix: today=%r, base suffix=%r",
                today, base_suffix)
          next_suffix = base_suffix + '.' + str(int(numerator) + 1)
    else:
      next_suffix = today + '.1'
    return self.name + '-' + next_suffix

  def last_upload_suffix(self, target='pypi'):
    lastvalue_key = "%s-css-%s" % (target, self.name)
    return self.state.last_values.get(lastvalue_key, None)

  @prop
  def basename(self):
    ''' The last component of the package name.
    '''
    return self.name.split('.')[-1]

  @prop
  def basepath(self):
    ''' The base path for this package.
    '''
    return os.sep.join([PYLIBTOP] + self.name.split('.'))

  @prop
  def module(self):
    ''' The Module for this package name.
    '''
    return self.modules[self.name]

  def paths(self):
    ''' Yield the paths associated with this package.

        Note: this is based on the current checkout state instead
        of some revision because "hg archive" complains if globs
        match no paths, and aborts.
    '''
    basepath = self.basepath
    if isdirpath(basepath):
      for subpath, dirnames, filenames in os.walk(basepath):
        if not subpath.startswith(basepath):
          info("SKIP %s", subpath)
          continue
        for filename in sorted(filenames):
          if not (
              filename.endswith('.pyc')
              or filename.endswith('.o')
          ):
            yield joinpath(subpath, filename)
    else:
      base = self.basename
      updir = dirname(basepath)
      for filename in sorted(os.listdir(updir)):
        filepath = joinpath(updir, filename)
        if (
            ( filename.startswith(base + '.')
              or filename.startswith(base + '_')
            )
            and not (
                filename.endswith('.pyc')
                or filename.endswith('.o')
            )
            and isfilepath(filepath)
        ):
          if isfilepath(filepath):
            yield filepath
          else:
            info("ignore %r, not a file", filepath)

  def checkout(self, revision, dirpath):
    ''' Check out the specified `revision` to the directory `dirpath`.
    '''
    with Pfx("checkout %r ==> %r", revision, dirpath):
      if pathexists(dirpath):
        raise ValueError("already exists")
      hg_argv = ['archive', '-r', revision]
      hg_argv.extend(vcs.hg_include(self.paths()))
      hg_argv.extend(['--', dirpath])
      return self.vcs.hg_cmd(*hg_argv)

  def log_since(self, tag=None):
    ''' Generator yielding (files, line) tuples
        for log lines since the last release for the supplied `prefix`.
    '''
    with Pfx("log_since"):
      if tag is None:
        tag = self.latest_release_tag()
        if tag is None:
          warning("no release tags, starting from the beginning")
          tag = "0"
      paths = list(self.paths())
      for files, firstline in self.vcs.log_since(tag, paths):
        files = [ filename for filename in files if filename in paths ]
        yield files, firstline

  @cached
  def check_basic(self, quiet=False):
    ''' Basic package checks.
    '''
    ok = True
    with Pfx('paths'):
      paths = list(self.paths())
      if not paths:
        quiet or warning("no files")
        ok = False
    return ok

  @cached
  def check_imports(self, quiet=False):
    ''' Check that this package's imported modules are ok
    '''
    ok = True
    M = self.module
    for submodule in sorted(M.imported_names):
      with Pfx(submodule):
        if submodule == self.name:
          continue
        if not submodule.startswith('cs.'):
          continue
        if not M.check(silent=True):
          quiet or warning("module NOT OK")
          ok = False
    return ok

  @cached
  def check_needs_release(self, quiet=False):
    ''' Check that this package is a candidate for release:
        * basic correctness
        * there are commits since the latest release
        * there are no uncommited changes awaiting commit
        * all the required modules are up to date
    '''
    ok = True
    paths = list(self.paths())
    if not self.check_basic(quiet=quiet):
      ok = False
    tag = self.latest_release_tag() or "0"
    unreleased_logs = list(self.log_since(tag))
    if not unreleased_logs:
      quiet or warning("no unreleased commits since revision %s", tag)
      ok = False
    changed_paths = [
        changed_path
        for changed_path in self.vcs.uncommitted()
        if changed_path in paths
    ]
    if changed_paths:
      quiet or warning("%d modified files", len(changed_paths))
      ok = False
    with Pfx("out of date requirements"):
      checked_packages = set()
      for import_name in sorted(self.module.imported_names):
        with Pfx(import_name):
          if import_name == self.name:
            ##info("SKIP self %r", import_name)
            continue
          if not import_name.startswith('cs.'):
            ##info("SKIP non-cs %r", import_name)
            continue
          M = self.modules[import_name]
          subpkg = M.package
          if subpkg in checked_packages:
            info("skipping, package %s already checked", subpkg.name)
            continue
          checked_packages.add(subpkg)
          if not subpkg.check_uptodate(quiet=False):
            quiet or warning("release not up to date")
            ok = False
      self.check_imports(quiet=quiet)
    return ok

  @cached
  def check_uptodate(self, quiet=False):
    ''' Check that this package has is up to date:
        * there are no commits since the latest release
        * there are no uncommited changes awaiting commit
    '''
    ok = True
    paths = list(self.paths())
    with Pfx("unreleased logs"):
      tag = self.latest_release_tag() or "0"
      unreleased_logs = list(self.log_since(tag))
      if unreleased_logs:
        quiet or warning(
            "%d unreleased commits since revision %s",
            len(unreleased_logs), tag)
        ok = False
    with Pfx("uncommitted changes"):
      changed_paths = [
          changed_path
          for changed_path in self.vcs.uncommitted()
          if changed_path in paths
      ]
      if changed_paths:
        quiet or warning("%d modified files", len(changed_paths))
        ok = False
    return ok

def ask(message):
  ''' Prompt with yes/no question, return true if response is "y" or "yes".
  '''
  print(message, end='? ')
  sys.stdout.flush()
  response = sys.stdin.readline().rstrip().lower()
  return response in ('y', 'yes')

@contextmanager
def pipefrom(*argv, **kw):
  ''' Context manager returning the standard output of a command.
  '''
  P = cs.psutils.pipefrom(argv, trace=False, **kw)
  yield P.stdout
  if P.wait() != 0:
    pipecmd = ' '.join(argv)
    raise ValueError("%s: exit status %d" % (pipecmd, P.returncode,))

class Modules(defaultdict):
  ''' An autopopulating dict of mod_name->Module.
  '''
  def __missing__(self, mod_name):
    M = Module(mod_name, self.state)
    self[mod_name] = M
    return M

class Module(object):
  ''' Metadata about a Python module.
  '''

  def __init__(self, name, state):
    self.name = name
    self.state = state
    self.modules = state.modules
    self.packages = state.packages
    self._distinfo = None
    self._checking = False
    self._check_status = None
    try:
      self.module = importlib.import_module(name)
    except ImportError as e:
      warning("ImportError: %s", e)
      self.module = None
      self.check_status = True
    except SyntaxError as e:
      warning("SyntaxError: %s", e)
      self.module = None
      self.check_status = False

  def __str__(self):
    return "%s[%r]" % (type(self).__name__, self.name)

  @prop
  @cached
  def package_name(self):
    ''' The name of the package containing this module,
        or None if this is not inside a package.
    '''
    M = self.module
    if M is None:
      error("%r.package_name: self.module is None", self.name)
      return None
    if M.__file__.endswith('_tests.py'):
      mainname = self.name[:-6]
      X("%r: test suite, get package name from modules[%r]", M.__file__, mainname)
      return self.modules[mainname].package_name
    try:
      pkg_name = M.__package__
    except AttributeError:
      X("%r.package_name: self.module has no __package__: %r", self.name, sorted(dir(M)))
      return None
    # Probe for zero length __init__.py file.
    # If empty then this module is just a module,
    # otherwise it really is part of a package.
    init_py = joinpath(dirname(M.__file__), '__init__.py')
    try:
      S = os.stat(init_py)
    except OSError as e:
      if e.errno == errno.ENOENT:
        warning("%s: M.__package__=%r but no %r", M.__file__, M.__package__, init_py)
        return None
      raise
    else:
      if S.st_size == 0:
        # empty __init__.py, not a package for release purposes
        return None
    return pkg_name

  @prop
  def package(self):
    name = self.package_name
    if name is None:
      name = self.name
      if name.endswith('_tests'):
        name = name[:-6]
    if self.name != name:
      X("%s.package => packages[%r]", self, name)
    return self.packages[name]

  @prop
  def in_package(self):
    ''' Is this module part of a package?
    '''
    return self.package_name is not None

  @prop
  def is_package(self):
    ''' Is this module a package?
    '''
    pkg_name = self.package_name
    return pkg_name is not None and pkg_name == self.name

  @prop
  def dirpath(self):
    M = self.module
    if M is None:
      return None
    if not self.is_package:
      return None
    return os.path.dirname(M.__file__)

  def paths(self):
    ''' Generator yield the .py filenames comprising this package.
    '''
    M = self.module
    if M is None:
      warning("paths: no module found")
      return
    filename = self.module.__file__
    if not self.is_package:
      yield filename
    else:
      moddir = os.path.dirname(filename)
      for dirpath, dirnames, filenames in os.walk(moddir):
        for basename in filenames:
          if basename.endswith('.py'):
            yield os.path.join(dirpath, basename)

  @prop
  def DISTINFO(self):
    D = self._distinfo
    if D is None:
      with Pfx("%s.DISTINFO", self.name):
        D = {}
        M = self.module
        if M is None:
          warning("cannot load module")
        else:
          try:
            D = M.DISTINFO
          except AttributeError:
            pkg_name = self.package_name
            if pkg_name == self.name:
              warning("missing")
            else:
              # look in the package
              P = self.modules[pkg_name]
              PM = P.module
              try:
                D = PM.DISTINFO
              except AttributeError:
                warning("missing and also missing from package %r", pkg_name)
              else:
                ##warning("DISTINFO from package %r", pkg_name)
                pass
          else:
            ##warning("DISTINFO from this module")
            pass
        self._distinfo = D
    return D

  @prop
  def requires(self):
    ''' Return other nonstdlib packages required by this module.
    '''
    return self.DISTINFO.get('install_requires')

  def check(self, silent=False):
    ''' Sanity check a package.
    '''
    if self._check_status is not None:
      return self._check_status
    if not self._checking:
      self._checking = True
      self._check_status = self._check(silent)
      self._checking = False
    return self._check_status

  def _check(self, silent):
    distinfo = self.DISTINFO
    if not distinfo:
      return False
    ok = True
    install_requires = self.requires
    if install_requires is None:
      silent or error("missing DISTINFO[install_requires]")
      ok = False
      install_requires = distinfo.get('requires')
      if install_requires is None:
        install_requires = ()
      else:
        silent or warning("working off DISTINFO[requires]=%r", install_requires)
    install_requires = set(install_requires)
    pkg_name = self.package_name
    if pkg_name is None:
      pkg_prefix = None
    else:
      pkg_prefix = pkg_name + '.'
    # check imports against install_requires
    for name in sorted(self.imported_names):
      if not name.startswith('cs.'):
        M = self.modules[name]
        Mpath = getattr(M.module, '__file__', None)
        if Mpath and '/site-ackages/' in Mpath:
          silent or warning("third party import %r not mentioned in install_requires", name)
          ok = False
        continue
      if name.endswith('_tests'):
        # tests are part of another package: ignore
        continue
      if name == pkg_name:
        # tests usually import the package - this is not a dependency
        continue
      if pkg_prefix and name.startswith(pkg_prefix):
        # package components are not a dependency
        continue
      if name not in install_requires:
        silent or warning("import %r not mentioned in install_requires", name)
        ok = False
        continue
      M = self.modules[name]
      if not M.check(silent):
        ok = False
        continue
    for name in sorted(install_requires):
      if name not in self.imported_names:
        silent or warning("requirement %r not imported", name)
        ok = False
    return ok

  @prop
  @cached
  def imported_names(self):
    ''' Return a set containing the modules names imported by this module
        both directly and indirectly.
    '''
    subnames = set()
    for path in self.paths():
      for name in self.directly_imported_names(self.name, path):
        if name in subnames:
          continue
        subnames.add(name)
    return subnames

  def directly_imported_names(self, module_name, filename, silent=False):
    ''' Yield the module names mentioned by "import" statements
        in the given file.
    '''
    with Pfx(filename):
      with open(filename) as codefp:
        for lineno, line in enumerate(codefp, 1):
          with Pfx(lineno):
            if line.startswith('import ') or line.startswith('from '):
              line = line.strip()
              # quick hack to strip trailing "; second-statement"
              try:
                line, _ = line.split(';', 1)
              except ValueError:
                pass
              words = line.split()
              if not words:
                continue
              if words[0] == 'import' or words[0] == 'from':
                if len(words) < 2:
                  silent or warning("missing module name")
                  continue
                subimport = words[1]
                if subimport == '.':
                  # don't recurse into ourself
                  pkg_name = self.package_name
                  if pkg_name is None:
                    silent or warning("import of '.' from non-package")
                    continue
                  subimport = pkg_name
                elif subimport.startswith('.'):
                  # resolve relative import name
                  preparts = module_name.split('.')
                  subimport = subimport[1:]
                  while subimport.startswith('.'):
                    preparts.pop(-1)
                    subimport = subimport[1:]
                  if preparts:
                    if subimport:
                      preparts.append(subimport)
                  subimport = '.'.join(preparts)
                yield subimport

class VCS(object):

  re_RELEASE_TAG = re.compile(
      #  name       - YYYYMMDD                            [.n]
      r'([a-z][^-]*)-(2[0-9][0-9][0-9][01][0-9][0-3][0-9](\.[1-9]\d*)?)$')

  @cached
  def release_tags(self):
    ''' Generator yielding the current release tags.
    '''
    regexp = self.re_RELEASE_TAG
    release_tags = [ tag for tag in self.tags() if regexp.match(tag) ]
    return release_tags

  def release_prefixes(self):
    ''' Return a set of the existing release prefixes.
    '''
    tagpfxs = set()
    for tag in self.release_tags():
      tagpfx, _ = tag.split('-', 1)
      tagpfxs.add(tagpfx)
    return tagpfxs

class VCS_Hg(VCS):

  def _pipefrom(self, *hgargs):
    hgargv = ['hg'] + list(hgargs) + ['|']
    return pipefrom('hg', *hgargs)

  def hg_cmd(self, *hgargs):
    print('hg', *hgargs, file=sys.stderr)
    check_call(['hg'] + list(hgargs))

  def hg_include(self, paths):
    ''' Generator yielding hg(1) -I/-X option strings to include the `paths`.
    '''
    for subpath in self.paths():
      yield '-I'
      yield 'path:' + subpath

  @cached
  def tags(self):
    ''' Generator yielding the current tags.
    '''
    with self._pipefrom('tags') as hgfp:
      tags = set()
      for tagline in hgfp:
        tag, _ = tagline.split(None, 1)
        yield tag

  def tag(self, tag_name, revision=None):
    ''' Tag a revision with the supplied `tag`, by default revision "tip".
    '''
    if revision is None:
      revision = 'tip'
    self.hg_cmd('tag',  '-r', revision, '--', tag_name)

  def log_since(self, tag, paths):
    with self._pipefrom(
        'log',
        '-r', tag + ':',
        '--template', '{files}\t{desc|firstline}\n',
        '--',
        *paths) as hgfp:
      for hgline in hgfp:
        files, firstline = hgline.split('\t', 1)
        files = files.split()
        firstline = firstline.strip()
        yield files, firstline

  def add_files(self, *paths):
    ''' Add the specified paths to the repository.
    '''
    self.hg_cmd('add', *paths)

  def commit(self, message, *paths):
    ''' Commit the specified `paths` with the specified `message`.
    '''
    self.hg_cmd('commit', '-m', message, '--', *paths)

  def uncommitted(self):
    ''' Generator yielding uncommitted but tracked paths.
    '''
    with self._pipefrom('status') as hgfp:
      for hgline in hgfp:
        s, path = hgline.rstrip().split(' ', 1)
        if s != '?':
          yield path

class ReleaseName(object):
  ''' State surrounding a particular release tag prefix.
  '''

  def __init__(self, prefix, modules, vcs, lv):
    self.prefix = prefix
    self.modules = modules
    self.vcs = vcs
    self.lv = lv

  def check(self, silent=False):
    ''' Perform various sanity checks on the named module, return true if all pass.
    '''
    ok = True
    if not self.modules[self.prefix].check(silent):
      ok = False
    unreleased_changes = list(self.log_since())
    if unreleased_changes:
      show_log = False and not silent and ok
      ok = False
      if not silent:
        error("%d unreleased changes", len(unreleased_changes))
        if show_log:
          for files, firstline in unreleased_changes:
            files = [
                filename[11:] if filename.startswith('lib/python/') else filename
                for filename in files
            ]
            info("  %s: %s", ' '.join(files)+':', firstline)
    return ok

  def tagname(self, suffix):
    ''' Compute a tag name for this release with the supplied `suffix`.
    '''
    tag = self.prefix + '-' + suffix
    m = re_RELEASE_TAG.match(tag)
    if not m:
      raise ValueError("invalid tag made from prefix %r and suffix %r" % (self.prefix, suffix))
    return tag

  def release_tags(self):
    ''' Generator yielding existing release tags.
    '''
    prefix = self.prefix
    prefix_ = prefix + '-'
    for tag in self.vcs.release_tags():
      if tag.startswith(prefix_):
        yield tag

  def release_suffixes(self):
    ''' Generator yielding existing suffixes.
    '''
    poffset = len(self.prefix) + 1
    for tag in self.release_tags():
      yield tag[poffset:]

  def last_suffix(self):
    ''' Return the last release suffix for the specified release prefix, or None.
    '''
    last = None
    for suffix in self.release_suffixes():
      if last is None or suffix > last:
        last = suffix
    return last

  def next_suffix(self):
    ''' Compute the next release suffix.
    '''
    prefix = self.prefix
    last_suffix = self.last_suffix()
    today = isodate(dashed=False)
    if last_suffix is None or last_suffix < today:
      next_suffix = today
    elif last_suffix == today:
      next_suffix = today + '.1'
    else:
      # last_suffix > today, therefore YYYYMMDD.n
      ordinal = last_suffix.split('.', 1)[1]
      if ordinal.startswith('0'):
        raise ValueError("expected last_suffix of the form YYYYMMDD.n, received %r" % (last_suffix,))
      ordinal = int(ordinal)
      next_suffix = today + '.' + str(ordinal + 1)
    return next_suffix

  def next_release_tag(self):
    ''' Compute the next release tag.
    '''
    return self.prefix + '-' + self.next_suffix()

  def paths(self):
    ''' List of paths relevant this name, for use with hg log.
    '''
    prefix = self.prefix
    base = os.path.join(PYLIBTOP, prefix.replace('.', os.sep))
    basepy = base + '.py'
    readme = os.path.join(os.path.dirname(base), 'README-' + os.path.basename(base) + '.rst')
    return base, basepy, readme

  def log_since(self):
    ''' Generator yielding (files, line) tuples
        for log lines since the last release for the supplied `prefix`.
    '''
    suffix = self.last_suffix()
    if suffix is None:
      start_tag = ""
    else:
      start_tag = self.tagname(suffix)
    paths = self.paths()
    for files, firstline in self.vcs.log_since(start_tag, paths):
      files = [ filename for filename in files if filename in paths ]
      yield files, firstline

  def uncommitted(self):
    ''' List of paths relevant to this release with uncommitted changes.
    '''
    pathset = set(self.paths())
    changed = []
    for path in self.vcs.uncommitted():
      if path in pathset:
        changed.append(path)
    return changed

  def submit_pypi(self, force=False):
    return self._submit_pypi('pypi', URL_PYPI_PROD, force=force)

  def last_upload(self, pypi_flavour):
    lastvalue_key = "%s-css-%s" % (pypi_flavour, self.prefix)
    last_pypi_release = self.lv.get(lastvalue_key, "")
    return lastvalue_key, last_pypi_release

  def _submit_pypi(self, pypi_flavour, pypi_url, force=False):
    ''' Submit the latest release of this package to PyPI.
    '''
    if not self.check():
      warning("check fails")
      if force:
        warning("submitting anyway")
      else:
        return
    with Pfx(pypi_flavour):
      last_suffix = self.last_suffix()
      lastvalue_key, last_pypi_release = self.last_upload(pypi_flavour)
      if last_suffix == last_pypi_release:
        info("already released %r", last_suffix)
        if force:
          warning("submitting anyway")
        else:
          return
      with Pfx(
          "%s->%r",
          repr(last_pypi_release) if last_pypi_release else '',
          last_suffix):
        defaults = dict(DISTINFO_DEFAULTS)
        PKG = PyPI_Package(pypi_url, self.prefix, last_suffix, defaults=defaults)
        PKG.upload()
        self.lv[lastvalue_key] = last_suffix

if __name__ == '__main__':
  sys.exit(main(sys.argv))
