#!/usr/bin/python
#
# Apply ID3 tags to files based on their pathname.
#   - Cameron Simpson <cs@zip.com.au> 24aug2014
#

from os.path import basename, dirname
import sys
from cs.id3 import ID3
from cs.lex import get_identifier
from cs.logutils import setup_logging, Pfx, X

usage = '''Usage: %s [--clean] [--deduce] [--infer] [tag=value...] [--] filenames...
    --clean     Strip trailing NULs and leading and trailing whitespace from tags.
    --deduce    Overwrite tags with values deduced from file pathname.
    --infer     Update tags (if missing or blank) with values inferred from file pathname.'''

def main(argv):
  xit = 0
  cmd = basename(argv[0])
  setup_logging(cmd)
  args = argv[1:]
  do_clean = False
  do_deduce = False
  do_infer = False
  tag_values = {}
  badopts = False
  while args:
    arg = args.pop(0)
    if arg == '--':
      break
    if arg == '--clean':
      do_clean = True
      continue
    if arg == '--deduce':
      do_deduce = True
      continue
    if arg == '--infer':
      do_infer = True
      continue
    # tag=value
    tag_name, offset = get_identifier(arg)
    if offset > 0 and offset < len(arg) and arg[offset] == '=':
      tag_value = arg[offset+1:]
      tag_values[tag_name] = tag_value
      continue
    if not arg.startswith('-'):
      args.insert(0, arg)
      break
    error("invalid option: %s", arg)
    badopts = True

  if do_deduce and do_infer:
    error("you may not specify both --deduce and --infer")
    badopts = True

  for mp3path in mp3paths:
    X(mp3path)
    mp3 = ID3(mp3path)
    ##info = pathinfo(mp3path)
    ##X(repr(info))
    X("mp3 artist = %r, ", mp3.artist)
    ##for tag_name in ( 'artist', 'album', 'title'):
    ##  mp3[tag_name] = info[tag_name]
    ##update_tracknum(mp3, info['tracknum'])
    ### SKIP mp3.flush()
    for frame in mp3.tag:
      frameid = frame['frameid']
      if frameid not in ID3.frameids_to_names:
        print "UNKNOWN frameid %r: %r" % (frameid, frame)
      else:
        frame_name = ID3.frameids_to_names[frameid][0]
        if frame_name == 'attached_picture':
          frame['data'] = '%d bytes' % (len(frame['data']),)
        print "%s: %r" % (frame_name, frame)
      if 'text' not in frame:
        print "  no 'text' field"
    break
  return xit

def pathinfo(path, sep='/'):
  ''' Deduce metadata from file pathname `path`.
      Expected format:
        .../AlbumArtist/AlbumName/[discnum-]tracknum trackname
  '''
  X("PATHINFO: sep=%r", sep)
  with Pfx(path):
    info = {}

    if sep == '/':
      # split on path components
      filepart = basename(path)
      pathdir = dirname(path)
      dirpart = basename(pathdir)
      pathdir2 = dirname(pathdir)
      dirpart2 = basename(pathdir2)
      parts = [ dirpart2, dirpart, filepart ]
    else:
      # split basename on separator
      parts = basename(path).rsplit(sep, 2)

    X("PATHINFO: parts = %r", parts)
    artist, album, trackpart = parts
    info['album'] = album
    info['artist'] = artist
    left, ext = trackpart.rsplit('.', 1)
    if ext != 'mp3':
      raise ValueError('expected name to end in .mp3')
    # optional leading disc number with dash
    if left[0].isdigit() and left[1] == '-':
      info['disc_num'] = int(left[0])
      left = left[2:]
    # leading track number, 2 digits
    if not left[:2].isdigit():
      raise ValueError('expected 2 leading digits')
    info['track_number'] = str(int(left[:2]))
    info['title'] = left[2:].strip()
    return info

def update_tracknum(mp3, new_tracknum):
  track = mp3.track
  if track[0] != new_tracknum:
    new_track = tuple( [new_tracknum] + track[1:] )
    X(".track: %r => %r", track, new_track)
    mp3.track = new_track

def norm_artist(artist):
  if artist[:4].lower() == 'the ' and ',' not in artist:
    artist = ', '.join( ( artist[4:].lstrip(), artist[:3] ) )
  return artist

if __name__ == '__main__':
  sys.exit(main(sys.argv))
