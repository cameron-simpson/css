#!/bin/sh
#
# Write a possibly-colourised string to the alert log.
#	- Cameron Simpson <cs@zip.com.au>
#

set -ue

: ${OS:=`uname -s | tr '[A-Z]' '[a-z]'`}
: ${LOGDIR:=$HOME/var/log}
: ${ALERTLOG:=$LOGDIR/alert-local}
: ${ALERT_TO:='log stderr'}
: ${ALERT_GROUP:=''}

cmd=$0
usage="Usage: $cmd [-A alert_to] [-c colour] [-e command [args...] --] [-l level] [-s subtitle] [-t title] {-|echo-args...]}"

colour=
level=1
growl=
tnotify=
title=
subtitle=
execute=
case "$OS" in
  darwin)
    ##growl=1
    tnotify=1
    ;;
esac
if flag -w GROWL_DISABLE
then  growl=
fi

badopts=

while [ $# -gt 0 ]
do
  case $1 in
    -A) ALERT_TO=$2; shift ;;
    -c) colour=$2; shift ;;
    -e) shift
        firstarg=1
        tailargs=
        for arg
        do
          if [ $tailargs ]
          then
            # re-accrue the trailing arguments
            set -- ${1+"$@"} "$arg"
          else
            if [ "x$arg" = x-- ]
            then
              if [ $firstarg ]
              then
                echo "$cmd: missing command after -e" >&2
                badopts=1
              else
                execute=$( as-script "$@" )
                execute='exec >>"$ALERTLOG" 2>&1; '$execute
              fi
              set --
              tailargs=1
            else
              [ $firstarg ] && { set --; firstarg=; }
              set -- ${1+"$@"} "$arg"
            fi
          fi
        done
        if [ -z "$tailargs" ]
        then
          echo "$cmd: -e: missing trailing --" >&2
          badopts=1
        fi
        continue
        ;;
    -l) level=$2; shift ;;
    -t) title=$2; shift ;;
    -s) subtitle=$2; shift ;;
    --) shift; break ;;
    -?*)echo "$cmd: unrecognised option: $1" >&2
        badopts=1
        ;;
    *)  break ;;
  esac
  shift
done

if [ $# = 0 ]
then
  echo "$cmd: missing \"-\" or echo-args" >&2
  badopts=1
else
  case "$*" in
    -)  set -- "`cat`" ;;
  esac
fi

to_log=
to_desktop=
to_dlog=
to_stderr=
for alert_to in $ALERT_TO
do
  case $alert_to in
    log)        to_log=1 ;;
    desktop)    to_desktop=1 ;;
    dlog)       to_dlog=1 ;;
    stderr)     to_stderr=1 ;;
    *)          echo "$cmd: unsupported alert_to target ignored: $alert_to" >&2 ;;
  esac
done

[ $badopts ] && { echo "$usage" >&2; exit 2; }

exec </dev/null

xit=0

message=$*
if [ -z "$title" ]
then
  tag=`expr "x$message" : 'x\([A-Z][A-Z0-9_]*\):  *' || :`
  if [ -n "$tag" ]
  then
    title=$tag
    message=`expr "x$message" : 'x[A-Z][A-Z0-9_]*:  *\(.*\)' || :`
  fi
fi

if [ -z "$subtitle" ]
then
  tag=`expr "x$message" : 'x\([^:]*\):  *' || :`
  if [ -n "$tag" ]
  then
    subtitle=$tag
    message=`expr "x$message" : 'x[^:]*:  *\(.*\)' || :`
  fi
fi

set -- "$message"
[ -n "$subtitle" ] && set -- "$subtitle;" ${1+"$@"}
[ -n "$title" ] && set -- "$title:" ${1+"$@"}

if [ $to_log ]
then
  if [ -n "$colour" ]
  then  colour_echo "$colour" "$*"
  else  echo "$*"
  fi >>"$ALERTLOG" || xit=1
fi

[ $to_dlog ] && dlog "ALERT: $*"

if [ $to_desktop ]
then
  if [ $growl ]
  then
    # try growlnotify, otherwise hope /dev/tty is an iTerm
    growlnotify -m "$*" || echo $'\e]9;$*\a' >/dev/tty || xit=1
  fi

  if [ $tnotify ]
  then
    for var in title subtitle message
    do  eval "val=\$$var"
        val=`echo $val`
        case "$val" in
          *[\'\\]*)        val=`shqstr "$val"` ;;
        esac
        eval "$var=\$val"
    done
    set -- terminal-notifier -title "$title" -subtitle "$subtitle" -message "$message"
    # message group - this message updates/replaces last message in this group
    [ -n "$ALERT_GROUP" ] && set -- "$@" -group "$ALERT_GROUP"
    # command to run when notifier clicked
    [ -n "$execute" ] && set -- "$@" -execute "$execute"
    set -- timeout 10 reattach-to-user-namespace "$@"
    # async because I've seen terminal-notifier hang, stalling my mail filer
    # timeout also to stop hanging processes filling the process table
    "$@" >/dev/null || to_stderr=1
  fi
fi

[ $to_stderr ] && echo ALERT: "$title $subtitle $message" >&2

exit $xit
