#!/bin/sh
#
# Run ffmpeg via the linuxserver/ffmpeg Docker image.
# - Cameron Simpson <cs@cskk.id.au> 29jan2023
#

set -ue

use_tmux=
[ -n "${FFMPEG_DOCKER_TMUX:-}" ] && use_tmux=1
image=linuxserver/ffmpeg
runopts='--rm --read-only'
run_pull_mode=missing
ff_postopts=

cmd=$0
usage="Usage: $cmd [--tm] [-U] [input-opts...] -i inputfile [output-opts...] outputfile
  Run ffmpeg via \"docker run ... $image ...\" as a method for
  running a modern ffmpeg on a stale system.

  Leading options:
  --tm  Run the \"docker run ...\" in a tmux(1) session via the tm(1cs) command.
        This is handy when your transcoding machine is remote, or
        when you want to run a few ffmpegs in named sessions.
        I keep a shell alias \"fftm=ffmpeg-docker --tm\" for this purpose.
  -U    Update the docker image using \"docker run --pull always\".
        The default is \"--pull missing\"."

badopts=

while [ $# -gt 0 ]
do
  case $1 in
    --tm)   use_tmux=1 ;;
    -U)     run_pull_mode=always ;;
    *)      break ;;
  esac
  shift
done

[ $badopts ] && { echo "$usage" >&2; exit 2; }

# docker_name=$( echo "ffmpeg $inputbase $$" | tr -s "' .:+" "_____" )

set -- \
  python3 -c 'if 1:
                import sys
                from cs.ffmpegutils import ffmpeg_docker
                sys.exit(ffmpeg_docker(*sys.argv[1:]).returncode)
             ' ${1+"$@"}

if [ $use_tmux ]
then
  # session_name=$( echo "FFMPEG_$inputbase $outputbase $$" | tr -s ' .:+' '____' )
  session_name=$( echo "FFMPEG_$$" | tr -s ' .:+' '____' )
  set -- tm -x "$session_name" "$@"
fi

set -x
exec "$@"
