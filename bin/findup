#!/bin/sh
#
# Look for a relative path in all directories from the current one upward.
#   - Cameron Simpson <cs@zip.com.au> 04may2016
# 

set -ue

cmd=$( basename "$0" )
usage="Usage: $cmd [-a] [-d] {relpath|.} [{-c shcmd | testcmd [args...]}]
  -a    Find all matches. Default is to stop after the first match.
  -c shcmd
        Run shell command \"shcmd\" with the environment variable
  -d    Print the test directory instead of the test directory plus
        \"relpath\".
  Environment:
        \$FINDUP_DIR is set to the test directory.
        \$FINDUP_PATH is set to the test path (the test directory
        with \"relpath\" appended, unless \"relpath\" is \".\" or
        the empty string, in which case it will just be the test
        directory."

all=
dirmode=
shmode=

badopts=

while [ $# -gt 0 ]
do
  case $1 in
    -a) all=1 ;;
    -d) dirmode=1 ;;
    --) shift; break ;;
    -?*)echo "$cmd: unrecognised option: $1" >&2
        badopts=1
        ;;
    *)  break ;;
  esac
  shift
done

if [ $# = 0 ]
then
  echo "$cmd: missing relpath" >&2
  badopts=1
else
  relpath=$1
  shift
fi

[ $badopts ] && { echo "$usage" >&2; exit 2; }

# default test: path exists
if [ $# = 0 ]
then
  set -- test -e
else
  if [ "x$1" = x-c ]
  then
    shmode=1
    shift
    if [ $# = 0 ]
    then
      echo "$cmd: -c: missing shcmd" >&2
      badopts=1
    else
      shcmd=$1
      shift
      [ $# = 0 ] || { echo "$cmd: -c: extra arguments after shcmd: $*" >&2
                      badopts=1
                    }
    fi
  fi
fi

xit=1

odir=
dir=$( pwd )
while [ -z "$odir" ] || [ "x$odir" != "x$dir" ]
do
  case "$relpath" in
    '' | . )    path=$dir ;;
    *)          path=$dir/$relpath ;;
  esac
  if if [ $shmode ]
     then  FINDUP_DIR=$dir FINDUP_PATH=$path sh -c "$shcmd"
     else  FINDUP_DIR=$dir FINDUP_PATH=$path "$@" "$path"
     fi
  then
    xit=0
    if [ $dirmode ]
    then  printf '%s\n' "$dir"
    else  printf '%s\n' "$path"
    fi
    [ $all ] || break
  fi
  odir=$dir
  dir=$( dirname "$dir" )
done

exit $xit
