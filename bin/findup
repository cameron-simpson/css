#!/bin/sh
#
# Look for a relative path in all directories from the current one upward.
#   - Cameron Simpson <cs@zip.com.au> 04may2016
# 

set -ue

cmd=$( basename "$0" )
usage="Usage: $cmd [-a] relpath [{-c shcmd | testcmd [args...]}]
  -a    Find all matches. Default is to stop after the first match.
  -c shcmd
        Run shell command \"shcmd\" with the environment variable
        \$FINDUP_PATH set to the test directory."

all=
shmode=

badopts=

while [ $# -gt 0 ]
do
  case $1 in
    -a) all=1 ;;
    --) shift; break ;;
    -?*)echo "$cmd: unrecognised option: $1" >&2
        badopts=1
        ;;
    *)  break ;;
  esac
  shift
done

if [ $# = 0 ]
then
  echo "$cmd: missing relpath" >&2
  badopts=1
else
  relpath=$1
  shift
fi

[ $badopts ] && { echo "$usage" >&2; exit 2; }

# default test: path exists
if [ $# = 0 ]
then
  set -- test -e
else
  if [ "x$1" = x-c ]
  then
    shmode=1
    shift
    if [ $# = 0 ]
    then
      echo "$cmd: -c: missing shcmd" >&2
      badopts=1
    else
      shcmd=$1
      shift
      [ $# = 0 ] || { echo "$cmd: -c: extra arguments after shcmd: $*" >&2
                      badopts=1
                    }
    fi
  fi
fi

xit=1

odir=
dir=$( pwd )
while [ -z "$odir" ] || [ "x$odir" != "x$dir" ]
do
  path=$dir/$relpath
  if if [ $shmode ]
     then  FINDUP_PATH=$path sh -c "$shcmd"
     else  "$@" "$path"
     fi
  then
    xit=0
    printf '%s\n' "$path"
    [ $all ] || break
  fi
  odir=$dir
  dir=$( dirname "$dir" )
done

exit $xit
