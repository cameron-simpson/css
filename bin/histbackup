#!/bin/sh
#
# Freshmeat release: 2011-02-19
#
# =head1 NAME
#
# histbackup - backup a directory using an incremental technique
#
# =head1 SYNOPSIS
#
# histbackup [options...] [host:]source backupdir [otherbackupdirs...] [rsyncopts...]
#
# histbackup [options...] --no-rsync backupdir
#
# histbackup [options...] [-- [rsyncopts...]]
#
# =head1 DESCRIPTION
#
# I<histbackup>
# makes incremental backups of a directory tree
# in a set of directories named by dates, or date-time if the date already exists.
# The new backup is prepopulated by hardlinks of each file from the previous backup
# and then updated with rsync(1).
# This arranges that the only new content of each new backup is fresh copies of the changed files.
# In this way each backup directory is a full copy of the source directory
# but the disc space cost is that of an incremental backup.
# Because it uses rsync,
# it is possible efficiently to backup remote directories in this manner.
# The companion script I<histbackup-prune> keeps the growth under control.
#
# =head1 SETUP AND USE
#
# Before deployment, decide who will own and do the backups.
# Do all the local (backup end) setup as that user.
# If you're not a sysadmin then that user is probably yourself.
#
# Generally, setup is as follows:
#
# =over 4
#
# =item Create the backup area.
#
# Decide where the backup data will be. Make an empty directory to hold it:
#
#       mkdir /path/to/backup/area
#
# =item Arrange access to the source data
#
# If the data to backup are local to this machine
# you merely need read access to it.
# If the data are remote
# you will need ssh(1) access to the remote host as a user with read access to the data there.
# Test it:
#
#       ssh user@remote ls -l /path/to/source/directory
#
# =item Perform a test backup
#
# Histbackup does the right thing when the backup area is empty
# so just:
#
#       histbackup -x user@remote:/path/to/source/directory /path/to/backup/area
#
# =item Schedule your backups
#
# If these backups are to happen regularly
# a crontab(5) entry should be made to do so.
# Use "C<crontab -e>" to make this.
# Example:
#
#       MAILTO=backup-admin@yoursite
#       PATH=$PATH:/opt/css/bin
#       0 * * * * histbackup -x user@remote:/path/to/source/directory /path/to/backup/area
#
# That will run a I<histbackup> every day at midnight,
# delivering the output of the run by email to B<backup-admin@yoursite>.
#
# Note that cron's environment is very spartan
# (it does not source C</etc/profile> or C<~/.profile>)
# and so you may need to arrange that the CSS package's environment is present.
# Also,
# because cron is a batch situation,
# your ssh access will almost certainly require a special purpose passphraseless key
# to access the remote host.
#
# =back
#

set -ue

trace=
[ -t 2 ] && trace=set-x
vecho=:
symlink=LATEST
src=
dest=
linkonly=
rrsync=rsync
usehbinclude=1
usehbfiles=1
obackup_options=
symlink_unchanged=1
rsopts=
rsdelete=--delete
thisbackup=
verbose=
imode=
##[ -t 1 ] && verbose=1

cmd=`basename "$0"`
usage="Usage:
  $cmd [options...] [host:]source backupdir [otherbackupdirs...] [rsyncopts...]
  $cmd [options...] --no-rsync backupdir
  $cmd [options...] [-- [rsyncopts...]]

  -A, --acls    Preserve ACLs. Passed to rsync.
  -i, --itemize-changes
                Passed to rsync, result slightly filtered by histbackup.
  -v, --verbose Verbose. Note: _not_ passed to rsync.
  -x            Trace execution. Recite linktree and rsync invocations.
  --no-delete   Don't pass --delete to rsync.
  --date datestring A date string for use as the backup target.
                The default is the current date or date-time.
  --delete      Pass --delete to rsync.
  --delete-excluded
                Pass --delete --delete-excluded to rsync.
  --no-hbfiles  Do not honour the .hbfiles file in the backup directory.
  --no-hbinclude Do not honour the .hbinclude file in the backup directory.
  --no-rsync    Don't do the rsync pass - just set up the new link tree and
                report its basename.
  --link-fail-repair (Obsolete; this is always done.)
                Proceed even if the linktree step fails, presumably due
                to hard link limit reached.
  --symlink-if-unchanged
                Just symlink the top level date if there are no changes.
                Requires a prepass \"rsync -n\" but saves a lot of hardlinks
                and time if the tree is often unchanged.
                This is the default.
  --no-symlink-if-unchanged
                Make a link tree even when there are no changes.
  --rsync-path rrsync Execute the command \"rrsync\" as the remote rsync.
                Passed to rsync.
  --symlink name Make a symlink named \"name\" pointing at the latest backup.
                 Default: $symlink
                 Supply the empty string for no symlink."

badopts=

# have "cp -ral"? otherwise rely on my linktree script
if [ "x`cp --help 2>&1 | grep ' -[ral][, ]' | wc -l`" = x3 ]
then
  mklinktree(){
    [ $# = 2 ] || { echo "Usage: mklinktree srcdir dstdir" >&2; return 2; }
    _mkl_src=$1
    _mkl_dst=$2
    case "$_mkl_dst" in
      /* | ./* ) ;; *) _mkl_dst=./$_mkl_dst ;;
    esac
    # make link tree, might fail if hard link limit reached for files
    $trace cp -ral "$1" "$2" && return 0
    # failed to make target? fail outright
    [ -d "$2/." ] || return 1
    # if we made the target, update from source
    $trace rsync -iaO "$1/." "$2/."
  }
else
  mklinktree(){ $trace linktree "$1" "$2"; }
fi
daycode(){ date '+%Y-%m-%d'; }
datecode(){ date '+%Y-%m-%d-%H:%M:%S'; }

### rsync capabilities at local end
##rsync_has_link_dest=
##rsv=`rsync --version | sed -n 's/^rsync *version \([1-9]\)\.\([0-9][0-9]*\)\.\([0-9][0-9]*\) .*/\1 \2 \3/p'`
##if [ -n "$rsv" ] && rsvn=`set -- $rsv; printf "%d%03d%03d\n" "$@"`
##then
##  [ "$rsvn" -ge 2005006 ] && rsync_has_link_dest=1
##  ## other end needs proto 29 also ## [ "$rsvn" -ge 2006004 ] && rsopts="$rsopts --fuzzy"
##fi

# =head1 OPTIONS
#
# =over 4
#
while [ $# -gt 0 ]
do
  case $1 in

    # =item --no-delete
    #
    # Suppress passing the B<--delete> or B<--delete-excluded> option to rsync.
    #
    --no-delete)
      rsdelete=
      ;;

    # =item --no-rsync
    #
    # Skip the rsync step; just create the new link tree.
    #
    --no-rsync)
      linkonly=1
      ;;

    # =item --link-fail-repair
    #
    # Proceed even if the linktree step fails, presumably due to
    # reaching the filesystem hard link limit. Does a repair rsync
    # from the previous to new backup before proceeding.
    #
    --link-fail-repair)
      echo "$cmd: $1: obsolete option; $cmd always tries to cope with hard link failure" >&2
      ;;
    # =item --symlink-if-unchanged
    #
    # Symlink the top level date if there are no changes to the tree.
    # This requires a prepass with "rsync -n" but saves time and
    # hardlinks if there are no changes.
    #
    --symlink-if-unchanged)
        symlink_unchanged=1
        ;;
    # =item --no-symlink-if-unchanged
    #
    # Do not symlink the top level date if there are no changes to the tree,
    # instead always make a hard link tree.
    #
    --no-symlink-if-unchanged)
        symlink_unchanged=
        ;;
    # =item --date datestring
    #
    # Specify datestring for this backup. The default is the current date or date-time.
    #
    --date)
        thisbackup=$2; shift
        ;;
    # =item --delete
    #
    # Passed to rsync.
    #
    --delete)
      rsdelete="$rsdelete --delete"
      ;;

    # =item --delete-excluded
    #
    # Passed to rsync. Also implies --delete.
    #
    --delete-excluded)
      rsdelete='--delete --delete-excluded'
      ;;

    # =item --no-hbfiles
    #
    # Do not honour the .hbfiles file in the backup directory.
    # 
    --no-hbfiles)
      usehbfiles=
      ;;

    # =item --no-hbinclude
    #
    # Do not honour the .hbinclude file in the backup directory.
    # 
    --no-hbinclude)
      usehbinclude=
      ;;

    # =item --rsync-path rrsync
    #
    # Passed to rsync.
    # Specifies the pathname to the remote rsync executable.
    #
    --rsync-path)
      rrsync=$2; shift ;;

    # =item --symlink name
    #
    # After the backup is done,
    # make a symbolic link named I<name> pointing at the latest backup directory.
    # This is useful so that other programs may trivially reference the latest
    # backup without having to figure out its name.
    # Eg: B<--symlink LATEST>.
    #
    --symlink)
      symlink=$2; shift ;;

    # =item -A, --acls
    #
    # Preserve ACLs. Passed to rsync.
    #
    -A|--acls)
      rsopts="$rsopts $1"
      ;;

    # =item -i, --itemize-changes
    #
    # Itemise changes. Passed to rsync, but histbackup strips a few noisy outputs.
    #
    -i|--itemize-changes)
      imode=1
      rsopts="$rsopts -i"
      ;;

    # =item -v, --verbose
    #
    # Turn on verbose mode.
    #
    -v|--verbose)
      verbose=1
      vecho=echo
      ;;

    # =item -x
    #
    # Trace execution of important commands (rsync, linktree etc).
    #
    -x)         trace=set-x ;;

    --)         shift; break ;;
    -*)         echo "$cmd: unrecognised option: $1" >&2
                badopts=1
                ;;
    *)          break ;;
  esac
  shift
done

#
# =back
#
# =head1 Post Option Arguments
#
# If the B<--no-rsync> option has been used, only the destination
# directory appears after the options. It will be initialised for use.
#
# If neither the source not destination appear
# it is expected that the destination is the current directory
# and that the source is specified by the .hbsource file in the current directory.
#
# Otherwise, the source and destination appear.
# These may be followed by I<otherbackupdirs>, the full paths of other directories like the one B<histbackup> is copying;
# these will be handed to rsync(1) as B<--link-dest> options.
# After the I<otherbackupdirs>, other rsync(1) options may be supplied;
# these will be passed to rsync.
#

if [ $linkonly ]
then
    if [ $# -lt 1 ]
    then
        echo "$cmd: missing parent" >&2
        badopts=1
    else
        dest=$1
        shift
    fi
else
    case "$*" in
      '' | -* )
        # neither source nor backupdir: use .hbsource and "."
        src=
        dest=.
        if [ ! -f .hbsource ]
        then
          echo "$cmd: missing .hbsource" >&2
          badopts=1
        else
          src=$(<.hbsource)
          [ -n "$src" ] || { echo "$cmd: empty source from .hbsource" >&2; badopts=1; }
        fi
        ;;
      *)
        # expect source _and_ backupdir
        if [ $# -lt 2 ]
        then
            echo "$cmd: missing source or backupdir" >&2
            badopts=1
        else
            src=$1 dest=$2
            shift; shift
            # gather other backup dirs, turn into --link-dest= options
            obackup_count=0
            while [ $# -gt 0 ]
            do
              case "x$1" in
                x/*)
                  obackup=$1; shift
                  if [ "$obackup_count" -lt 20 ]
                  then
                    obackup_options="$obackup_options --link-dest=$obackup"
                    obackup_count=`expr $obackup_count + 1`
                  else
                    $vecho "$cmd: warning: ignoring --link-dest=$obackup due to arbitrary rsync limit of 20 such" >&2
                  fi
                  ;;
                *)break
                  ;;
              esac
            done
        fi
        ;;
    esac
fi

if [ $linkonly ] && [ $# -gt 0 ]
then
    echo "$cmd: --no-rsync: extra arguments after parent: $*" >&2
    badopts=1
fi

[ -d "$dest/." ] || { echo "$cmd: backup dir $dest: not a directory" >&2
                      badopts=1
                    }

# sanity check $src
case "$src" in
    '')         [ $linkonly ] || { echo "$cmd: empty src, rejected" >&2; badopts=1; }
                ;;
    *:*)        # remote - don't check
                ;;
    *)          [ -d "$src/."  ] || { echo "$cmd: source dir $src: not a directory" >&2
                                      badopts=1
                                    }
                ;;
esac

[ $badopts ] && { echo "$usage" >&2; exit 2; }

if [ $linkonly ]
then
  # protect against accidental misused of $src
  unset src
  exec 3>&1 1>&2
fi

if [ $imode ]
then
  # filter out mention of directories, symlink times and hard links
  filteroutput=`shqstr sed '/\/$/d; /^\.L\.\.[Tt]\.\.\.\.\.\. .* -> /d; /^\.d/d; /^hf/d'`
fi

# =head1 CUSTOMISATION FILES
#
# If the file I<backupdir>/F<.hfiles> is present
# the options B<"-r --files-from=>I<backupdir>/F<.hbinclude>
# will be added to the I<rsync> command invocation.
# In this way specific contents may be backed up.
# See rsync(1).
#
if [ $usehbfiles ]
then
  hbfiles=$dest/.hbfiles
  if [ -f "$hbfiles" ]
  then
    if [ ! -s "$hbfiles" ]
    then
      echo "$cmd: $hbfiles: expected non-empty file, aborting" >&2
      exit 1
    fi
    set -- ${1+"$@"} -r "--files-from=$hbfiles"
  fi
fi

#
# If the file I<backupdir>/F<.hbinclude> is present
# the option B<"--include-from=>I<backupdir>/F<.hbinclude>
# will be added to the I<rsync> command invocation.
# In this way the content to be backed up may be tuned.
# See rsync(1).
#
if [ $usehbinclude ]
then
  hbinclude=$dest/.hbinclude
  [ -s "$hbinclude" ] && set -- ${1+"$@"} "--include-from=$hbinclude"
fi

# determine name for this backup
if [ -n "$thisbackup" ]
then
  # check specified backup does not yet exist
  if [ -d "$dest/$thisbackup/." ]
  then
    echo "$cmd: $dest/$thisbackup already exist, aborting" >&2
    exit 1
  fi
else
  # allocate a backup name
  today=`daycode` || exit 1
  thisbackup=$today
  if [ -d "$dest/$thisbackup/." ]
  then
    now=`datecode` || exit 1
    thisbackup=$now
    if [ -d "$dest/$thisbackup/." ]
    then
      echo "$cmd: $dest/$today and $dest/$now already exist, aborting" >&2
      exit 1
    fi
  fi
fi

# locate to most recent backup, if any
lastbackup=$(
        cd "$dest" || exit 1
        (
          if [ $symlink_unchanged ] || [ $linkonly ]
          then
            # actual directory trees only
            ls -ld [0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]* 2>/dev/null \
            | sed -n 's/^d.* //p'
          else
            # directory or symlink
            ls -d [0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]* 2>/dev/null
          fi
          echo "$thisbackup"
        ) \
        | sort -u \
        | sed "/^$thisbackup/,\$d" \
        | sed -n '$p'
)

dorsync()
{ [ $# -ge 2 ] || { echo "Usage: dorsync src dst [extra-rsync-opts...]" >&2; exit 2; }
  _drs_src=$1
  _drs_dst=$2
  shift; shift
  case "$_drs_dst" in
    /* | ./* | ../* ) ;; 
    *) _drs_dst=./$_drs_dst ;;
  esac
  set -- rsync $rsopts -aH $rsdelete --rsync-path "$rrsync" ${1+"$@"} "$_drs_src/" "$_drs_dst/"
  [ $imode ] && set -- filter_fd 1 "$filteroutput" "$@"
  $trace "$@"
}

ok=

dolink=1
if [ -n "$lastbackup" -a -d "$dest/$lastbackup/." ]
then
    if [ $symlink_unchanged ] && [ -z "$linkonly" ]
    then
      $vecho "checking for changes to $src from $lastbackup ..."
      changes=$( dorsync "$src" "$dest/$lastbackup" ${1+"$@"} -niO \
               | sed -n '/^..         /!{ p; q; }' \
               )
      if [ -z "$changes" ]
      then
        $vecho "no changes, symlinking last tree"
        ( cd "$dest" || exit 1
          exec $trace ln -s "$lastbackup" "$thisbackup"
        )
        exit
      else
        $vecho "changes, proceeding with regular backup ..."
      fi
    fi
    $vecho "existing backup: linking $lastbackup to $thisbackup ..."
    if ( cd "$dest" || exit 1
         mklinktree "$lastbackup" "$thisbackup" \
         || {
           dolink=
           $trace rm -rf "$thisbackup"
           false
         }
       )
    then
      ok=1
      if [ $linkonly ]
      then  echo "$dest/$thisbackup" >&3
      else  $vecho "updating $thisbackup from $src ..."
      fi
    fi
else
    if [ $linkonly ]
    then
        echo "$cmd: $dest: no subdirectory to link from" >&2
        ls -la "$dest" >&2
        exit 1
    else
        $vecho "fresh backup, just copying source ..."
        $trace mkdir "$dest/$thisbackup" && ok=1
    fi
fi

if [ $ok ] && [ -z "$linkonly" ]
then
  dorsync "$src" "$dest/$thisbackup" ${1+"$@"} $obackup_options
fi

if [ $ok ] && [ -n "$symlink" -a -d "$dest/$thisbackup/." ]
then
  if [ $dolink ]
  then
    ( cd "$dest" || exit 1
      rm -f "$symlink"
      $trace ln -s "$thisbackup" "$symlink"
    ) || ok=
  else
    echo "$cmd: new directory worse than old, symlink \"$symlink\" not made" >&2
    ok=
  fi
fi

[ $ok ]
exit

# =head1 AUTHOR
#
# Cameron Simpson <cs@zip.com.au> 03apr2000
#
# =head1 SEE ALSO
#
# histbackup-prune(1cs), linktree(1cs), rsync(1), ssh(1), cp(1), cpdir(1cs), crontab(1), crontab(5)
#
