#!/bin/sh
#
# Freshmeat release: 2011-02-19
#
# =head1 NAME
#
# histbackup - backup a directory using an incremental technique
#
# =head1 SYNOPSIS
#
# histbackup [options...] [host:]source backupdir [otherbackupdirs...] [rsyncopts...]
#
# histbackup [options...] --no-rsync backupdir
#
# histbackup [options...] [-- [rsyncopts...]]
#
# =head1 DESCRIPTION
#
# I<histbackup>
# makes incremental backups of a directory tree
# in a set of directories named by dates, or date-time if the date already exists.
# The new backup is prepopulated by hardlinks of each file from the previous backup
# and then updated with rsync(1).
# This arranges that the only new content of each new backup is fresh copies of the changed files.
# In this way each backup directory is a full copy of the source directory
# but the disc space cost is that of an incremental backup.
# Because it uses rsync,
# it is possible efficiently to backup remote directories in this manner.
# The companion script I<histbackup-prune> keeps the growth under control.
#
# =head1 SETUP AND USE
#
# Before deployment, decide who will own and do the backups.
# Do all the local (backup end) setup as that user.
# If you're not a sysadmin then that user is probably yourself.
#
# Generally, setup is as follows:
#
# =over 4
#
# =item Create the backup area.
#
# Decide where the backup data will be. Make an empty directory to hold it:
#
#       mkdir /path/to/backup/area
#
# =item Arrange access to the source data
#
# If the data to backup are local to this machine
# you merely need read access to it.
# If the data are remote
# you will need ssh(1) access to the remote host as a user with read access to the data there.
# Test it:
#
#       ssh user@remote ls -l /path/to/source/directory
#
# =item Perform a test backup
#
# Histbackup does the right thing when the backup area is empty
# so just:
#
#       histbackup -x user@remote:/path/to/source/directory /path/to/backup/area
#
# =item Schedule your backups
#
# If these backups are to happen regularly
# a crontab(5) entry should be made to do so.
# Use "C<crontab -e>" to make this.
# Example:
#
#       MAILTO=backup-admin@yoursite
#       PATH=$PATH:/opt/css/bin
#       0 * * * * histbackup -x user@remote:/path/to/source/directory /path/to/backup/area
#
# That will run a I<histbackup> every day at midnight,
# delivering the output of the run by email to B<backup-admin@yoursite>.
#
# Note that cron's environment is very spartan
# (it does not source C</etc/profile> or C<~/.profile>)
# and so you may need to arrange that the CSS package's environment is present.
# Also,
# because cron is a batch situation,
# your ssh access will almost certainly require a special purpose passphraseless key
# to access the remote host.
#
# =back
#

set -ue

trace=
[ -t 2 ] && trace=set-x
vecho=:
symlink=LATEST
src=
dest=
linkonly=
rrsync=rsync
usehbinclude=1
usehbfiles=1
obackup_options=
symlink_unchanged=1
rsopts=
copytimes=
rsdelete=--delete
thisbackup=
reverse=
verbose=
imode=
##[ -t 1 ] && verbose=1

cmd=`basename "$0"`
usage="Usage:
  $cmd [options...] [host:]source backupdir [otherbackupdirs...] [rsyncopts...]
  $cmd [options...] --no-rsync backupdir
  $cmd [options...] [-- [rsyncopts...]]

  -A, --acls    Preserve ACLs. Passed to rsync.
  -i, --itemize-changes
                Passed to rsync, result slightly filtered by histbackup.
  -r, --reverse Reverse. Consider the youngest older date instead
                of the oldest younger date as the reference tree.
                Clears any --symlink setting; --symlink must come
                later than this option is required.
  -v, --verbose Verbose. Note: _not_ passed to rsync.
  -x            Trace execution. Recite linktree and rsync invocations.
  --copy-times  Copy file timestamps from the source tree to the
                new link tree before the rsync pass. Useful for
                media libraries which may be touched to aid browsing
                order but dangerous for files where the content
                might change without a change in file size.
  --no-delete   Don't pass --delete to rsync.
  --date datestring A date string for use as the backup target.
                The default is the current date or date-time.
  --delete      Pass --delete to rsync.
  --delete-excluded
                Pass --delete --delete-excluded to rsync.
  --no-hbfiles  Do not honour the .hbfiles file in the backup directory.
  --no-hbinclude Do not honour the .hbinclude file in the backup directory.
  --no-rsync    Don't do the rsync pass - just set up the new link tree and
                report its basename.
  --link-fail-repair (Obsolete; this is always done.)
                Proceed even if the linktree step fails, presumably due
                to hard link limit reached.
  --symlink-if-unchanged
                Just symlink the top level date if there are no changes.
                Requires a prepass \"rsync -n\" but saves a lot of hardlinks
                and time if the tree is often unchanged.
                This is the default.
  --no-symlink-if-unchanged
                Make a link tree even when there are no changes.
  --rsync-path rrsync Execute the command \"rrsync\" as the remote rsync.
                Passed to rsync.
  --symlink name Make a symlink named \"name\" pointing at the latest backup.
                 Default: $symlink
                 Supply the empty string for no symlink."

badopts=

# have "cp -ral"? otherwise rely on my linktree script
if [ "x`cp --help 2>&1 | grep ' -[ral][, ]' | wc -l | tr -d ' '`" = x3 ]
then
  mklinktree(){
    [ $# = 2 ] || { echo "Usage: mklinktree srcdir dstdir" >&2; return 2; }
    _mkl_src=$1
    _mkl_dst=$2
    case "$_mkl_dst" in
      /* | ./* ) ;; *) _mkl_dst=./$_mkl_dst ;;
    esac
    # make link tree, might fail if hard link limit reached for files
    $trace cp -ral "$1" "$2" && return 0
    # failed to make target? fail outright
    [ -d "$2/." ] || return 1
    # if we made the target, update from source
    $trace rsync -iaO "$1/." "$2/."
  }
else
  mklinktree(){ $trace linktree "$1" "$2"; }
fi
daycode(){ date '+%Y-%m-%d'; }
datecode(){ date '+%Y-%m-%d-%H:%M:%S'; }

### rsync capabilities at local end
##rsync_has_link_dest=
##rsv=`rsync --version | sed -n 's/^rsync *version \([1-9]\)\.\([0-9][0-9]*\)\.\([0-9][0-9]*\) .*/\1 \2 \3/p'`
##if [ -n "$rsv" ] && rsvn=`set -- $rsv; printf "%d%03d%03d\n" "$@"`
##then
##  [ "$rsvn" -ge 2005006 ] && rsync_has_link_dest=1
##  ## other end needs proto 29 also ## [ "$rsvn" -ge 2006004 ] && rsopts="$rsopts --fuzzy"
##fi

# =head1 OPTIONS
#
# =over 4
#
while [ $# -gt 0 ]
do
  case $1 in

    # =item --copy-times
    #
    # Copy file timestamps from the source tree to the
    # new link tree before the rsync pass.
    # This can be useful for trees such as media libraries which may be
    # touched to aid browing order, but dangerous for files where the content
    # might change without a change in file size.
    #
    --copy-times)
      copytimes=1
      ;;
    # =item --no-delete
    #
    # Suppress passing the B<--delete> or B<--delete-excluded> option to rsync.
    #
    --no-delete)
      rsdelete=
      ;;

    # =item --no-rsync
    #
    # Skip the rsync step; just create the new link tree.
    #
    --no-rsync)
      linkonly=1
      ;;

    # =item --link-fail-repair
    #
    # Proceed even if the linktree step fails, presumably due to
    # reaching the filesystem hard link limit. Does a repair rsync
    # from the previous to new backup before proceeding.
    #
    --link-fail-repair)
      echo "$cmd: $1: obsolete option; $cmd always tries to cope with hard link failure" >&2
      ;;
    # =item --symlink-if-unchanged
    #
    # Symlink the top level date if there are no changes to the tree.
    # This requires a prepass with "rsync -n" but saves time and
    # hardlinks if there are no changes.
    #
    --symlink-if-unchanged)
        symlink_unchanged=1
        ;;
    # =item --no-symlink-if-unchanged
    #
    # Do not symlink the top level date if there are no changes to the tree,
    # instead always make a hard link tree.
    #
    --no-symlink-if-unchanged)
        symlink_unchanged=
        ;;
    # =item --date datestring
    #
    # Specify datestring for this backup. The default is the current date or date-time.
    #
    --date)
        thisbackup=$2; shift
        ;;
    # =item --delete
    #
    # Passed to rsync.
    #
    --delete)
      rsdelete="$rsdelete --delete"
      ;;

    # =item --delete-excluded
    #
    # Passed to rsync. Also implies --delete.
    #
    --delete-excluded)
      rsdelete='--delete --delete-excluded'
      ;;

    # =item --no-hbfiles
    #
    # Do not honour the .hbfiles file in the backup directory.
    # 
    --no-hbfiles)
      usehbfiles=
      ;;

    # =item --no-hbinclude
    #
    # Do not honour the .hbinclude file in the backup directory.
    # 
    --no-hbinclude)
      usehbinclude=
      ;;

    # =item --rsync-path rrsync
    #
    # Passed to rsync.
    # Specifies the pathname to the remote rsync executable.
    #
    --rsync-path)
      rrsync=$2; shift ;;

    # =item --symlink name
    #
    # After the backup is done,
    # make a symbolic link named I<name> pointing at the latest backup directory.
    # This is useful so that other programs may trivially reference the latest
    # backup without having to figure out its name.
    # Eg: B<--symlink LATEST>.
    #
    --symlink)
      symlink=$2; shift ;;

    # =item -A, --acls
    #
    # Preserve ACLs. Passed to rsync.
    #
    -A|--acls)
      rsopts="$rsopts $1"
      ;;

    # =item -i, --itemize-changes
    #
    # Itemise changes. Passed to rsync, but histbackup strips a few noisy outputs.
    #
    -i|--itemize-changes)
      imode=1
      rsopts="$rsopts -i"
      ;;

    # -item -r, --reverse
    #
    # Reverse dates.
    #
    # =item -v, --verbose
    #
    -r|--reverse)
      reverse=1
      symlink=
      ;;

    # Turn on verbose mode.
    #
    -v|--verbose)
      verbose=1
      vecho=echo
      ;;

    # =item -x
    #
    # Trace execution of important commands (rsync, linktree etc).
    #
    -x)         trace=set-x ;;

    --)         shift; break ;;
    -*)         echo "$cmd: unrecognised option: $1" >&2
                badopts=1
                ;;
    *)          break ;;
  esac
  shift
done

#
# =back
#
# =head1 Post Option Arguments
#
# If the B<--no-rsync> option has been used, only the destination
# directory appears after the options. It will be initialised for use.
#
# If neither the source not destination appear
# it is expected that the destination is the current directory
# and that the source is specified by the .hbsource file in the current directory.
#
# Otherwise, the source and destination appear.
# These may be followed by I<otherbackupdirs>, the full paths of other directories like the one B<histbackup> is copying;
# these will be handed to rsync(1) as B<--link-dest> options.
# After the I<otherbackupdirs>, other rsync(1) options may be supplied;
# these will be passed to rsync.
#

if [ $linkonly ]
then
    if [ $# -lt 1 ]
    then
        echo "$cmd: missing parent" >&2
        badopts=1
    else
        dest=$1
        shift
    fi
else
    case "$*" in
      '' | -* )
        # neither source nor backupdir: use .hbsource and "."
        src=
        dest=.
        if [ ! -f .hbsource ]
        then
          echo "$cmd: missing .hbsource" >&2
          badopts=1
        else
          src=$(cat .hbsource)
          [ -n "$src" ] || { echo "$cmd: empty source from .hbsource" >&2; badopts=1; }
        fi
        ;;
      *)
        # expect source _and_ backupdir
        if [ $# -lt 2 ]
        then
            echo "$cmd: missing source or backupdir" >&2
            badopts=1
        else
            src=$1 dest=$2
            shift; shift
            # gather other backup dirs, turn into --link-dest= options
            obackup_count=0
            while [ $# -gt 0 ]
            do
              case "x$1" in
                x/*)
                  obackup=$1; shift
                  if [ "$obackup_count" -lt 20 ]
                  then
                    obackup_options="$obackup_options --link-dest=$obackup"
                    obackup_count=`expr $obackup_count + 1`
                  else
                    $vecho "$cmd: warning: ignoring --link-dest=$obackup due to arbitrary rsync limit of 20 such" >&2
                  fi
                  ;;
                *)break
                  ;;
              esac
            done
        fi
        ;;
    esac
fi

if [ $linkonly ] && [ $# -gt 0 ]
then
    echo "$cmd: --no-rsync: extra arguments after parent: $*" >&2
    badopts=1
fi

[ -d "$dest/." ] || { echo "$cmd: backup dir $dest: not a directory" >&2
                      badopts=1
                    }

# sanity check $src
case "$src" in
    '')         [ $linkonly ] || { echo "$cmd: empty src, rejected" >&2; badopts=1; }
                ;;
    *:*)        # remote - don't check
                ;;
    *)          [ -d "$src/."  ] || { echo "$cmd: source dir $src: not a directory" >&2
                                      badopts=1
                                    }
                ;;
esac

[ $badopts ] && { echo "$usage" >&2; exit 2; }

if [ $linkonly ]
then
  # protect against accidental misused of $src
  unset src
  exec 3>&1 1>&2
fi

if [ $imode ]
then
  # filter out mention of directories, symlink times and hard links
  filteroutput=`shqstr sed '/\/$/d; /^\.L\.\.[Tt]\.\.\.\.\.\. .* -> /d; /^\.d/d; /^hf/d'`
fi

# =head1 CUSTOMISATION FILES
#
# If the file I<backupdir>/F<.hfiles> is present
# the options B<"-r --files-from=>I<backupdir>/F<.hbinclude>
# will be added to the I<rsync> command invocation.
# In this way specific contents may be backed up.
# See rsync(1).
#
if [ $usehbfiles ]
then
  hbfiles=$dest/.hbfiles
  if [ -f "$hbfiles" ]
  then
    if [ ! -s "$hbfiles" ]
    then
      echo "$cmd: $hbfiles: expected non-empty file, aborting" >&2
      exit 1
    fi
    set -- ${1+"$@"} -r "--files-from=$hbfiles"
  fi
fi

#
# If the file I<backupdir>/F<.hbinclude> is present
# the option B<"--include-from=>I<backupdir>/F<.hbinclude>
# will be added to the I<rsync> command invocation.
# In this way the content to be backed up may be tuned.
# See rsync(1).
#
if [ $usehbinclude ]
then
  hbinclude=$dest/.hbinclude
  [ -s "$hbinclude" ] && set -- ${1+"$@"} "--include-from=$hbinclude"
fi

# determine name for this backup
if [ -n "$thisbackup" ]
then
  # check specified backup does not yet exist
  if [ -d "$dest/$thisbackup/." ]
  then
    echo "$cmd: $dest/$thisbackup already exist, aborting" >&2
    exit 1
  fi
else
  # allocate a backup name
  today=`daycode` || exit 1
  thisbackup=$today
  if [ -d "$dest/$thisbackup/." ]
  then
    now=`datecode` || exit 1
    thisbackup=$now
    if [ -d "$dest/$thisbackup/." ]
    then
      echo "$cmd: $dest/$today and $dest/$now already exist, aborting" >&2
      exit 1
    fi
  fi
fi

# locate to most recent backup younger than this one, if any
# if $reverse, locate oldest backup later than this one
lastbackup=$(
        cd "$dest" || exit 1
        (
          if [ $symlink_unchanged ] || [ $linkonly ]
          then
            # actual directory trees only
            ls -ld [0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]* 2>/dev/null \
            | sed -n 's/^d.* //p'
          else
            # directory or symlink
            ls -d [0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]* 2>/dev/null
          fi
          echo "$thisbackup"
        ) \
        | if [ $reverse ]; then sort -ur; else sort -u; fi \
        | sed "/^$thisbackup/,\$d" \
        | sed -n '$p'
)

dorsync()
{ [ $# -ge 2 ] || { echo "Usage: dorsync src dst [extra-rsync-opts...]" >&2; exit 2; }
  _drs_src=$1
  _drs_dst=$2
  shift; shift
  case "$_drs_dst" in
    /* | ./* | ../* ) ;; 
    *) _drs_dst=./$_drs_dst ;;
  esac
  set -- $trace rsync $rsopts -aH $rsdelete --rsync-path "$rrsync" ${1+"$@"} "$_drs_src/" "$_drs_dst/"
  [ $imode ] && set -- filter_fd 1 "$filteroutput" "$@"
  set -- $trace "$@"
  "$@"
}

ok=

dolink=1
if [ -n "$lastbackup" -a -d "$dest/$lastbackup/." ]
then
    if [ $symlink_unchanged ] && [ -z "$linkonly" ]
    then
      $vecho "checking for changes to $src from $lastbackup ..."
      changes=$( dorsync "$src" "$dest/$lastbackup" ${1+"$@"} -niO \
               | sed -n '/^..         /!{ p; q; }' \
               )
      if [ -z "$changes" ]
      then
        $vecho "no changes, symlinking last tree"
        ( set -ue
          cd "$dest" || exit 1
          $trace ln -s "$lastbackup" "$thisbackup"
          [ -z "$symlink" ] \
          || { rm -f "$symlink"; $trace ln -s "$thisbackup" "$symlink"; }
        )
        exit
      else
        $vecho "changes, proceeding with regular backup ..."
      fi
    fi
    $vecho "existing backup: linking $lastbackup to $thisbackup ..."
    if ( cd "$dest" || exit 1
         mklinktree "$lastbackup" "$thisbackup" \
         || {
           dolink=
           $trace rm -rf "$thisbackup"
           false
         }
       )
    then
      ok=1
      if [ $linkonly ]
      then  echo "$dest/$thisbackup" >&3
      else  $vecho "updating $thisbackup from $src ..."
            if [ $copytimes ]
            then
              $trace cpt "$src" "$dest/$thisbackup" || ok=
            fi
      fi
    fi
else
    if [ $linkonly ]
    then
        echo "$cmd: $dest: no subdirectory to link from" >&2
        ls -la "$dest" >&2
        exit 1
    else
        $vecho "fresh backup, just copying source ..."
        $trace mkdir "$dest/$thisbackup" && ok=1
    fi
fi

if [ $ok ] && [ -z "$linkonly" ]
then
  dorsync "$src" "$dest/$thisbackup" ${1+"$@"} $obackup_options
fi

if [ $ok ] && [ -n "$symlink" -a -d "$dest/$thisbackup/." ]
then
  if [ $dolink ]
  then
    ( cd "$dest" || exit 1
      rm -f "$symlink"
      $trace ln -s "$thisbackup" "$symlink"
    ) || ok=
  else
    echo "$cmd: new directory worse than old, symlink \"$symlink\" not made" >&2
    ok=
  fi
fi

[ $ok ]
exit

# =head1 AUTHOR
#
# Cameron Simpson <cs@cskk.id.au> 03apr2000
#
# =head1 SEE ALSO
#
# histbackup-prune(1cs), linktree(1cs), rsync(1), ssh(1), cp(1), cpdir(1cs), crontab(1), crontab(5)
#
