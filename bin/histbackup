#!/bin/sh -ue
#
# Freshmeat release: 2011-02-19
#
# =head1 NAME
#
# histbackup - backup a directory using an incremental technique
#
# =head1 SYNOPSIS
#
# histbackup [options...] [host:]source backupdir [otherbackupdirs...] [rsyncopts...]
#
# histbackup [options...] --no-rsync parent
#
# =head1 DESCRIPTION
#
# I<histbackup>
# makes incremental backups of a directory tree
# in a set of directories named by dates, or date-time if the date already exists.
# The new backup is prepopulated by hardlinks of each file from the previous backup
# and then updated with rsync(1).
# This arranges that the only new content of each new backup is fresh copies of the changed files.
# In this way each backup directory is a full copy of the source directory
# but the disc space cost is that of an incremental backup.
# Because it uses rsync,
# it is possible efficiently to backup remote directories in this manner.
# The companion script I<histbackup-prune> keeps the growth under control.
#
# =head1 SETUP AND USE
#
# Before deployment, decide who will own and do the backups.
# Do all the local (backup end) setup as that user.
# If you're not a sysadmin then that user is probably yourself.
#
# Generally, setup is as follows:
#
# =over 4
#
# =item Create the backup area.
#
# Decide where the backup data will be. Make an empty directory to hold it:
#
#	mkdir /path/to/backup/area
#
# =item Arrange access to the source data
#
# If the data to backup are local to this machine
# you merely need read access to it.
# If the data are remote
# you will need ssh(1) access to the remote host as a user with read access to the data there.
# Test it:
#
#	ssh user@remote ls -l /path/to/source/directory
#
# =item Perform a test backup
#
# Histbackup does the right thing when the backup area is empty
# so just:
#
#	histbackup -x user@remote:/path/to/source/directory /path/to/backup/area
#
# =item Schedule your backups
#
# If these backups are to happen regularly
# a crontab(5) entry should be made to do so.
# Use "C<crontab -e>" to make this.
# Example:
#
#	MAILTO=backup-admin@yoursite
#	PATH=$PATH:/opt/css/bin
#	0 * * * * histbackup -x user@remote:/path/to/source/directory /path/to/backup/area
#
# That will run a I<histbackup> every day at midnight,
# delivering the output of the run by email to B<backup-admin@yoursite>.
#
# Note that cron's environment is very spartan
# (it does not source C</etc/profile> or C<~/.profile>)
# and so you may need to arrange that the CSS package's environment is present.
# Also,
# because cron is a batch situation,
# your ssh access will almost certainly require a special purpose passphraseless key
# to access the remote host.
#
# =back
#

trace=
symlink=LATEST
src=
dest=
linkonly=
rrsync=rsync
usehbinclude=1
usehbfiles=1
rsopts=
rsdelete=--delete
verbose=
imode=
##[ -t 1 ] && verbose=1

cmd=`basename "$0"`
usage="Usage:
	$cmd [options...] [host:]source backupdir [otherbackupdirs...] [rsyncopts...]
	$cmd [options...] --no-rsync parent

        -i, --itemize-changes
                        Passed to rsync, result slightly filtered by histbackup.
	-v, --verbose	Verbose. Also passed to rsync.
	-x		Trace execution. Recite linktree and rsync invocations.
	--no-delete     Don't pass --delete to rsync.
        --delete        Pass --delete to rsync.
	--delete-excluded
			Pass --delete --delete-excluded to rsync.
        --no-hbfiles    Do not honour the .hbfiles file in the backup directory.
        --no-hbinclude  Do not honour the .hbinclude file in the backup directory.
	--no-rsync      Don't do the rsync pass - just set up the new link tree
			and report its basename.
	--rsync-path rrsync Execute the command \"rrsync\" as the remote rsync.
			Passed to rsync.
	--symlink name	Make a symlink named \"name\" pointing at the latest backup.
			Default: $symlink
			Use the empty string for no symlink."

badopts=

# have "cp -ral"? otherwise rely on my linktree script
if [ "x`cp --help 2>&1 | grep ' -[ral][, ]' | wc -l`" = x3 ]
then  mklinktree(){ $trace cp -ral "$1" "$2"; }
else  mklinktree(){ $trace linktree "$1" "$2"; }
fi
daycode(){ date '+%Y-%m-%d'; }
datecode(){ date '+%Y-%m-%d-%H:%M:%S'; }

### rsync capabilities at local end
##rsync_has_link_dest=
##rsv=`rsync --version | sed -n 's/^rsync *version \([1-9]\)\.\([0-9][0-9]*\)\.\([0-9][0-9]*\) .*/\1 \2 \3/p'`
##if [ -n "$rsv" ] && rsvn=`set -- $rsv; printf "%d%03d%03d\n" "$@"`
##then
##  [ "$rsvn" -ge 2005006 ] && rsync_has_link_dest=1
##  ## other end needs proto 29 also ## [ "$rsvn" -ge 2006004 ] && rsopts="$rsopts --fuzzy"
##fi

# =head1 OPTIONS
#
# =over 4
#
while [ $# -gt 0 ]
do
  case $1 in

    # =item --no-delete
    #
    # Suppress passing the B<--delete> or B<--delete-excluded> option to rsync.
    #
    --no-delete)
      rsdelete=
      ;;

    # =item --no-rsync
    #
    # Skip the rsync step; just create the new link tree.
    #
    --no-rsync)
      linkonly=1
      ;;

    # =item --delete
    #
    # Passed to rsync.
    #
    --delete)
      rsdelete="$rsdelete --delete"
      ;;

    # =item --delete-excluded
    #
    # Passed to rsync. Also implies --delete.
    #
    --delete-excluded)
      rsdelete='--delete --delete-excluded'
      ;;

    # =item --no-hbfiles
    #
    # Do not honour the .hbfiles file in the backup directory.
    # 
    --no-hbfiles)
      usehbfiles=
      ;;

    # =item --no-hbinclude
    #
    # Do not honour the .hbinclude file in the backup directory.
    # 
    --no-hbinclude)
      usehbinclude=
      ;;

    # =item --rsync-path rrsync
    #
    # Passed to rsync.
    # Specifies the pathname to the remote rsync executable.
    #
    --rsync-path)
      rrsync=$2; shift ;;

    # =item --symlink name
    #
    # After the backup is done,
    # make a symbolic link named I<name> pointing at the latest backup directory.
    # This is useful so that other programs may trivially reference the latest
    # backup without having to figure out its name.
    # Eg: B<--symlink LATEST>.
    #
    --symlink)
      symlink=$2; shift ;;

    # =item -i, --itemize-changes
    #
    # Itemise changes. Passed to rsync, but histbackup strips a few noisy outputs.
    #
    -i|--itemize-changes)
      imode=1
      rsopts="$rsopts -i"
      ;;

    # =item -v, --verbose
    #
    # Turn on verbose mode;
    # also passes B<-v> to rsync.
    #
    -v|--verbose)
      verbose=1
      ;;

    # =item -x
    #
    # Trace execution of important commands (rsync, linktree etc).
    #
    -x)		trace=set-x ;;

    --)		shift; break ;;
    -*)		echo "$cmd: unrecognised option: $1" >&2
		badopts=1
		;;
    *)		break ;;
  esac
  shift
done

[ $verbose ] && rsopts="$rsopts -v"

#
# =back
#
# =head1 Post Option Arguments
#
# If the B<--no-rsync> option has been used, only the destination
# directory appears after the options. It will be initialised for use.
#
# Otherwise, the source and destination appear.
# These may be followed by I<otherbackupdirs>, the full paths of other directories like the one B<histbackup> is copying;
# these will be handed to rsync(1) as B<--link-dest> options.
# After the I<otherbackupdirs>, other rsync(1) options may be supplied;
# these will be passed to rsync.
#

if [ $linkonly ]
then
    if [ $# -lt 1 ]
    then
	echo "$cmd: missing parent" >&2
	badopts=1
    else
	dest=$1
	shift
    fi
else
    if [ $# -lt 2 ]
    then
        echo "$cmd: missing source or backupdir" >&2
        badopts=1
    else
        src=$1 dest=$2
        shift; shift
        # gather other backup dirs, turn into --link-dest= options
        obackup_count=0
        while [ $# -gt 0 ]
        do
          case "x$1" in
            x/*)
              obackup=$1; shift
              if [ "$obackup_count" -lt 20 ]
              then
                set -- ${1+"$@"} "--link-dest=$obackup"
                obackup_count=`expr $obackup_count + 1`
              else
                echo "$cmd: warning: ignoring --link-dest=$obackup due to arbitrary rsync limit of 20 such" >&2
              fi
              ;;
            *)break
              ;;
          esac
        done
    fi
fi

if [ $linkonly ] && [ $# -gt 0 ]
then
    echo "$cmd: --no-rsync: extra arguments after parent: $*" >&2
    badopts=1
fi

[ -d "$dest/." ] || { echo "$cmd: backup dir $dest: not a directory" >&2
		      badopts=1
		    }
case "$src" in
    *:*)	# remote - don't check
		;;
    *)		[ -d "$src/."  ] || { echo "$cmd: source dir $src: not a directory" >&2
				      badopts=1
				    }
		;;
esac

[ $badopts ] && { echo "$usage" >&2; exit 2; }

if [ $linkonly ]
then
  exec 3>&1 1>&2
fi

if [ $verbose ]
then  echo=echo
else  echo=:
fi

if [ $imode ]
then
  # filter out mention of directories, symlink times and hard links
  filteroutput=`shqstr sed '/\/$/d; /^\.L\.\.[Tt]\.\.\.\.\.\. .* -> /d; /^\.d\.\.t\.\.\.\.\.\. /d; /^hf/d'`
fi

# =head1 CUSTOMISATION FILES
#
# If the file I<backupdir>/F<.hfiles> is present
# the options B<"-r --files-from=>I<backupdir>/F<.hbinclude>
# will be added to the I<rsync> command invocation.
# In this way specific contents may be backed up.
# See rsync(1).
#
if [ $usehbfiles ]
then
  hbfiles=$dest/.hbfiles
  if [ -f "$hbfiles" ]
  then
    if [ ! -s "$hbfiles" ]
    then
      echo "$cmd: $hbfiles: expected non-empty file, aborting" >&2
      exit 1
    fi
    set -- ${1+"$@"} -r "--files-from=$hbfiles"
  fi
fi

#
# If the file I<backupdir>/F<.hbinclude> is present
# the option B<"--include-from=>I<backupdir>/F<.hbinclude>
# will be added to the I<rsync> command invocation.
# In this way the content to be backed up may be tuned.
# See rsync(1).
#
if [ $usehbinclude ]
then
  hbinclude=$dest/.hbinclude
  [ -s "$hbinclude" ] && set -- ${1+"$@"} "--include-from=$hbinclude"
fi

# locate to most recent backup, if any
lastbackup=`cd "$dest" || exit 1; ls -dr [0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]* 2>/dev/null | sed 1q`

today=`daycode` || exit 1
thisbackup=$today
if [ -d "$dest/$thisbackup/." ]
then
    now=`datecode` || exit 1
    thisbackup=$now
    if [ -d "$dest/$thisbackup/." ]
    then
	echo "$cmd: $dest/$today and $dest/$now already exist, aborting" >&2
	exit 1
    fi
fi

ok=

dolink=1
if [ -n "$lastbackup" -a -d "$dest/$lastbackup/." ]
then
    $echo "existing backup: linking $lastbackup to $thisbackup ..."
    if ( cd "$dest" || exit 1
         mklinktree "$lastbackup" "$thisbackup" \
         || { dolink=; $trace rm -rf "$thisbackup"; false; }
       )
    then
      ok=1
      if [ $linkonly ]
      then  echo "$dest/$thisbackup" >&3
      else  $echo "updating $thisbackup from $src ..."
      fi
    fi
else
    if [ $linkonly ]
    then
        echo "$cmd: $dest: no subdirectory to link from" >&2
        ls -la "$dest" >&2
        exit 1
    else
        $echo "fresh backup, just copying source ..."
        $trace mkdir "$dest/$thisbackup" && ok=1
    fi
fi

if [ $ok ] && [ -z "$linkonly" ]
then
  set -- rsync $rsopts -aH $rsdelete --rsync-path "$rrsync" ${1+"$@"} "$src/" "$dest/$thisbackup/"
  if [ $imode ]
  then
    set -- filter_fd 1 "$filteroutput" "$@"
  fi
  $trace "$@" || ok=
fi

if [ $ok ] && [ -n "$symlink" -a -d "$dest/$thisbackup/." ]
then
  if [ $dolink ]
  then
    ( cd "$dest" || exit 1
      rm -f "$symlink"
      $trace ln -s "$thisbackup" "$symlink"
    ) || ok=
  else
    echo "$cmd: new directory worse than old, symlink \"$symlink\" not made" >&2
    ok=
  fi
fi

[ $ok ]
exit

# =head1 AUTHOR
#
# Cameron Simpson <cs@zip.com.au> 03apr2000
#
# =head1 SEE ALSO
#
# histbackup-prune(1cs), linktree(1cs), rsync(1), ssh(1), cp(1), cpdir(1cs)
#
