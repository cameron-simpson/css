#!/usr/bin/env python3
#
# Trivial convenience wrapper for the essential iview-python tool:
#  https://github.com/vadmium/python-iview
# Cameron Simpson <cs@zip.com.au>
#

from __future__ import print_function, absolute_import
import os
import sys
import re
from io import TextIOWrapper
from collections import namedtuple
import subprocess
from cs.logutils import setup_logging, error, warning, info, Pfx, X

USAGE = '''Usage:
  %s {download|dl} {file|/regexp/}...
                Download specified files.
  %s [ls] [/regexp/]
                Listing selected by regexp.
  %s programme  Return the full output of iview-cli --programme.'''

def run(argv):
  ''' Run a command. Trace invocation.
  '''
  pargv = ['+'] + argv
  print(*pargv, file=sys.stderr)
  return subprocess.call(argv)

def pipefrom(argv):
  ''' Pipe text from a command. Trace invocation.
  '''
  pargv = ['+'] + argv + ['|']
  print(*pargv, file=sys.stderr)
  P = subprocess.Popen(argv, stdin=subprocess.DEVNULL, stdout=subprocess.PIPE)
  P.stdout = TextIOWrapper(P.stdout)
  return P

_IViewInfo = namedtuple('IViewInfo', 'title episode url')
class IViewInfo(_IViewInfo):
  def print(self):
    print(self.title, self.episode, self.url, sep='\t')
  def match_re(self, R):
    if isinstance(R, str):
      R = re.compile(R, re.I)
    return R.search(self.title) or R.search(self.episode)
  def fetch(self, url, overwrite=False, make_mp4=False):
    '''
    '''
    with Pfx('fetch: %s', url):
      base, ext = os.path.splitext(os.path.basename(url))
      if ext != '.mp4':
        warning('expected .mp4 but ext=%r', ext)
      output_flv = base + '.flv'
      output_mp4 = base + ',mp4'
      with Pfx(output_flv):
        if not overwrite and os.path.exists(output_flv):
          warning('FLV output exists, skipping fetch')
          xit = 0
        else:
          argv = ['iview-cli', '-d']
          xit = run(argv)
          if xit != 0:
            error("nonzero exit from %r: %d", argv, xit)
            with Pfx('remove %r', output_flv):
              try:
                os.remove(output_flv)
              except OSError as e:
                if e.error != ENOENT:
                  error('%s', e)
              else:
                info('removed')
      if xit == 0:
        if make_mp4:
          with Pfx(output_mp4):
            if not overwrite and os.path.exists(output_mp4):
              warning('MP4 output exists, skipping: %r', output_mp4)
            else:
              argv = ['ffmpeg', '-i', output_flv, '-strict', '-2', '--', output_mp4]
              xit = run(argv)
              if xit != 0:
                error("nonzero exit from %r: %d", argv, xit)
                with Pfx('remove %r', output_mp4):
                  try:
                    os.remove(output_mp4)
                  except OSError as e:
                    if e.error != ENOENT:
                      error('%s', e)
                  else:
                    info('removed')
        return xit

def iview_info():
  ''' Generator yieldinfo IViewInfo objects.
  '''
  argv = ['iview-cli', '--programme']
  P = pipefrom(argv)
  title = None
  for lineno, line in enumerate(P.stdout, 1):
    with Pfx(lineno):
      if not line.endswith('\n'):
        raise ValueError("mssing newline")
      if line.startswith('\t'):
        episode, url = line.strip().split('\t', 1)
        with Pfx('url: %r', url):
          if url.startswith('('):
            url = url[1:]
          else:
            warning('expected URL to start with open bracket')
          if url.endswith(')'):
            url = url[:-1]
          else:
            warning('expected URL to end with closing bracket')
        if title is None:
          warning('episode before any title, discarded')
        else:
          yield IViewInfo(title, episode, url)
      else:
        title = line.strip()
        if title.endswith(':'):
          title = title[:-1]
        else:
          warning('title line not terminated by colon')
  xit = P.wait()
  if xit != 0:
    warning('nonzero exit %d from: %r', xit, argv)
  return

def iview_matches(matches):
  ''' Generator returning matching IViewInfo objects.
      `matches` is an iterable or regexp objects or regexp strings.
  '''
  Rs = []
  for regexp_s in matches:
    if isinstance(regexp_s, str):
      if regexp_s.startswith('/'):
        regexp_s = regexp_s[1:]
      if regexp_s.endswith('/'):
        regexp_s = regexp_s[:-1]
      try:
        R = re.compile(regexp_s, re.I)
      except Exception as e:
        warning('bad regexp, ignored: %s', e)
      else:
        Rs.append(R)
    else:
      Rs.append(regexp_s)
  if Rs:
    all_info = list(iview_info())
    for info in all_info:
      for R in Rs:
        if info.match_re(R):
          yield info
          break

def main(argv):
  cmd = argv.pop(0)
  usage = USAGE % (cmd, cmd, cmd)
  setup_logging(cmd)
  badopts = False
  if not argv:
    op = 'programme'
  elif argv[0].startswith('/'):
    op = 'ls'
  else:
    op = argv.pop(0)

  xit = 0
  if not badopts:
    with Pfx(op):
      if op == 'ls':
        if argv:
          matches = iview_matches(argv)
        else:
          matches = iview_info()
        for info in matches:
          info.print()
      elif op == 'programme':
        if argv:
          warning('extra arguments: %r', argv)
          badopts = True
        else:
          xit = os.system('iview-cli --programme')
      elif op == 'download' or op == 'dl':
        if argv:
          matches = iview_matches(argv)
        else:
          matches = iview_info()
        xit = 0
        for info in matches:
          with Pfx(info):
            if info.fetch(overwrite=False, make_mp4=True) != 0:
              error('fetch fails')
              xit = 1
      else:
        warning('unrecognised operator')
        badopts = True
  if badopts:
    print(usage, file=sys.stderr)
    xit = 2
  return xit

if __name__ == '__main__':
  sys.exit(main(sys.argv))
