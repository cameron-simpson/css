#!/usr/bin/env py26+
#
# Merge Apache access logs named on the command line.
#       - Cameron Simpson <cs@zip.com.au> 30aug2007
#

import sys
import os.path
import re
import time
from getopt import getopt, GetoptError
from datetime import datetime, timedelta
from cs.logutils import setup_logging, error, warning, cmd

def main(argv):
  argv = list(argv)
  cmd = os.path.basename(argv.pop(0))
  setup_logging(cmd)

  usage = '''Usage: %s [-M] [-O] /fixed-string/ logfiles
    -M    Accept multiple leading IP addresses on a line, emit the last.
    -O    Require strict ordering in the input log files.
''' % (cmd,)

  requireOrdering = False
  multiAddrs = False
  fgrep = None
  badopts = False

  try:
    opts, args = getopt(sys.argv[1:], 'MO')
  except GetoptError, e:
    error(e)
    badopts = True

  if not badopts:
    for opt, value in opts:
      if opt == '-M':
        multiAddrs = True
      elif opt == '-O':
        requireOrdering = True
      else:
        assert True, "%s: unhandled option: %s" % (cmd, opt)

    if args and len(args[0]) > 2 and args[0].startswith('/') and args[0].endswith('/'):
      fgrep = args[0][1:-1]
      args.pop(0)

    if len(args) < 1:
      error("missing logfiles")
      badopts = True

  if badopts:
    sys.stderr.write(usage)
    sys.exit(2)

  if multiAddrs:
    leadingAddrRe = re.compile(r'^[^ ,]*,( |%20)*')

  zones = {}
  defaultZone = None

  queues = [ LogFile(arg).lines() for arg in args ]
  lines  = [None] * len(queues)

  while len(queues) > 0:
    choice = None
    i = 0
    while i < len(queues):
      if lines[i] is None:
        try:
          nline, ndt = queues[i].next()
        except StopIteration:
          # EOF on file, remove file from queue
          del queues[i]
          del lines[i]
          continue
        lines[i] = (nline, ndt)

      if choice is None or lines[i][1] < lines[choice][1]:
        choice = i

      i += 1

    if choice is not None:
      print lines[choice][0]
      lines[choice] = None
    else:
      assert len(queues) == 0

  return 0

def aptime(logline):
  fields = logline.split(' ')
  if len(fields) < 5:
    ##warning("bad log line: %s", logline)
    return None

  global defaultZone
  dt = None
  tzinfo = None

  # try for desired "[DD/Mon/YYYY:HH:MM:SS +hhmm]" format
  humantime, tzinfo = fields[3], fields[4]
  if len(humantime) == 21 \
  and humantime.startswith('[') \
  and tzinfo.endswith(']'):
    try:
      dt = datetime.strptime(humantime, "[%d/%b/%Y:%H:%M:%S")
    except ValueError, e:
      dt = None
    if dt is None:
      tzinfo = None
    else:
      tzinfo = tzinfo[:-1]

  if dt is None:
    tzinfo = None
    # try for undesired "[DD/Mon/YYYY:HH:MM:SS]" format
    humantime = fields[3]
    if len(humantime) == 22 \
    and humantime.startswith('[') \
    and humantime.endswith(']'):
      try:
        dt = datetime.strptime(humantime, "[%d/%b/%Y:%H:%M:%S]")
      except ValueError, e:
        dt = None

  if dt is None:
    tzinfo = None
    # try for undesired "[DD/Mon/YYYY HH:MM:SS]" format
    humantime = " ".join(fields[3:5])
    if len(humantime) == 22 \
    and humantime.startswith('[') \
    and humantime.endswith(']'):
      try:
        dt = datetime.strptime(humantime, "[%d/%b/%Y %H:%M:%S]")
      except ValueError, e:
        dt = None

  if dt is None:
    warning("bad human time in log line: %s", logline)
    return None

  # use defaultZone if tzinfo is not set
  if tzinfo is None:
    if defaultZone is None:
      tm = time.localtime()
      if tm[8]:
        tzoff = time.altzone
      else:
        tzoff = time.timezone
      if tzoff < 0:
        zoneSign = '+'
        tzoff = -tzoff
      else:
        zoneSign = '-'
      defaultZone = "%s%02d%02d" % (zoneSign, int(tzoff/3600), int( int(tzoff/60) % 60))
    tzinfo = defaultZone

  global zones
  if tzinfo not in zones:
    if len(tzinfo) != 5 \
    or tzinfo[0] not in '+-' \
    or not tzinfo[1:5].isdigit():
      warning("bad timezone offset (%s) in log line: %s", tzinfo, logline)
      return None
    tzoff = (int(tzinfo[1:3])*60+int(tzinfo[3:5]))*60
    if tzinfo[0] == '+':
      tzoff = -tzoff
    zones[tzinfo] = timedelta(0,tzoff)

  tzoff = zones[tzinfo]
  dt += tzoff

  ##print "%s %s => %s" % (humantime, tzinfo, dt.isoformat())

  return dt

class LogFile:
  def __init__(self,filename):
    self.filename = filename
    if filename.endswith('.gz'):
      import gzip
      self.fp = gzip.open(filename)
    else:
      self.fp = open(filename)
    self.lineno = 0

  def lines(self):
    global cmd, requireOrdering, multiAddrs, leadingAddrRe, fgrep

    olddt = None
    for line in self.fp:
      self.lineno += 1
      if line[-1] != '\n':
        warning("%s, line %d: unexpected EOF: %s",
             self.filename, self.lineno, line)
        break

      if fgrep is not None and fgrep not in line:
        continue

      line = line[:-1]

      if multiAddrs:
        m = leadingAddrRe.match(line)
        while m is not None:
          line = line[m.end():]
          m = leadingAddrRe.match(line)

      dt = aptime(line)
      if dt is None:
        continue

      if requireOrdering:
        assert olddt is None or olddt <= dt, \
              "%s: %s, line %d: out of order timestamps: %s" \
              % (cmd, self.filename, self.lineno, line)
      olddt = dt

      yield line, dt

if __name__ == '__main__':
  sys.exit(main(sys.argv))
