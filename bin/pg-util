#!/bin/sh
#
# Generate and possibly apply GRANTs to PostgresQL roles.
#       - Cameron Simpson <cs@zip.com.au>
#

set -ue

cmd=`basename "$0"`
usage="Usage:
  -U pg-user    PostgreSQL database user. Default from \$USER or \`id -un\`.
  -x            Trace execution. With \"grant\", apply the GRANTs instead
                of reciting them.
  $cmd [-U pg-user] [-x]
        List database names.
  $cmd [-U pg-user] [-x] database [ls]
        List database relations (tables, etc).
  $cmd [-U pg-user] [-x] databases,... grant grants,... [on tables,...] to pg-role
        Recite or apply the specified GRANTs.
        The database name \"ALL\" will recurse over all databases except
        \"template0\".
        If \"on tables\" is omitted or tables is \"ALL\" then the GRANTs
        will be applied to all relations in the database.
"
pg_user=${USER:-`id -un`}
pg_database=
doit=
trace=
[ -t 2 ] && trace=set-x
xopt=

badopts=

while [ $# -gt 0 ]
do
  case "$1" in
    -U) pg_user=$2; shift ;;
    -x) xopt=$1 doit=1 trace=set-x ;;
    --) shift; break ;;
    -?*)echo "$cmd: unrecognised option: $1" >&2
        badopts=1
        ;;
    *)  break ;;
  esac
  shift
done

if [ $# -gt 0 ]
then
  pg_database=$1
  shift
  [ -n "$pg_database" ] || { echo "$cmd: database name may not be empty" >&2
                             badopts=1
                           }
fi

if [ -n "$pg_database" ]
then
  if [ $# = 0 ]
  then  op=ls
  else  op=$1; shift
  fi
  case "$op" in

    grant)
      if [ $# = 0 ]
      then
        echo "$cmd: $op: missing grants" >&2
        badopts=1
      else
        pg_grants=$1
        shift
      fi

      if [ $# -gt 0 ] && [ "x$1" = xon ]
      then
        pg_tables=$( echo "$2" | tr , ' ' )
        shift; shift
      else
        pg_tables=ALL
      fi

      if [ $# -gt 0 ] && [ "x$1" = xto ]
      then
        pg_role=$2
        shift; shift
      else
        echo "$cmd: $op: missing \"to pg-role\"" >&2
        badopts=1
      fi

      if [ $# -gt 0 ]
      then
        echo "$cmd: extra arguments: $*" >&2
        badopts=1
      fi
      ;;

    ls)
      if [ $# -gt 0 ]
      then
        echo "$cmd: $op: extra arguments: $*" >&2
        badopts=1
      fi
      ;;

    *)echo "$cmd: unrecognised op \"$op\"" >&2
      badopts=1
      ;;
  esac
fi

[ $badopts ] && { echo "$usage" >&2; exit 2; }

if [ -z "$pg_database" ]
then
  exec sed_fd 1 '/,/!d; s/,.*//' psql -U "$pg_user" -l -F, -A -t
fi

# call ourself with supplied post-option arguments
recurse()
{ $trace "$0" -U "$pg_user" $xopt -- ${1+"$@"}
}

case "$op" in

  grant)
    case "$pg_database" in
      ALL)
        if [ "x$pg_database" = xALL ]
        then
          for db in $( recurse | grep -v '^template0$' )
          do
            recurse "$db" grant "$pg_grants" on "$pg_tables" to "$pg_role"
          done
          exit $?
        fi
        ;;
      *,*)
        for db in `echo "$pg_database" | tr , ' '`
        do
          recurse "$db" grant "$pg_grants" on "$pg_tables" to "$pg_role"
        done
        exit $?
        ;;
    esac
    case "$pg_tables" in
      '' | ALL )
        pg_tables=$( recurse "$pg_database" ls )
        ;;
      *,* )
        pg_tables=$( echo "$pg_tables" | echo , ' ' )
        ;;
    esac
    for table in $pg_tables
    do
      echo "GRANT $pg_grants on TABLE $table to $pg_role;"
    done \
    | if [ $doit ]
      then
        $trace psql -U "$pg_user" -- "$pg_database"
      else
        cat
      fi
    ;;

  ls)
    filter_fd 1 "awk -F, '{ print \$2 }'" $trace psql -U "$pg_user" -At -F,  -c '\d' -- "$pg_database"
    ;;

  *)echo "$cmd: $op: unimplemented op" >&2
    exit 1
    ;;

esac
