#!/bin/sh
#
# Monitor an IP target using ping.
# Run commands on "up" and "down"; repeat until successful or state change.
#       - Cameron Simpson <cs@zip.com.au>
#

set -ue

up=
dotrace=
ping_count=5
sleep_time=30
pingopts=
setflag=
flagname=
upcmd=
downcmd=
quiet=

cmd=`basename "$0"`
usage="Usage: $cmd [-c count] [-F] [-q] [-s sleep] [-V rtable] [-x] target down-shcmd up-shcmd
  -c count  Probe ping count. Default: $ping_count.
  -F        Set or clear flag PING_{TARGET}.
  -f flagname Specify flag name.
  -q        Quiet.
  -s sleep  Sleep period between probes. Default: $sleep_time.
  -V rtable Passed to ping.
  -x        Trace execution."

badopts=

while [ $# -gt 0 ]
do
  case $1 in
    -0) up= ;;
    -1) up=1 ;;
    -F) setflag=1 ;;
    -f) setflag=1 flagname=$2; shift ;;
    -c) ping_count=$2; shift ;;
    -q) pingopts="$pingopts $1" quiet=1 ;;
    -s) sleep_time=$2; shift ;;
    -V) pingopts="$pingopts $1 $2"; shift ;;
    -x) dotrace=1 ;;
    --) shift; break ;;
    -?*)echo "$cmd: unrecognised option: $1" >&2
        badopts=1
        ;;
    *)  break ;;
  esac
  shift
done

if [ $# = 0 ]
then
  echo "$cmd: missing target" >&2
  badopts=1
else
  target=$1
  shift
  if [ $# = 0 ]
  then
    [ $setflag ] || \
    { echo "$cmd: missing down-shcmd" >&2
      badopts=1
    }
  else
    downcmd=$1
    shift
    if [ $# = 0 ]
    then
      echo "$cmd: missing up-shcmd" >&2
      badopts=1
    else
      upcmd=$1
      shift
      if [ $# -gt 0 ]
      then
        echo "$cmd: extra arguments after up-shcmd: $*" >&2
        badopts=1
      fi
    fi
  fi
fi

[ $badopts ] && { echo "$usage" >&2; exit 2; }

if [ $dotrace ]
then  trace=set-x setx='set -x'
else  trace= setx=
fi

if [ $setflag ]
then  : ${flagname:=PING_$( printf '%s\n' "$target" | tr '[.a-z]' '[_A-Z]' )}
fi

retry_upcmd=
retry_downcmd=

while :
do
  if ( [ -z "$quiet" ] || exec >/dev/null; $trace ping $pingopts -c "$ping_count" "$target"; )
  then
    # up!
    if [ $up ]
    then
      # already up - retry cmd if still pending
      if [ $retry_upcmd ]
      then { [ -z "$upcmd" ] || $trace sh -c "$setx; $upcmd"; } && retry_upcmd=
      fi
    else
      # newly up - note new state and run upcmd
      up=1
      [ $setflag ] && flag "$flagname" 1
      if [ -z "$upcmd" ] || $trace sh -c "$setx; $upcmd"
      then retry_upcmd=
      else retry_upcmd=1
      fi
    fi
  else
    # down:-(
    if [ $up ]
    then
      # newly down - note new state and run downcmd
      up=
      if [ -z "$downcmd" ] || $trace sh -c "$setx; $downcmd"
      then retry_downcmd=
      else retry_downcmd=1
      fi
    else
      # still down - retry cmd if still pending
      if [ $retry_downcmd ]
      then { [ -z "$downcmd" ] || $trace sh -c "$setx; $downcmd"; } && retry_downcmd=
      fi
    fi
  fi
  $trace sleep "$sleep_time"
done

