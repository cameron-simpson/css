#!/bin/sh -ue
#
# Run the named port forwards indefinitely.
#       - Cameron Simpson <cs@zip.com.au> 08jul2008
#

set -ue

: ${VARRUN:=$HOME/var/run}
: ${LOGDIR:=$HOME/var/log}
: ${PORTFWD_CONFIG:=$HOME/rc/ssh/portfwd}
: ${PORTFWD_SSH_CONFIG:=$HOME/rc/ssh/config-pf}
: ${USER:=`id -un`}

trace=set-x
trace_dated='set-x --date'
setx='set -x'   ## ${DEBUG:-:}${DEBUG:+set -x}
once=
sshcfg=$PORTFWD_SSH_CONFIG
fwdcfg=$PORTFWD_CONFIG
pfnames=
sshopts=-n

cmd=`basename "$0"`
usage="Usage:
  $cmd -d [targets...]
        Disable portfwd for targets, setting PORTFWD_TARGET_DISABLE.
        If no targets are specified, set PORTFWD_DISABLE.
  $cmd -e [targets...]
        Enable portfwd for targets, clearing PORTFWD_TARGET_DISABLE.
        If no targets are specified, clear PORTFWD_DISABLE.
  $cmd -D [targets...]
        Disable the override flag for targets, clearing PORTFWD_TARGET_OVERRIDE.
        If no targets are specified, set PORTFWD_OVERRIDE.
  $cmd -E [targets...]
        Enable the override for targets, clearing PORTFWD_TARGET_OVERRIDE.
        If no targets are specified, clear PORTFWD_OVERRIDE.
  $cmd [-1] [-F ssh_config] targets...
  -1    Once. Do not restart the tunnel if it dies.
  -F    Ssh configuration file with clause for target.
        Default from \$PORTFWD_SSH_CONFIG: $sshcfg
  -P pfname
        Require the named portfwd instance to have its CONNECTED
        flag true before starting our ssh. For a pfname of \"foo\"
        the flag \"PORTFWD_FOO_CONNECTED\" is tested. Multiple -P
        options may be supplied.
  -v    Verbose. Passed to ssh.

If a target starts with an upper case letter it is taken to be a group name,
and the targets are found by finding the first hostname in Host clauses with
the group name appended. Example: \"Host home ALL\""

setflag=
opts=
badopts=

while [ $# -gt 0 ]
do
  case $1 in
    -1) once=1 ;;
    -d) setflag=1 flagsuffix=DISABLE flagvalue=1 ;;
    -e) setflag=1 flagsuffix=DISABLE flagvalue=0 ;;
    -D) setflag=1 flagsuffix=OVERRIDE flagvalue=0 ;;
    -E) setflag=1 flagsuffix=OVERRIDE flagvalue=1 ;;
    -F) sshcfg=$2 opts="$opts $1 $2"; shift ;;
    -P) pfnames="$pfnames $2" opts="$opts $1 $2"; shift ;;
    -v) opts="$opts $1"; sshopts="$sshopts $1" ;;
    --) shift; break ;;
    -?*)echo "$cmd: unrecognised option: $1" >&2
        badopts=1
        ;;
    *)  break ;;
  esac
  shift
done

if [ -z "$setflag" ]
then
  if [ $# = 0 ]
  then
    echo "$cmd: no targets supplied" >&2
    sed -n 's/^ *[Hh][Oo][Ss][Tt][ 	][ 	]*/  /p' "$sshcfg" >&2
    echo >&2
    badopts=1
  fi
fi

# transmute group names into hosts
first=1
for target
do
  [ $first ] && { set --; first=; }
  case "$target" in
    [A-Z]*)
      onargs=$#
      set -- ${1+"$@"} \
             `sed -n 'y/	/ /
                      s/$/ /
                      s/^  *//
                      s/  */  /g
                      /^[Hh][Oo][Ss][Tt] .*'"$target"' /s/^[^ ]*  *\([^ A-Z][^ ]*\).*/\1/p' "$sshcfg"`
      if [ $# = $onargs ]
      then
        echo "$cmd: group \"$target\" does not match any Hosts in $sshcfg" >&2
        sed -n 's/^ *[Hh][Oo][Ss][Tt][ 	][ 	]*/  /p' "$sshcfg" >&2
        echo >&2
        badopts=1
      fi
      ;;
    *)set -- ${1+"$@"} "$target"
      ;;
  esac
done

[ $badopts ] && { echo "$usage" >&2; exit 2; }

uppername()
{ echo "$1" | tr -- '-[a-z]' '_[A-Z]'
}

if [ $setflag ]
then
  xit=0
  if [ $# = 0 ]
  then
    flag=PORTFWD_${flagsuffix}
    $trace flag -w "$flag" "$flagvalue" || xit=1
  else
    for target
    do
      utarget=$( uppername "$target" )
      flag=PORTFWD_${utarget}_${flagsuffix}
      $trace flag -w "$flag" "$flagvalue" || xit=1
    done
  fi
  exit $xit
fi

target=

abort() {
  $setx
  : PORTFWD TRAP "subpids=[$subpids]"
  if [ -n "$subpids" ]
  then
    killpids -W 5 -- $subpids
    [ -z "$target" ] || alert "EXITED: $target" </dev/null
  fi
  [ -n "$pidfile" ] && { >"$pidfile"; rm -f "$pidfile"; }
  [ -n "$flag_connected" ] && flag -w "$flag_connected" 0
  exit 1
}

pidfile=
subpids=
flag_connected=
trap 'abort' 1 2 3 15

# dispatch default route monitor if not already running
$trace monitor-default-route &

if [ $# -gt 1 ]
then
  # multiple targets - dispatch portfwd for each
  ( subpids=
    for target
    do
      pfx "$target" $trace "$0" $opts -- "$target" &
    done
    wait
  ) &
  subpids="$subpids $!"
  wait
  exit $?
fi

target=$1
shift

sshpidfile()
{ [ $# = 1 ] || { echo "$cmd: Usage: sshpidfile pfname" >&2; return 2; }
  echo "$VARRUN/portfwd-ssh.$1.pid"
}

utarget=$(uppername "$target")
flag_connected=PORTFWD_${utarget}_CONNECTED
pfflags=
pfpidfiles=
for pfname in $pfnames
do
  upfname=$( uppername "$pfname" )
  pfflags="$pfflags "PORTFWD_${upfname}_CONNECTED
  pfpidfiles="$pfpidfiles "`sshpidfile "$pfname"`
done

# construct svcd "ok to ssh" test command
test_shcmd=' flag -w PORTFWD_OVERRIDE && exit 0
             flag -w PORTFWD_DISABLE && exit 1'
for pfpidfile in $pfpidfiles
do
  test_shcmd="$test_shcmd
              ifpid -q '$pfpidfile' || exit 1"
done
for pfflag in $pfflags
do
  test_shcmd="$test_shcmd
              flag -w '$pfflag' || exit 1"
done
test_shcmd=" $test_shcmd
           "'ssh-add -l >/dev/null || exit 1
             flag -w ROUTE_DEFAULT || exit 1
             [ -x "$HOME/bin-local/do-portfwd" ] || exit 0
             "$HOME/bin-local/do-portfwd"
            '

# run main restart outer control via svcd
[ $once ] \
|| exec set-x \
          svcd -n "PORTFWD_$target" \
               -t "$test_shcmd" \
               -- "$0" -1 $opts -- "$target"

# getconfig target
#
# Set cfg_* vars from $fwdcfg[$target].
#
getconfig()
{ if [ -s "$fwdcfg" ]
  then
    _gc_wcv=`winclausevars "$fwdcfg" "$1" cfg`
    eval "$_gc_wcv"
  fi
}

cmd="$cmd $target"
pidfile=`sshpidfile "$target"`

# reload config on every pass
# default command tails var/log/alert-local and wait for the parent sshd to exit
cfg_command='pids=
             [ ! -s var/log/alert-local ] || { tail -F var/log/alert-local & pids="$pids $!"; }
             exec >&2
             while kill -0 "$PPID"
             do
               sleep 5
             done
             [ -z "$pids" ] || kill $pids
            '
cfg_outlog=alert-$target
cfg_errlog=portfwd-$target
getconfig "$target"
case $cfg_outlog in
  /*) ;; *) cfg_outlog=$LOGDIR/portfwd/$cfg_outlog ;;
esac
case $cfg_errlog in
  /*) ;; *) cfg_errlog=$LOGDIR/portfwd/$cfg_errlog ;;
esac

[ -n "$cfg_command" ] || sshopts="$sshopts -N"

if ifpid -q "$pidfile"
then
  echo "$cmd: $pidfile: process still running" >&2
  pfx "$cmd: $pidfile" cat "$pidfile" >&2
  exit 1
fi

# fetch some values to compute ControlPath
ssh_user=$( get-ssh-option -F "$sshcfg" -- "$target" User "$USER" )
ssh_port=$( get-ssh-option -F "$sshcfg" -- "$target" Port 22 )

ssh_ctrlpath='~/.sshctrl-%r@%n-pf:%p'
sh_ctrlpath=$HOME/.sshctrl-$ssh_user@$target-pf:$ssh_port

flag -w "$flag_connected" 0
alert "STARTING: $target"
rm -f -- "$sh_ctrlpath"
tag_fd 2 "$target" \
  $trace_dated \
    ssh $sshopts -F "$sshcfg" \
      -o 'PermitLocalCommand=yes' \
      -o "LocalCommand=flag -w '$flag_connected' 1; </dev/null alert CONNECTED: $target &" \
      -o "User=$ssh_user" \
      -o "Port=$ssh_port" \
      -o "ControlPath=$ssh_ctrlpath" \
      "$target" "$cfg_command" \
    >>"$cfg_outlog" 2>>"$cfg_errlog" </dev/null &
sshpid=$!
subpids="$subpids $sshpid"
echo "$sshpid" >"$pidfile"
wait
flag -w "$flag_connected" 0
>"$pidfile"; rm -f "$pidfile"
rm -f -- "$sh_ctrlpath"
alert "EXITED: $target"
