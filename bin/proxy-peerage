#!/usr/bin/python
#
# Emit configuration lines computed from my proxy peerage file.
#   - Cameron Simpson <cs@zip.com.au> 09sep2015
#

from __future__ import print_function
import sys
from collections import namedtuple
from re import escape
from cs.app.haproxy import quote as haquote
from cs.lex import get_uc_identifier
from cs.logutils import setup_logging, Pfx, X, error, warning, info

USAGE = '''Usage:
    %s haproxy backends frontend_name frontend_listen
    %s squid acls'''

Proxy = namedtuple('Proxy', 'name defn_lineno hostname port patterns')

def main(argv):
  cmd = argv.pop(0)
  setup_logging(cmd)
  usage = USAGE % (cmd, cmd)
  with Pfx(cmd):
    badopts = False
    if not argv:
      error('missing op')
      badopts = True
    else:
      op = argv.pop(0)
      with Pfx(op):
        if op == 'haproxy':
          if not argv:
            error('missing subop')
            badopts = True
          else:
            subop = argv.pop(0)
            with Pfx(subop):
              if subop == 'backends':
                if not argv:
                  error('missing frontend_name')
                  badopts = True
                else:
                  frontend_name = argv.pop(0)
                  if not argv:
                    error('missing frontend_listen')
                    badopts = True
                  else:
                    frontend_listen = argv.pop(0)
                    if argv:
                      error('extra arguments: %s', ' '.join(argv))
                      badopts = True
              else:
                error('unrecognised subop')
                badopts = True
        elif op == 'squid':
          if not argv:
            error('missing subop')
            badopts = True
          else:
            subop = argv.pop(0)
            with Pfx(subop):
              if subop == 'acls':
                if argv:
                  error('extra arguments: %s', ' '.join(argv))
                  badopts = True
              else:
                error('unrecognised subop')
                badopts = True
        else:
          error('unrecognised op')
          badopts = True
    if badopts:
      print(usage, file=sys.stderr)
      return 2
    xit = 0
    proxies = {'DIRECT': Proxy('DIRECT', 'builtin', None, None, [])}
    with Pfx('stdin'):
      if not load_proxies(sys.stdin, proxies):
        xit=1
    direct_proxy = proxies.pop('DIRECT')
    if op == 'haproxy':
      if subop == 'backends':
        return cmd_haproxy_backends(proxies, frontend_name, frontend_listen)
    error('unimplemented op/subop: %s/%s', op, subop)
    return 2

def cmd_haproxy_backends(proxies, frontend_name, frontend_listen):
  # invert the proxy pattern mapping and make a backend for each
  # map patterns to accepting proxies
  proxies_by_pattern = {}
  for proxy_name, proxy in proxies.items():
    for pattern in proxy.patterns:
      proxies_by_pattern.setdefault(pattern, set()).add(proxy_name)
  # map proxy groups to delivering patterns
  proxy_groups = {}
  for pattern, proxy_set in sorted(proxies_by_pattern.items()):
    proxy_groups.setdefault(tuple(sorted(proxy_set)), []).append(pattern)
  print('frontend', frontend_name, frontend_listen)
  for pattern, proxy_set in sorted(proxies_by_pattern.items()):
    # catch the wildcard last
    if pattern == '*':
      continue
    print('  use_backend %s if { %s }'
          % (haproxy_backend_name(proxy_set),
             haproxy_acl(pattern)))
  print('  default_backend', haproxy_backend_name(proxies_by_pattern['*']),)
  for proxy_names, patterns in sorted(proxy_groups.items()):
    print()
    print('backend', haproxy_backend_name(proxy_names))
    print('  option httpchk HEAD http://www.smh.com.au/ HTTP/1.0\\r\\n')
    for proxy_name in sorted(proxy_names):
      if proxy_name == 'DIRECT':
        continue
      proxy = proxies[proxy_name]
      print('  server %s_%d %s:%d check' % (proxy.hostname, proxy.port, proxy.hostname, proxy.port))
  return 0

def haproxy_backend_name(proxy_names):
  return '__'.join(sorted(proxy_names))

def haproxy_acl(pattern):
  with Pfx('acl_haproxy(%r)', pattern):
    if not pattern:
      raise ValueError('empty pattern')
    # * - wildcard pattern
    if pattern == '*':
      return None
    # *.dom.ain
    if pattern.startswith('*.') and len(pattern) > 2:
      return r'hdr_end(host) %s || hdr_reg(host) %s:[1-9][0-9]*$' \
             % (haquote(pattern[1:]), haquote(escape(pattern[1:])))
    # hostname or fqdn
    if pattern[0].isalpha():
      return r'hdr(host) %s || hdr_reg(host) ^%s:[1-9][0-9]*$' \
             % (haquote(pattern), haquote(escape(pattern)))
    # n.n.* - ip-prefix
    if pattern[0].isdigit() and '.' in pattern:
      words = pattern.split('.')
      if words[-1] == '*':
        words.pop(-1)
        if ( len(words) > 3
          or not(all(word.isdigit() and int(word) < 256 for word in words))
           ):
          raise ValueError('invalid ip-prefix')
        return 'hdr.beg(host) %s' % haquote('.'.join(words) + '.')
      if ( len(words) > 4
        or not(all(word.isdigit() and int(word) < 256 for word in words))
         ):
        raise ValueError('invalid IPv4')
      return r'hdr(host) %s || hdr_reg(host) ^%s:[1-9][0-9]*$' \
             (haquote(pattern), haquote(escape(pattern)))
    # .ext - file extension
    if pattern.startswith('.'):
      return r'path_end %s || path_reg %s' \
             % ( haquote(pattern), haquote(escape(pattern + '?')))
    raise ValueError('unrecognised pattern')

def load_proxies(fp, proxies):
  ''' Load proxy definitions from `fp`, update `proxies`. Return success.
  '''
  all_ok = True
  for lineno, line in enumerate(fp, 1):
    with Pfx(lineno):
      ok = True
      if not line.endswith('\n'):
        error('missing newline')
        all_ok = False
        continue
      line = line.strip()
      if not line or line.startswith('#'):
        # skip blank lines and comments
        continue
      label, offset = get_uc_identifier(line)
      if not label:
        error('expected leading uppercase identifier')
        all_ok = False
        continue
      if line[offset:].startswith('='):
        with Pfx(label):
          defn = line[offset+1:]
          if not defn:
            error('missing definition')
            all_ok = False
            continue
          words = defn.split()
          defn = words[0]
          if ':' in defn:
            proxy_host, proxy_port = defn.rsplit(':', 1)
            with Pfx('proxy_port: %r', proxy_port):
              try:
                proxy_port = int(proxy_port)
              except ValueError as e:
                error(e)
                ok = False
              else:
                if proxy_port < 1 or proxy_port >= 65536:
                  error('out of range')
                  ok = False
          else:
            proxy_host, proxy_port = defn, 3128
          if len(words) > 1:
            error('extra text after definition: %s', ' '.join(words[1:]))
            ok = False
          proxy = proxies.get(label)
          if proxy:
            error('repeated definition, first on line %d', proxy.defn_lineno)
            ok = False
          if ok:
            proxies[label] = Proxy(label, lineno, proxy_host, proxy_port, [])
          else:
            all_ok = False
      else:
        # gather comma separated labels
        labels = [label]
        while offset < len(line) and line[offset] == ',':
          label, offset = get_uc_identifier(line, offset + 1)
          if not label:
            error('expected uppercase identifier after comma, found: %r', line[offset:])
            all_ok = False
            continue
          labels.append(label)
        if offset == len(line) or not line[offset].isspace():
          error('expected patterns after labels, found: %r', line[offset:])
          all_ok = False
          continue
        words = line[offset:].split()
        patterns = []
        for word in words:
          patterns.extend(_ for _ in word.split(',') if _)
        for label in labels:
          with Pfx(label):
            proxy = proxies.get(label)
            if not proxy:
              error('unknown proxy')
              all_ok = False
            else:
              proxy.patterns.extend(patterns)
  return all_ok

if __name__ == '__main__':
  sys.exit(main(sys.argv))
