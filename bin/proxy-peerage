#!/usr/bin/python
#
# Emit configuration lines computed from my proxy peerage file.
#   - Cameron Simpson <cs@zip.com.au> 09sep2015
#

from __future__ import print_function
import sys
from collections import namedtuple
from re import escape
from cs.app.haproxy import quote as haquote
from cs.lex import get_uc_identifier
from cs.logutils import setup_logging, Pfx, X, error, warning, info

USAGE = '''Usage:
    %s haproxy backends frontend_name frontend_listen
    %s proxy.pac [-v]
    %s squid acls proxy_name'''

def main(argv):
  cmd = argv.pop(0)
  setup_logging(cmd)
  usage = USAGE % (cmd, cmd, cmd)
  with Pfx(cmd):
    badopts = False
    if not argv:
      error('missing op')
      badopts = True
    else:
      op = argv.pop(0)
      with Pfx(op):
        if op == 'haproxy':
          if not argv:
            error('missing subop')
            badopts = True
          else:
            subop = argv.pop(0)
            with Pfx(subop):
              if subop == 'backends':
                if not argv:
                  error('missing frontend_name')
                  badopts = True
                else:
                  frontend_name = argv.pop(0)
                  if not argv:
                    error('missing frontend_listen')
                    badopts = True
                  else:
                    frontend_listen = argv.pop(0)
                    if argv:
                      error('extra arguments: %s', ' '.join(argv))
                      badopts = True
              else:
                error('unrecognised subop')
                badopts = True
        elif op == 'proxy.pac':
          if argv and argv[0] == '-v':
            argv.pop(0)
            verbose = True
          else:
            verbose = False
          if argv:
            error('extra arguments: %s', ' '.join(argv))
            badopts = True
        elif op == 'squid':
          if not argv:
            error('missing subop')
            badopts = True
          else:
            subop = argv.pop(0)
            with Pfx(subop):
              if subop == 'acls':
                if not argv:
                  error('missing proxy_name')
                  badopts = True
                else:
                  proxy_name = argv.pop(0)
                  if argv:
                    error('extra arguments: %s', ' '.join(argv))
                    badopts = True
              else:
                error('unrecognised subop')
                badopts = True
        else:
          error('unrecognised op')
          badopts = True
    if badopts:
      print(usage, file=sys.stderr)
      return 2
    xit = 0
    config = Config({'DIRECT': Proxy('DIRECT', None, None, None)}, [])
    with Pfx('stdin'):
      config, ok = read_peerage(sys.stdin, config)
      if not ok:
        xit=1
    if op == 'haproxy':
      # haproxy does not handle DIRECT
      if subop == 'backends':
        return cmd_haproxy_backends(config, frontend_name, frontend_listen)
    if op == 'proxy.pac':
      return cmd_proxy_pac(config, verbose)
    if op == 'squid':
      if subop == 'acls':
        return cmd_squid_acls(proxies, proxy_name)
    error('unimplemented op/subop: %s/%s', op, subop)
    return 2

def read_peerage(fp, config=None):
  ''' Read proxy peer information from a file `fp`. Return Config and ok.
  '''
  if config is None:
    config = Config({}, [])
  if isinstance(fp, str):
    filename = fp
    with Pfx(filename):
      with open(filename) as fp:
        return read_peerage(fp, config)
  proxies = config.proxies
  rules = config.rules
  ok = True
  R = None
  for lineno, line in enumerate(fp, 1):
    with Pfx(lineno):
      if not line.endswith('\n'):
        error("missing trailing newline")
        ok = False
      line = line.strip()
      if not line:
        continue
      if line.startswith('#'):
        continue
      words = line.split()
      word0 = words.pop(0)
      proxy_name, offset = get_uc_identifier(word0)
      if not proxy_name:
        error("expected leading uppercase identifier")
        ok = False
        continue
      with Pfx(proxy_name):
        if word0.startswith('=', offset):
          # proxy definition PROXY=host[:port]
          defn = line[offset+1:]
          try:
            proxy_host, proxy_port = defn.rsplit(':', 1)
          except ValueError:
            proxy_host = defn
            proxy_port = 3128
          else:
            with Pfx("port %r", proxy_port):
              try:
                proxy_port = int(proxy_port)
              except ValueError as e:
                error(e)
                ok = False
                continue
          if words:
            error('extra text after definition: %s', ' '.join(words))
            ok = False
            continue
          if proxy_name in proxies:
            error('repeated definition, first on line %d', proxy.defn_lineno)
            ok = False
            continue
          proxies[proxy_name] = Proxy(proxy_name, lineno, proxy_host, proxy_port)
          continue
        # LABEL[,LABEL2...] pattern...
        proxy_names = []
        for proxy_name in word0.split(','):
          if proxy_name not in proxies:
            error("unknown proxy name %r", proxy_name)
            ok = False
            continue
          proxy_names.append(proxy_name)
        if R is None or proxy_names != R.proxy_names:
          # commence new rule
          R = Rule(proxy_names, lineno, [])
          rules.append(R)
        for pattern in words:
          P = Pattern(pattern, lineno)
          R.patterns.append(P)
  return config, ok

def cmd_haproxy_backends(proxies, frontend_name, frontend_listen):
  # define the frontend
  for ha_line_words in proxies.haproxy_define_frontend(frontend_name, frontend_listen):
    print(*ha_line_words)
  # define the backends
  for proxy_combo in sorted(proxies.proxy_combinations()):
    print()
    for ha_line_words in proxies.haproxy_define_backend(proxy_combo):
      print(*ha_line_words)

def haproxy_backend_name(proxy_names):
  return '__'.join(sorted(proxy_names))

def cmd_proxy_pac(config, verbose):
  for line in config.proxy_pac(verbose):
    print(line)

def cmd_squid_acls(proxies, proxy_name):
  proxy = proxies[proxy_name]
  patterns = proxy.patterns
  allow_as_fallback = False
  for n, pattern in enumerate(patterns):
    defn = pattern.definition
    if defn == '*':
      allow_as_fallback = True
    else:
      print('acl', '_'.join( (proxy_name, str(n)) ), pattern.squid_acl())
  if proxy_name == 'DIRECT':
    # force these ACLs to be direct
    for n, pattern in enumerate(patterns):
      acl_name = '_'.join( (proxy_name, str(n)) )
      print('always_direct allow', acl_name)
    print('always_direct deny all')
    # prevent these ACLs from being never_direct
    for n, pattern in enumerate(patterns):
      acl_name = '_'.join( (proxy_name, str(n)) )
      print('never_direct deny', acl_name)
    if not allow_as_fallback:
      # prevent other ACLs from going direct
      print('never_direct allow all')
  else:
    raise ValueError(proxy_name)

_Config = namedtuple("Config", "proxies rules")
class Config(_Config):

  def proxy_pac(self, verbose):
    yield 'function FindProxyForURL(url, host) {'
    for R in self.rules:
      jscond = '\n    || '.join( pattern.proxy_pac_condition(url_varname="url", host_varname="host")
                                 for pattern in R.patterns
                               )
      proxy_list = '; '.join( self.proxies[proxy_name].proxy_pac_hostport()
                              for proxy_name in R.proxy_names
                            )
      yield '  if (%s) {' % (jscond,)
      yield '    proxies = %r;' % (proxy_list,)
      if verbose:
        yield '    alert(url + " ==> " + proxies);'
      yield '    return proxies;'
      yield '  }'
    yield '}'

  def proxy_combinations(self):
    ''' Compute the set of unique proxy combinations.
    '''
    combos = set()
    for R in self.rules:
      combos.add(R.proxy_names_tuple())
    return combos

  def haproxy_define_frontend(self, frontend_name, frontend_listen):
    ''' Generator yielding words to define a frontend to choose amongst the proxies.
    '''
    yield 'frontend', frontend_name
    yield '  bind', frontend_listen
    default_proxies = set()
    for R in self.rules:
      proxy_names = R.proxy_names
      for pattern in R.patterns:
        defn = pattern.pattern
        # catch the wildcard last
        if defn == '*':
          default_proxies.update(proxy_names)
          continue
        yield ( '  use_backend %s if { %s }' \
                % (haproxy_backend_name(proxy_names), pattern.haproxy_acl()),
              )
    yield '  default_backend', haproxy_backend_name(default_proxies)

  def haproxy_define_backend(self, proxy_names):
    ''' Generator yielding words to define an haproxy backend.
    '''
    yield 'backend', haproxy_backend_name(proxy_names)
    yield '  option httpchk HEAD http://www.smh.com.au/ HTTP/1.0\\r\\n',
    for proxy_name in sorted(proxy_names):
      proxy = self.proxies[proxy_name]
      if proxy.host is not None:
        yield ( '  server %s_%d %s:%d check' \
                % (proxy.host, proxy.port, proxy.host, proxy.port),
              )

_Proxy = namedtuple("Proxy", "name lineno host port")
class Proxy(_Proxy):

  def proxy_pac_hostport(self):
    if self.host is None:
      return 'DIRECT'
    return "%s:%d" % (self.host, self.port)

_Rule = namedtuple('Rule', 'proxy_names lineno patterns')
class Rule(_Rule):

  def proxy_names_tuple(self):
    ''' Canonical proxy name tuple - sorted.
    '''
    return tuple(sorted(set(self.proxy_names)))

_Pattern = namedtuple('Pattern', 'pattern lineno')
class Pattern(_Pattern):

  def haproxy_acl(self):
    ''' Return the inline ACL condition for use in an haproxy backend selector.
    '''
    pattern = self.pattern
    with Pfx('haproxy_acl(%r)', self):
      if not pattern:
        raise ValueError('empty pattern')
      # * - wildcard pattern
      if pattern == '*':
        return None
      # *.dom.ain
      if pattern.startswith('*.') and len(pattern) > 2:
        return r'hdr_end(host) %s || hdr_reg(host) %s:[1-9][0-9]*$' \
               % (haquote(pattern[1:]), haquote(escape(pattern[1:])))
      # hostname or fqdn
      if pattern[0].isalpha():
        return r'hdr(host) %s || hdr_reg(host) ^%s:[1-9][0-9]*$' \
               % (haquote(pattern), haquote(escape(pattern)))
      # n.n.* - ip-prefix
      if pattern[0].isdigit() and '.' in pattern:
        words = pattern.split('.')
        if words[-1] == '*':
          words.pop(-1)
          if ( len(words) > 3
            or not(all(word.isdigit() and int(word) < 256 for word in words))
             ):
            raise ValueError('invalid ip-prefix')
          return 'hdr_beg(host) %s' % haquote('.'.join(words) + '.')
        if ( len(words) > 4
          or not(all(word.isdigit() and int(word) < 256 for word in words))
           ):
          raise ValueError('invalid IPv4')
        return r'hdr(host) %s || hdr_reg(host) ^%s:[1-9][0-9]*$' \
               (haquote(pattern), haquote(escape(pattern)))
      # .ext - file extension
      if pattern.startswith('.'):
        return r'path_end %s || path_reg %s' \
               % ( haquote(pattern), haquote(escape(pattern + '?')))
      if '*' in pattern:
        return r'hdr_reg(host) ^%s$' % (pattern.replace('.', '\\.').replace('*', '.*'),)
      raise ValueError('unrecognised pattern')

  def squid_acl(self):
    ''' Return the condition part of a squid ACL.
    '''
    pattern = self.definition
    with Pfx('squid_acl(%r)', pattern):
      if not pattern:
        raise ValueError('empty pattern')
      # * - wildcard pattern
      if pattern == '*':
        return 'true'
      # *.dom.ain
      if pattern.startswith('*.') and len(pattern) > 2:
        return 'dstdomain %s' % (pattern[1:],)
      # hostname or fqdn
      if pattern[0].isalpha():
        return 'dstdomain %s' % (pattern,)
      # n.n.* - ip-prefix
      if pattern[0].isdigit() and '.' in pattern:
        words = pattern.split('.')
        if words[-1] == '*':
          words.pop(-1)
          if ( len(words) > 3
            or not(all(word.isdigit() and int(word) < 256 for word in words))
             ):
            raise ValueError('invalid ip-prefix')
          padwords = ( words + ['0', '0', '0'] ) [:4]
          return 'dst -n %s/%d' % ('.'.join(padwords), 8*len(words))
        if ( len(words) > 4
          or not(all(word.isdigit() and int(word) < 256 for word in words))
           ):
          raise ValueError('invalid IPv4')
        return 'dstdomain %s' % (pattern,)
      # .ext - file extension
      if pattern.startswith('.'):
        return r'url_regex [.]%s(\?[^?]*)?$' % (escape(pattern),)
      raise ValueError('unrecognised pattern')

  def proxy_pac_condition(self, url_varname="url", host_varname="host"):
    ''' Return a javascript test to match this pattern.
    '''
    pattern = self.pattern
    if pattern == '*':
      return 'true'
    if '*' in pattern:
      return 'shExpMatch(%s, %r)' % (host_varname, pattern)
    return '%s == %r' % (host_varname, pattern)
    ##raise ValueError("no proxy_pac_condition for pattern %r" % (pattern,))

if __name__ == '__main__':
  sys.exit(main(sys.argv))
