#!/bin/sh
#
# Ensure we have an ssh agent, setting up a per-host ssh-agent in daemon mode if needed.
# Emit $SSH_AUTH_SOCK to stdout.
#
# I keep a shell function around to access the host agent:
#
#    gsa(){
#      SSH_AUTH_SOCK=`rig-ssh-agent -h ${1+"$@"}`; export SSH_AUTH_SOCK
#    }
#
# - Cameron Simpson <cs@cskk.id.au> 30jul2001
#

set -ue

: ${HOST:=`hostname -s`}

statefile=$HOME/var/run/ssh-agent-$HOST

cmd=$0
usage="Usage: $cmd [-f] [-h]
  -f    Force the creation of a new ssh-agent, updating the state file
        $statefile
  -h    Get the host specific agent, starting one if necessary.
        The default (no -f or -h) will use an existing agent if already set up."

force=
usehost=

badopts=
while [ $# -gt 0 ]
do
  case $1 in
    -f) force=1 ;;
    -h) usehost=1 ;;
    -?*)echo "$cmd: unrecognised option: $1" >&2; badopts=1 ;;
    *)  break ;;
  esac
  shift
done

[ $# = 0 ] || { echo "$cmd: extra arguments: $*" >&2; badopts=1; }

[ $badopts ] && { echo "$usage" >&2; exit 2; }

exec 3>&1 1>&2

if [ $usehost ]
then
  unset SSH_AUTH_SOCK
fi

need_agent=
if [ $force ]
then
  need_agent=1
else
  # test for existing ssh-agent
  { [ -n "${SSH_AUTH_SOCK:-}" ] && { ssh-add -l >/dev/null || [ $? = 1 ]; }; } \
  || { [ -s "$statefile" ] \
       && . "$statefile" \
       && { ssh-add -l >/dev/null 2>&1 || [ $? = 1 ]; }
     } \
  || need_agent=1
fi

if [ $need_agent ]
then
  # start per-host agent, update state file
  eval $(exec 3>&-; ssh-agent -s | tee "$statefile")
fi

exec 1>&3 3>&-
echo "$SSH_AUTH_SOCK"
