#!/bin/sh
#
# Replace text between two lines denoted by regexps.
#       - Cameron Simpson <cs@cskk.id.au> 20sep1995
#

set -ue

: ${TMPDIR:=/tmp}

cmd=`basename "$0"`
usage="Usage: $cmd -f from -t to {-i input -o output | target-file} [replacement-files...]
        -f from     Start line marked specified by regexp \"from\".
        -t to       Start line marked specified by regexp \"to\".
        -i input    Take input from \"input\"; \"-\" means standard input.
        -o output   Write result to \"output\"; \"-\" means standard output.
    target-file If no -i and no -o, use \"target-file\" for both.
    replacement-files
                Files providing the replacement text. \"-\" means standard input.
                Default: standard input."

input=
output=
from=
to=

badopts=

while [ $# -gt 0 ]
do
  case $1 in
    -f) from=$2; shift ;;
    -t) to=$2; shift ;;
    -i) input=$2; shift ;;
    -o) output=$2; shift ;;
    --) shift; break ;;
    -?*)echo "$cmd: unrecognised option: $1" >&2
        badopts=1 ;;
    *)  break ;;
  esac
  shift
done

# sanity check -i and -o; if both missing expect target-file next
if [ -n "$input" ]
then
  if [ -z "$output" ]
  then
    echo "$cmd: -i but no -o" >&2
    badopts=1
  fi
else
  if [ -n "$output" ]
  then
    echo "$cmd: -o but no -i" >&2
    badopts=1
  else
    if [ $# = 0 ]
    then
      echo "$cmd: no -i and no -o, missing target-file" >&2
      badopts=1
    else
      input=$1
      output=$1
      shift
    fi
  fi
fi

[ -n "$from" ] || { echo "$cmd: missing -f option" >&2; badopts=1; }
[ -n "$to" ] || { echo "$cmd: missing -t option" >&2; badopts=1; }
[ $# -gt 0 ] || set -- -

[ $badopts ] && { echo "$usage" >&2; exit 2; }

tmp=$TMPDIR/$cmd.$$
front=$tmp.a
back=$tmp.b

case $from in
    */*)        from=`printf '%s\n' "$from"|sed 's|/|\\\\/|g'` ;;
esac
case $to in
    */*)        to=`printf '%s\n' "$to"|sed 's|/|\\\\/|g'` ;;
esac

ok=1

trap 'rm -f "$front" "$back"' 0
trap 'rm -f "$front" "$back"; exit 1' 1 2 13 15

exec 3<&0       # save stdin

[ "x$input" = x- ] || exec <"$input"

# read the whole input file and grab the top and bottom bits
# this lets us use the same file for input and output
sed -n "1,/$from/w $front
        /$to/,\$w $back" || ok=

if [ $ok ]
then
    [ "x$output" = x- ] || exec >"$output"
    for file in "$front" "$@" "$back"
    do
      case $file in
        -)      cat <&3 ;;
        /*)     cat "$file" ;;
        *)      cat "./$file" ;;
      esac || ok=
    done
fi

[ $ok ] && exit 0
exit 1
