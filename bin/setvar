#!/usr/bin/env python
#
# Script to compute various environment parameters.
# Must be sourced, and defines the shell function setvar() as a consequence.
#	- Cameron Simpson, 18may1993
#
# Removed -n option.
# Recoded not to recurse to bypass Sys5 shell braindamage. - cameron, 30jul1993
# Recoded in Perl to bypass more shell braindamage.
# You don't source it anymore. - cameron, 07jan1994
# Added -f to force resetting variables. - cameron, 11jan1994
# Generalisation. - cameron, 02dec1998
# Python recode, syntax change, bootstrap. - cameron 23mar2008
#

from getopt import getopt, GetoptError
import os
import pwd
import sys
if sys.hexversion < 0x02060000: from sets import Set as set
import cs.misc
from cs.logutils import error, warn, info, debug, Pfx, setup_logging

setup_logging()

force=False     # don't reset existing variables
noAction=False  # don't exec command, recite var assignments on stdout
isset=set()
filevars={}
doingFilevar=set()
bootVal={}

def env(var,dflt=''):
  ''' Obtain the value of an environment variable.
      Returns None (or default) if the value cannot be determined.
  '''
  global force, isset
  if (not force or var in isset) and var in os.environ:
    return os.environ[var]
  if var not in doingFilevar:
    val=filevar(var)
  else:
    val=None
  if val is None:
    val=bootvar(var)
  if val is not None:
    setvar(var,val)
  if val is None:
    val=dflt
  return val

def bootvar(var):
  ''' Compute the value of a variety of variables from scratch.
  '''
  if var in bootVal:
    return bootVal[var]
  val=None
  if var == "CPU":
    cpu=os.uname()[4].lower()
    if cpu == 'power macintosh':
      cpu='ppc'
    val=cpu
  elif var == "HOME":
    val=pwd.getpwuid(os.geteuid())[5]
  elif var == "HOST":
    hostname=env("HOSTNAME")
    if '.' in hostname:
      host, hostdomain = hostname.split('.',1)
    else:
      host = hostname
    val=host
  elif var == "HOSTDOMAIN":
    hostname=env("HOSTNAME")
    host, hostdomain = hostname.split('.',1)
    val=hostdomain
  elif var == "HOSTNAME":
    ##import socket
    ##val=socket.getfqdn()
    val=os.popen('exec hostname').read()
    assert len(val) > 1 and val[-1] == '\n'
    val=val[:-1]
  elif var == "OS":
    opsys=os.uname()[0].lower()
    if opsys == "sunos":
      opsys='solaris'
    val=opsys
  elif var == "USER":
    val=pwd.getpwuid(os.geteuid())[0]
  elif var == "PYTHON_VV":
    val="%s.%s" % sys.version_info[:2]
  elif var == "VENDOR":
    vendor=None
    if os.path.isfile('/etc/fedora-release'):
      vendor='fedora'
    elif os.path.isfile('/etc/redhat-release'):
      vendor='redhat'
    elif os.path.isfile('/etc/gentoo-release'):
      vendor='gentoo'
    elif os.path.isfile('/etc/debian_version'):
      vendor='debian'
    else:
      opsys=env("OS")
      if opsys == "darwin":
        vendor="apple"
      elif opsys == "openbsd":
        vendor="openbsd"
      else:
        error("unknown VENDOR for OS=%s", opsys)
    val=vendor
  bootVal[var]=val
  return val

def filevarexts():
  hostname=env("HOSTNAME")
  if hostname is not None:
    yield "@%s" % hostname
  host=env("HOST")
  systemid=env("SYSTEMID")
  if host is not None:
    if systemid is not None:
      yield "@%s.%s" % (host, systemid)
    yield "@%s" % host
  if systemid is not None:
    yield "@%s" % systemid
  arch=env("ARCH")
  if arch is not None:
    yield ".%s" % arch
  osname=env("OS")
  if osname is not None:
    yield ".%s" % osname
  yield None

def filevar(var):
  if var in doingFilevar:
    warn("recursion in filevar(%s): %s", var, doingFilevar)
    return None
  doingFilevar.add(var)
  global filevars
  for ext in filevarexts():
    if ext is None:
      evar=var
    else:
      evar=var+ext
    if evar in filevars:
      doingFilevar.remove(var)
      return paramsubst(filevars[evar])

  doingFilevar.remove(var)
  return None

def setvar(var,val=None):
  if val is not None:
    if os.environ.get(var) != val:
      os.environ[var]=val
      isset.add(var)
    return val

  val=env(var)
  if val is None:
    warn("failed to setvar(%s)", var)
  else:
    os.environ[var]=val
    isset.add(var)
  return val

def paramsubst(val):
  newval=''
  while '$' in val:
    val0, val1 = val.split('$',1)
    newval+=val0
    pos=0
    while pos < len(val1) and (val1[pos].isalnum() or val1[pos] == '_'):
      pos+=1
    val=val1[pos:]
    subvar=val1[:pos]

    subval=env(subvar)
    if subval is None:
      warn("can't look up $%s", subvar)
    else:
      newval+=subval

  newval+=val

  return newval

def loadfilevars(path):
  global filevars
  for line in open(path):
    assert line[-1:] == '\n', "%s: unexpected EOF" % path
    if line[0] == '#' or line[0] == '\n':
      continue
    line=line[:-1]
    eqpos=line.find('=')
    assert eqpos > 0, "%s: bad line: %s" % (path, line)
    var, val = line.split('=', 1)
    filevars[var]=val

def listfilevars():
  global filevars
  V=set()
  for v in filevars.keys():
    if '.' in v:
      v, v2 = v.split('.',1)
    if '@' in v:
      v, v2 = v.split('@',1)
    V.add(v)
  return V

def doCommand(argv):
  op=argv[0]
  argv=argv[1:]
  if op == "addprefix":
    for arg in argv:
      arg=paramsubst(arg)
      if not os.path.isabs(arg):
        arg=os.path.join('/opt',arg)
      setvar('PATH',"%s:%s/bin:%s/sbin" % (env('PATH',''), arg, arg))
      setvar('MANPATH',"%s:%s/man:%s/share/man" % (env('MANPATH',''), arg, arg))
      setvar('PERL5LIB',"%s:%s/lib/perl5:%s/lib/perl5/vendor_perl" % (env('PERL5LIB',''), arg, arg))
      ##setvar('PYTHONPATH',"%s:%s/lib/python%s/site-packages:%s/lib/python%s" % (env('PYTHONPATH',''), arg, env('PYTHON_VV'), arg, env('PYTHON_VV')))
  elif op == "insprefix":
    argv.reverse()
    for arg in argv:
      arg=paramsubst(arg)
      if not os.path.isabs(arg):
        arg=os.path.join('/opt',arg)
      setvar('PATH',"%s/bin:%s/sbin:%s" % (arg, arg, env('PATH')))
      setvar('MANPATH',"%s/man:%s/share/man:%s" % (arg, arg, env('MANPATH')))
      setvar('PERL5LIB',"%s/lib/perl5:%s/lib/perl5/vendor_perl:%s" % (arg, arg, env('PERL5LIB')))
      ##setvar('PYTHONPATH',"%s/lib/python%s:%s" % (arg, env('PYTHON_VV'), env('PYTHONPATH')))
  elif op == "python":
    exec " ".join(argv)
  elif op == "use":
    global envpath
    for arg in argv:
      if os.path.isabs(arg):
        doFile(arg)
      else:
        for path in envpath:
          fpath=os.path.join(path,arg)
          if os.path.isfile(fpath):
            doFile(fpath)
            break
  elif op == "var":
    for arg in argv:
      if arg == "*":
        for var in listfilevars():
          setvar(var)
      else:
        for var in paramsubst(arg).split(' '):
          setvar(var)
  else:
    error("unsupported operation: %s", op)

def doFile(path):
  with Pfx(path):
    oline=""
    for line in open(path):
      if line[-1:] != '\n':
        error("unexpected EOF")
        break
      line=line[:-1]
      if len(line) == 0 or line[-1] != '\\':
        oline+=line
        oline=oline.strip()
        if len(oline) > 0 and oline[0] != '#':
          eqpos=oline.find('=')
          if eqpos > 0 \
          and oline[0].isalpha() \
          and sum([ c.isalnum() or c == '_' for c in oline[1:eqpos] ]) == eqpos-1:        # all() not available in 2.3
            setvar(oline[:eqpos], paramsubst(oline[eqpos+1:]))
          else:
            doCommand(oline.split())
        oline=""
      else:
        oline+=" "+line[:-2]
    if len(oline) > 0:
      error("unterminated slosh line")

def cleanpath(*vars):
  for var in vars:
    keep=[]
    if var not in os.environ:
      error("warning: cleanpath(%s): no such envvar", var)
      continue
    oval=os.environ[var]
    for path in oval.split(':'):
      if len(path) > 0 and os.path.exists(path):
        if path not in keep:
          keep.append(path)
    nval=":".join(keep)
    if oval != nval:
      os.environ[var]=nval

opts, args = getopt(sys.argv[1:], 'fn')
for opt, val in opts:
  if opt == '-f':
    force=True
  elif opt == '-n':
    noAction=True
  else:
    error("unimplemented option: %s", opt)
    sys.exit(2)

envpath=os.environ.get('ENVPATH')
if envpath is None:
  envpath='%s/.setvar:/etc/setvar' % env('HOME')
envpath=envpath.split(':')
renvpath=envpath[:]
renvpath.reverse()

for path in renvpath:
  varfile=os.path.join(path,'var')
  if os.path.isfile(varfile):
    loadfilevars(varfile)

setvar("HOSTNAME")
setvar("SYSTEMID")

if len(args) == 0:
  args=('var *',)
for arg in args:
  if ' ' in arg:
    doCommand(arg.split())
  else:
    setvar(arg)

cleanpath('PATH','MANPATH','PYTHONPATH','PERL5LIB')

if noAction:
  import cs.sh
  vars=list(isset)
  vars.sort()
  for var in vars:
    print "%s=%s; export %s;" % (var, cs.sh.quotestr(os.environ[var]), var)
else:
  error("action mode not supported")
  sys.exit(1)
