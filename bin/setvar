#!/usr/bin/env py25+
#
# Script to compute various environment parameters.
# Must be sourced, and defines the shell function setvar() as a consequence.
#	- Cameron Simpson, 18may1993
#
# Removed -n option.
# Recoded not to recurse to bypass Sys5 shell braindamage. - cameron, 30jul1993
# Recoded in Perl to bypass more shell braindamage.
# You don't source it anymore. - cameron, 07jan1994
# Added -f to force resetting variables. - cameron, 11jan1994
# Generalisation. - cameron, 02dec1998
# Python recode, syntax change, bootstrap. - cameron 23mar2008
#

from __future__ import with_statement
from getopt import getopt, GetoptError
import os
import os.path
import pwd
import sys
if sys.hexversion < 0x02060000: from sets import Set as set
from cs.env import envsub
from cs.lex import get_identifier
import cs.misc
from cs.logutils import error, warning, info, debug, Pfx, setup_logging

def main(argv):
  cmd = os.path.basename(argv[0])
  setup_logging(cmd)

  force=False     # don't reset existing variables
  noAction=True  # don't exec command, recite var assignments on stdout

  opts, args = getopt(argv[1:], 'fn')
  for opt, val in opts:
    if opt == '-f':
      force=True
    else:
      error("unimplemented option: %s", opt)
      sys.exit(2)

  # load up the environ mapping
  environ = EnvMapping(os.environ)
  vars = set()

  home = environ['HOME']
  envpath = setvar('ENVPATH',
                   '%s/.setvar-local:%s/.setvar:/etc/setvar'
                   % (home, home),
                   environ,
                   vars)
  for envdir in reversed(envpath.split(':')):
    varfile = os.path.join(envdir, 'var')
    if os.path.isfile(varfile):
      for var, value in filevars(varfile):
        environ[var] = value

  if len(args) == 0:
    args=('var *',)

  for arg in args:
    if ' ' in arg:
      doCommand(arg.split(), environ, vars)
    else:
      setvar(arg, None, environ, vars)

  for var in 'PATH', 'MANPATH', 'PYTHONPATH', 'PERL5LIB':
    try:
      new_value = cleanpath(environ[var])
    except ValueError:
      pass
    else:
      environ[var] = new_value

  import cs.sh
  for var in sorted(vars):
    print "%s=%s; export %s;" % (var, cs.sh.quotestr(environ[var]), var)

def filevars(path):
  ''' Return a list of (var, value) tuples from the specific file.
  '''
  items = []
  with Pfx(path):
    with open(path) as fp:
      lineno = 0
      for line in fp:
        lineno += 1
        with Pfx(lineno):
          if not line.endswith('\n'):
            raise ValueError('unexpected EOF: missing trailing newline')
          line = line.strip()
          if not line or line.startswith('#'):
            continue
          try:
            var, value = line.split('=', 1)
          except ValueError:
            raise ValueError('missing "="')
          items.append( (var, value) )
  return items

def setvar(var, value, environ, vars):
  if value is None:
    try:
      value = environ[var]
    except KeyError:
      error("no definition for $%s, using empty value" % (var,))
      value = ''
  environ[var] = value
  vars.add(var)
  return value

def doCommand(argv, environ, vars):
  op = argv[0]
  argv = argv[1:]
  if op == 'addprefix':
    for arg in argv:
      arg = envsub(arg, environ=environ, bare='$', default='')
      if not os.path.isabs(arg):
        arg=os.path.join('/opt',arg)
      setvar('PATH',
             '%s:%s/bin:%s/sbin' % (environ['PATH'], arg, arg),
             environ,
             vars)
      setvar('MANPATH',
             '%s:%s/man:%s/share/man' % (environ['MANPATH'], arg, arg),
             environ,
             vars)
      setvar('PERL5LIB',
             '%s:%s/lib/perl5:%s/lib/perl5/vendor_perl'
             % (environ['PERL5LIB'], arg, arg),
             environ,
             vars)
  elif op == 'insprefix':
    for arg in reversed(argv):
      arg = envsub(arg, environ=environ, bare='$', default='')
      if not os.path.isabs(arg):
        arg=os.path.join('/opt',arg)
      setvar('PATH',
             '%s/bin:%s/sbin:%s' % (arg, arg, environ['PATH']),
             environ,
             vars)
      setvar('MANPATH',
             '%s/man:%s/share/man:%s' % (arg, arg, environ['MANPATH']),
             environ,
             vars)
      setvar('PERL5LIB',
             '%s/lib/perl5:%s/lib/perl5/vendor_perl:%s'
             % (arg, arg, environ['PERL5LIB']),
             environ,
             vars)
  elif op == 'python':
    eval(' '.join(argv))
  elif op == 'use':
    for arg in argv:
      if os.path.isabs(arg):
        doFile(arg, environ, vars)
      else:
        for path in environ['ENVPATH'].split(':'):
          fpath = os.path.join(path, arg)
          if os.path.isfile(fpath):
            doFile(fpath, environ, vars)
            break
  elif op == 'var':
    for arg in argv:
      if arg == '*':
        varlist = sorted(set( get_identifier(v)[0] for v in environ.keys() ))
      else:
        varlist = envsub(arg, environ=environ, bare='$', default='').split(' ')
      for var in varlist:
        try:
          setvar(var, None, environ, vars)
        except ValueError, e:
          error(str(e))
  else:
    error("unsupported operation: %s", op)

def doFile(path, environ, vars):
  with Pfx(path):
    oline=""
    lineno = 0
    for line in open(path):
      lineno += 1
      if not line.endswith('\n'):
        error("unexpected EOF - missing newline")
        break
      line = line.strip()
      if not line or line.startswith('#'):
        continue
      word1, offset = get_identifier(line)
      if not word1:
        error("no var= or command")
        continue
      if offset < len(line) and line[offset] == '=':
        setvar(word1,
               envsub(line[offset+1:], environ, bare='$', default=''),
               environ,
               vars)
      else:
        doCommand(line.split(), environ, vars)

def cleanpath(path, sep=':'):
  keep = []
  for subpath in path.split(sep):
    if subpath not in keep and os.path.exists(subpath):
      keep.append(subpath)
  return sep.join(keep)

class EnvMapping(dict):

  def __getitem__(self, var):
    for ext in self._exts():
      var_ext = var + ext
      try:
        value = dict.__getitem__(self, var_ext)
      except KeyError:
        continue
      return envsub(value, environ=self, bare='$', default='')
    try:
      value = dict.__getitem__(self, var)
    except KeyError:
      try:
        value = self._boot(var)
      except KeyError:
        raise
      else:
        # save boot value for reuse
        self[var] = value
        return value
    else:
      return envsub(value, environ=self, bare='$', default='')

  def _boot(self, var):
    ''' Compute the value of a variety of variables from scratch.
    '''
    if var == "CPU":
      cpu = os.uname()[4].lower()
      if cpu == 'power macintosh':
        cpu = 'ppc'
      return cpu
    if var == "HOME":
      return pwd.getpwuid(os.geteuid())[5]
    if var == "HOST":
      hostname = self['HOSTNAME']
      if '.' in hostname:
        host, hostdomain = hostname.split('.', 1)
      else:
        host = hostname
      return host
    if var == "HOSTDOMAIN":
      hostname = self['HOSTNAME']
      if '.' in hostname:
        host, hostdomain = hostname.split('.',1)
        return hostdomain
      raise KeyError
    if var == "HOSTNAME":
      val=os.popen('exec hostname').read()
      if val.endswith('\n'):
        return val[:-1]
      raise KeyError
    if var == "OS":
      opsys = os.uname()[0].lower()
      if opsys == "sunos":
        opsys = 'solaris'
      return opsys
    if var == "USER":
      return pwd.getpwuid(os.geteuid())[0]
    if var == "PYTHON_VV":
      return "%s.%s" % sys.version_info[:2]
    if var == "VENDOR":
      if os.path.isfile('/etc/fedora-release'):
        return 'fedora'
      if os.path.isfile('/etc/redhat-release'):
        return 'redhat'
      if os.path.isfile('/etc/gentoo-release'):
        return 'gentoo'
      if os.path.isfile('/etc/debian_version'):
        return 'debian'
      if os.path.isfile('/etc/system-release'):
        return open('/etc/system-release').read().split()[0]
      opsys = self['OS']
      if opsys == "darwin":
        return "apple"
      if opsys == "openbsd":
        return "openbsd"
      if opsys == "freebsd":
        return "freebsd"
      raise KeyError('unknown VENDOR for OS=%s' % (opsys,))
    raise KeyError

  def _exts(self):
    ''' Generator yielding
          @$HOSTNAME
          @$HOST.$SYSTEMID
          @$HOST
          .$ARCH
          .$OS
        if available for use in choosing variable values.
    '''
    v_arch = dict.get(self, 'ARCH')
    v_hostname = dict.get(self, 'HOSTNAME')
    v_host = dict.get(self, 'HOST')
    v_os = dict.get(self, 'OS')
    v_systemid = dict.get(self, 'SYSTEMID')
    if v_hostname:
      yield '@' + v_hostname
    if v_host:
      if v_systemid:
        yield '@' + v_host + '.' + v_systemid
      yield '@' + v_host
    if v_arch:
      yield '.' + v_arch
    if v_os:
      yield '.' + v_os

sys.exit(main(sys.argv))
