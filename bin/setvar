#!/usr/bin/env py25+
#
# Script to compute various environment parameters.
# Must be sourced, and defines the shell function setvar() as a consequence.
#	- Cameron Simpson, 18may1993
#
# Removed -n option.
# Recoded not to recurse to bypass Sys5 shell braindamage. - cameron, 30jul1993
# Recoded in Perl to bypass more shell braindamage.
# You don't source it anymore. - cameron, 07jan1994
# Added -f to force resetting variables. - cameron, 11jan1994
# Generalisation. - cameron, 02dec1998
# Python recode, syntax change, bootstrap. - cameron 23mar2008
#

from __future__ import with_statement
from getopt import getopt, GetoptError
import os
import os.path
import pwd
import sys
if sys.hexversion < 0x02060000: from sets import Set as set
import cs.misc
from cs.logutils import error, warn, info, debug, Pfx, setup_logging

def main(argv):
  cmd = os.path.basename(argv[0])
  setup_logging(cmd)

  force=False     # don't reset existing variables
  noAction=False  # don't exec command, recite var assignments on stdout
  isset=set()
  var_values = {}
  doingFilevar=set()
  bootVal={}

  opts, args = getopt(argv[1:], 'fn')
  for opt, val in opts:
    if opt == '-f':
      force=True
    elif opt == '-n':
      noAction=True
    else:
      error("unimplemented option: %s", opt)
      sys.exit(2)

  home = env('HOME', force=force)
  for envdir in reversed(
                  os.environ
                    .get('ENVPATH',
                         '%s/.setvar-local:%s/.setvar:/etc/setvar'
                         % (home,home,))
                    .split(':')):
    varfile = os.path.join(envdir, 'var')
    if os.path.isfile(varfile):
      for var, value in filevars(varfile):
        var_values[var] = value

  setvar("HOSTNAME")
  setvar("SYSTEMID")

  if len(args) == 0:
    args=('var *',)
  for arg in args:
    if ' ' in arg:
      doCommand(arg.split())
    else:
      setvar(arg)

  for var in 'PATH', 'MANPATH', 'PYTHONPATH', 'PERL5LIB':
    environ[var] = cleanpath(environ[var])

  if noAction:
    import cs.sh
    vars=list(isset)
    vars.sort()
    for var in vars:
      print "%s=%s; export %s;" % (var, cs.sh.quotestr(os.environ[var]), var)
  else:
    error("action mode not supported")
    sys.exit(1)

def env(var, force=False):
  ''' Obtain the value of an environment variable.
      Returns None (or default) if the value cannot be determined.
  '''
  if (not force or var in isset) and var in os.environ:
    return os.environ[var]
  if var not in doingFilevar:
    val=filevar(var)
  else:
    val=None
  if val is None:
    val=bootvar(var)
  if val is not None:
    setvar(var,val)
  if val is None:
    val=''
  return val

def bootvar(var, force=False):
  ''' Compute the value of a variety of variables from scratch.
  '''
  if var in bootVal:
    return bootVal[var]
  val=None
  if var == "CPU":
    cpu=os.uname()[4].lower()
    if cpu == 'power macintosh':
      cpu='ppc'
    val=cpu
  elif var == "HOME":
    val=pwd.getpwuid(os.geteuid())[5]
  elif var == "HOST":
    hostname=env("HOSTNAME", force=force)
    if '.' in hostname:
      host, hostdomain = hostname.split('.',1)
    else:
      host = hostname
    val=host
  elif var == "HOSTDOMAIN":
    hostname=env("HOSTNAME", force=force)
    host, hostdomain = hostname.split('.',1)
    val=hostdomain
  elif var == "HOSTNAME":
    ##import socket
    ##val=socket.getfqdn()
    val=os.popen('exec hostname').read()
    assert len(val) > 1 and val[-1] == '\n'
    val=val[:-1]
  elif var == "OS":
    opsys=os.uname()[0].lower()
    if opsys == "sunos":
      opsys='solaris'
    val=opsys
  elif var == "USER":
    val=pwd.getpwuid(os.geteuid())[0]
  elif var == "PYTHON_VV":
    val="%s.%s" % sys.version_info[:2]
  elif var == "VENDOR":
    vendor=None
    if os.path.isfile('/etc/fedora-release'):
      vendor='fedora'
    elif os.path.isfile('/etc/redhat-release'):
      vendor='redhat'
    elif os.path.isfile('/etc/gentoo-release'):
      vendor='gentoo'
    elif os.path.isfile('/etc/debian_version'):
      vendor='debian'
    elif os.path.isfile('/etc/system-release'):
      vendor=open('/etc/system-release').read().split()[0]
    else:
      opsys=env("OS", force=force)
      if opsys == "darwin":
        vendor="apple"
      elif opsys == "openbsd":
        vendor="openbsd"
      elif opsys == "freebsd":
        vendor="freebsd"
      else:
        error("unknown VENDOR for OS=%s", opsys)
    val=vendor
  bootVal[var]=val
  return val

def filevarexts():
  hostname=env("HOSTNAME", force=force)
  if hostname is not None:
    yield "@%s" % hostname
  host=env("HOST", force=force)
  systemid=env("SYSTEMID", force=force)
  if host is not None:
    if systemid is not None:
      yield "@%s.%s" % (host, systemid)
    yield "@%s" % host
  if systemid is not None:
    yield "@%s" % systemid
  arch=env("ARCH", force=force)
  if arch is not None:
    yield ".%s" % arch
  osname=env("OS", force=force)
  if osname is not None:
    yield ".%s" % osname
  yield None

def filevar(var):
  if var in doingFilevar:
    warn("recursion in filevar(%s): %s", var, doingFilevar)
    return None
  doingFilevar.add(var)
  for ext in filevarexts():
    if ext is None:
      evar=var
    else:
      evar=var+ext
    if evar in filevars:
      doingFilevar.remove(var)
      return paramsubst(filevars[evar])

  doingFilevar.remove(var)
  return None

def setvar(var, val=None):
  if val is not None:
    if os.environ.get(var) != val:
      os.environ[var]=val
      isset.add(var)
    return val
  val=env(var, force=force)
  if val is None:
    warn("failed to setvar(%s)", var)
  else:
    os.environ[var]=val
    isset.add(var)
  return val

def paramsubst(val):
  newval=''
  while '$' in val:
    val0, val1 = val.split('$',1)
    newval+=val0
    pos=0
    while pos < len(val1) and (val1[pos].isalnum() or val1[pos] == '_'):
      pos+=1
    val=val1[pos:]
    subvar=val1[:pos]

    subval=env(subvar, force=force)
    if subval is None:
      warn("can't look up $%s", subvar)
    else:
      newval+=subval

  newval+=val

  return newval

def filevars(path):
  ''' Return a list of (var, value) tuples from the specific file.
  '''
  items = []
  with Pfx(path):
    with open(path) as fp:
      lineno = 0
      for line in fp:
        lineno += 1
        with Pfx(lineno):
          if not line.endswith('\n'):
            raise ValueError('unexpected EOF: missing trailing newline')
          line = line.strip()
          if not line or line.startswith('#'):
            continue
          try:
            var, value = line.split('=', 1)
          except ValueError:
            raise ValueError('missing "="')
          items.append( (var, value) )
  return items

def listfilevars():
  V=set()
  for v in filevars.keys():
    if '.' in v:
      v, v2 = v.split('.',1)
    if '@' in v:
      v, v2 = v.split('@',1)
    V.add(v)
  return V

def doCommand(argv):
  op=argv[0]
  argv=argv[1:]
  if op == "addprefix":
    for arg in argv:
      arg=paramsubst(arg)
      if not os.path.isabs(arg):
        arg=os.path.join('/opt',arg)
      setvar('PATH',"%s:%s/bin:%s/sbin" % (env('PATH', force=force), arg, arg))
      setvar('MANPATH',"%s:%s/man:%s/share/man" % (env('MANPATH', force=force), arg, arg))
      setvar('PERL5LIB',"%s:%s/lib/perl5:%s/lib/perl5/vendor_perl" % (env('PERL5LIB', force=force), arg, arg))
      ##setvar('PYTHONPATH',"%s:%s/lib/python%s/site-packages:%s/lib/python%s" % (env('PYTHONPATH', force=force), arg, env('PYTHON_VV', force=force), arg, env('PYTHON_VV', force=force)))
  elif op == "insprefix":
    argv.reverse()
    for arg in argv:
      arg=paramsubst(arg)
      if not os.path.isabs(arg):
        arg=os.path.join('/opt',arg)
      setvar('PATH',"%s/bin:%s/sbin:%s" % (arg, arg, env('PATH', force=force)))
      setvar('MANPATH',"%s/man:%s/share/man:%s" % (arg, arg, env('MANPATH', force=force)))
      setvar('PERL5LIB',"%s/lib/perl5:%s/lib/perl5/vendor_perl:%s" % (arg, arg, env('PERL5LIB', force=force)))
      ##setvar('PYTHONPATH',"%s/lib/python%s:%s" % (arg, env('PYTHON_VV', force=force), env('PYTHONPATH', force=force)))
  elif op == "python":
    exec " ".join(argv)
  elif op == "use":
    for arg in argv:
      if os.path.isabs(arg):
        doFile(arg)
      else:
        for path in envpath:
          fpath=os.path.join(path,arg)
          if os.path.isfile(fpath):
            doFile(fpath)
            break
  elif op == "var":
    for arg in argv:
      if arg == "*":
        for var in listfilevars():
          setvar(var)
      else:
        for var in paramsubst(arg).split(' '):
          setvar(var)
  else:
    error("unsupported operation: %s", op)

def doFile(path):
  with Pfx(path):
    oline=""
    for line in open(path):
      if line[-1:] != '\n':
        error("unexpected EOF")
        break
      line=line[:-1]
      if len(line) == 0 or line[-1] != '\\':
        oline+=line
        oline=oline.strip()
        if len(oline) > 0 and oline[0] != '#':
          eqpos=oline.find('=')
          if eqpos > 0 \
          and oline[0].isalpha() \
          and sum([ c.isalnum() or c == '_' for c in oline[1:eqpos] ]) == eqpos-1:        # all() not available in 2.3
            setvar(oline[:eqpos], paramsubst(oline[eqpos+1:]))
          else:
            doCommand(oline.split())
        oline=""
      else:
        oline+=" "+line[:-2]
    if len(oline) > 0:
      error("unterminated slosh line")

def cleanpath(path, sep=':'):
  keep = []
  for subpath in path.split(sep):
    if subpath not in keep and os.path.exists(subpath):
      keep.append(subpath)
  return sep.join(keep)

sys.exit(main(sys.argv))
