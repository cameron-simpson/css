#!/usr/bin/python
#
# Read peer access patterns and emit squid directives.
#       - Cameron Simpson <cs@zip.com.au> 23jul2012
#

from __future__ import print_function
import re
import sys
from cs.env import envsub
from cs.logutils import setup_logging, Pfx, error
from cs.obj import O

PEERAGE = "$HOME/.peerage"

re_PROXY = re.compile('^([a-zA-Z]\w*)=')

def main(argv):
  argv = list(argv)
  cmd = argv.pop(0)
  setup_logging(cmd)
  peerage = envsub(PEERAGE)

  ok = True

  peers = {}
  proxies = Proxies()
  proxies.add_proxy('DIRECT', None)

  with Pfx(peerage):
    with open(peerage) as pfp:
      lineno = 0
      for line in pfp:
        lineno += 1
        with Pfx(lineno):
          if not line.endswith('\n'):
            raise ValueError("unexpected EOF, no newline")
          line = line.strip()
          if not line or line.startswith('#'):
            continue
          m = re_PROXY.match(line)
          if m:
            proxname = m.group(1)
            peername = line[m.end():].lstrip()
            proxies.add_proxy(proxname, peername)
            continue
          try:
            proxname, etc = line.split(None, 1)
          except ValueError:
            proxname, etc = line, ''
          if not etc:
            continue
          patterns = re.split('[\s,]+', etc)
          if proxname not in proxies:
            error("invalid proxname: %s", proxname)
            ok = False
          else:
            proxies[proxname].add_patterns(patterns)

    if not ok:
      error("invalid specification")
      return 1

  # define accrued ACLs
  for proxy in proxies.values():
    proxy.define_acls()

  proxnames = sorted(proxies.keys())
  for proxname in proxnames:
    proxy = proxies[proxname]
    for acl_defn in proxy.acl_definitions():
      print(acl_defn)

  for proxname in proxnames:
    for access in proxies[proxname].peer_access:
      print(access)

  return 0

re_HAS_SCHEME = re.compile(r'^[a-z]+:')

def pattern_acl(pattern):
  ''' Return an ACL derived from the supplied pattern.
  '''
  if pattern == '*':
    return "src all"
  # /regex
  if pattern.startswith('/'):
    return "url_regex "+pattern
  # scheme:...
  if re_HAS_SCHEME.match(pattern):
    return "url_regex ^"+pattern
  # .ext ==> url_regex \.ext$
  if pattern.startswith('.'):
    return 'url_regex [.]' + pattern[1:] + '$'
  # *.domain ==> dstdomain .domain
  if pattern.startswith("*."):
    return "dstdomain "+pattern[1:]
  # specific domain ==> dstdomain domain
  return "dstdomain "+pattern

class Proxies(dict):

  def add_proxy(self, proxname, peername):
    if proxname in self:
      raise KeyError("proxy \"%s\" already seen" % (proxname,))
    self[proxname] = Proxy(proxname, peername, self)

class Proxy(O):

  def __init__(self, name, peername, all_proxies):
    self.name = name
    self.peername = peername
    self._patterns = []
    self.all_proxies = all_proxies
    self.also_unmatched = False
    self.any_unmatched = False

  def add_patterns(self, patterns):
    for pattern in patterns:
      if pattern == '*':
        self.also_unmatched = True
      elif pattern == '**':
        self.any_unmatched = True
      else:
        self._patterns.append(pattern)

  def define_acls(self):
    ''' Define ACLs for our patterns.
    '''
    self._acls = {}
    n = 0
    oacl_type = None
    for pattern in sorted(self._patterns):
      if pattern != "*":
        acl = pattern_acl(pattern)
        acl_type, acl_text = acl.split(None, 1)
        # squid 2 just complained about redundancy on ACL definitions
        # squid 3 aborts, so we'll just make distinct ACLs for each pattern
        # ghastly, yes
        if oacl_type is None or acl_type != oacl_type:
          oacl_type = acl_type
          acl_name = '_'.join( ('for', self.name, str(n)) )
          self._acls[acl_name] = []
          n += 1
        ##acl_name = '_'.join( (prefix, self.name, str(n)) )
        ##n += 1
        self._acls[acl_name].append("acl %s %s %s" % (acl_name, acl_type, acl_text))

  @property
  def acl_names(self):
    return sorted(self._acls.keys())

  def acl_definitions(self):
    for acl_name in self.acl_names:
      for acl_defn in self._acls[acl_name]:
        yield acl_defn

  @property
  def other_proxies(self):
    for proxname, proxy in sorted(self.all_proxies.items()):
      if proxy is not self:
        yield proxy

  @property
  def peer_access(self):
    ''' For the DIRECT peer, set always_direct.
        For other peers, set cache_peer_access;
          deny DIRECT patterns
          if not any_unmatched:
            deny all patterns not in our list
          allow our patterns
          if also_unmatched or any_unmatched
          then
            allow all
          else
            deny all
    '''
    name = self.name
    peername = self.peername
    if name == 'DIRECT':
      for acl_name in self.acl_names:
        yield "always_direct allow %s" % (acl_name,)
      for acl_name in self.acl_names:
        yield "never_direct deny %s" % (acl_name,)
    else:
      for acl_name in self.all_proxies['DIRECT'].acl_names:
        yield "cache_peer_access %s deny %s" % (peername, acl_name)
      if not self.any_unmatched:
        for oproxy in self.other_proxies:
          for acl_name in oproxy.acl_names:
            yield "cache_peer_access %s deny %s" % (peername, acl_name)
      for acl_name in self.acl_names:
        yield "cache_peer_access %s allow %s" % (peername, acl_name)
      if self.also_unmatched or self.any_unmatched:
        # allow all others
        yield "cache_peer_access %s allow all" % (peername,)
      else:
        # reject anything else not in our patterns
        yield "cache_peer_access %s deny all" % (peername,)

if __name__ == '__main__':
  sys.exit(main(sys.argv))
