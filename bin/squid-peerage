#!/usr/bin/python
#
# Read peer access patterns and emit squid directives.
#       - Cameron Simpson <cs@zip.com.au> 23jul2012
#

from __future__ import print_function
import re
import sys
from cs.env import envsub
from cs.logutils import Pfx
from cs.obj import O

PEERAGE = "$HOME/.peerage"

re_PROXY = re.compile('^([a-zA-Z]\w*)=')

def main(argv):
  argv = list(argv)
  cmd = argv.pop(0)
  peerage = envsub(PEERAGE)

  peers = {}
  proxies = Proxies()
  proxies.add_proxy('DIRECT', None)

  with Pfx(peerage):
    with open(peerage) as pfp:
      lineno = 0
      for line in pfp:
        lineno += 1
        with Pfx(lineno):
          if not line.endswith('\n'):
            raise ValueError("unexpected EOF, no newline")
          line = line.strip()
          if not line or line.startswith('#'):
            continue
          m = re_PROXY.match(line)
          if m:
            proxname = m.group(1)
            peername = line[m.end():].lstrip()
            proxies.add_proxy(proxname, peername)
            continue
          try:
            proxname, etc = line.split(None, 1)
          except ValueError:
            proxname, etc = line, ''
          if not etc:
            continue
          patterns = re.split('[\s,]+', etc)
          proxies[proxname].patterns.extend(patterns)

  proxnames = sorted(proxies.keys())
  for proxname in proxnames:
    for acl in proxies[proxname].acls:
      print(acl)

  for proxname in proxnames:
    for access in proxies[proxname].peer_access:
      print(access)

re_HAS_SCHEME = re.compile(r'^[a-z]+:')

def pattern_acl(pattern):
  ''' Return an ACL derived from the supplied pattern.
  '''
  # /regex
  if pattern == '*':
    return "src all"
  if pattern.startswith('/'):
    return "url_regex "+pattern
  # scheme:...
  if re_HAS_SCHEME.match(pattern):
    return "url_regex ^"+pattern
  if pattern.startswith("*."):
    return "dstdomain "+pattern[1:]
  return "dstdomain "+pattern

class Proxies(dict):

  def add_proxy(self, proxname, peername):
    if proxname in self:
      raise KeyError("proxy \"%s\" already seen" % (proxname,))
    self[proxname] = Proxy(proxname, peername, self)

class Proxy(O):

  def __init__(self, name, peername, all_proxies):
    self.name = name
    self.peername = peername
    self.patterns = []
    self.all_proxies = all_proxies

  @property
  def acls(self):
    ''' Define ACLs for our patterns, except "*".
    '''
    n = 0
    oacl_type = None
    for pattern in self.patterns:
      if pattern != "*":
        acl = pattern_acl(pattern)
        acl_type, acl_text = acl.split(None, 1)
        if oacl_type is None or acl_type != oacl_type:
          oacl_type = acl_type
          acl_name = "for_%s_%d" % (self.name, n)
          n += 1
        yield "acl %s %s %s" % (acl_name, acl_type, acl_text)

  @property
  def acl_names(self):
    ''' Enumerate the ACL names defained by .acls.
    '''
    seen = []
    for acl in self.acls:
      a, n, t = acl.split(None, 2)
      if n not in seen:
        yield n
        seen.append(n)

  @property
  def other_proxies(self):
    for proxname, proxy in sorted(self.all_proxies.items()):
      if proxy is not self:
        yield proxy

  @property
  def peer_access(self):
    ''' For the DIRECT peer, set always_direct.
        For other peers, set cache_peer_access;
          reject DIRECT patterns
          allow our patterns except for "*"
          if "*" in our patterns
            reject other non-DIRECT peers' patterns
            then allow all
          else
            reject all
    '''
    name = self.name
    peername = self.peername
    if name == 'DIRECT':
      for acl_name in self.acl_names:
        yield "always_direct allow %s" % (acl_name,)
      for acl_name in self.acl_names:
        yield "never_direct deny %s" % (acl_name,)
    else:
      for acl_name in self.all_proxies['DIRECT'].acl_names:
        yield "cache_peer_access %s deny %s" % (peername, acl_name)
      # allow our patterns (except "*")
      for acl_name in self.acl_names:
        yield "cache_peer_access %s allow %s" % (peername, acl_name)
      if "*" in self.patterns:
        # reject other proxies' patterns (except "*")
        for oproxy in self.other_proxies:
          if oproxy.name != 'DIRECT':
            for acl_name in oproxy.acl_names:
              yield "cache_peer_access %s deny %s" % (peername, acl_name)
        # allow all others
        yield "cache_peer_access %s allow all" % (peername,)
      else:
        # reject anything else not in our patterns
        yield "cache_peer_access %s deny all" % (peername,)

if __name__ == '__main__':
  sys.exit(main(sys.argv))
