#!/usr/bin/python
#
# Parse command line options and ssh config files.
#   - Cameron Simpson <cs@zip.com.au> 01oct2016
#

from __future__ import print_function
import sys
from fnmatch import fnmatch
from cs.app.ssh import parse_option, update_from_file, DEFAULT_CONFIGS
from cs.env import envsub
from cs.logutils import setup_logging, Pfx, info, warning, error, XP

USAGE = r'''Usage: %s [-F config-file]... [-o opt=value]... host [options...]
  -F config-file    Specific configuration file to read. These accumulate.
                    If no configuration files are specified use:
                        ''' + " ".join(DEFAULT_CONFIGS) + r'''
                    Configuration files are consulted in order and
                    the earlier matching setting of each option is
                    used.
  -o opt=value      Specify an ssh configuration option. Later -o
                    options override earlier ones. Options specified
                    by -o override options from configuration files.
  host              Host name used to match clauses in configuration files.
  options           If specified, print the value of each option
                    in order, each on its own line.
                    If not options are specified, print the value
                    of each option defined by -o or in a configuration
                    file as:
                        option-name option-value'''

def main(argv):
  cmd = argv.pop(0)
  setup_logging(cmd)
  usage = USAGE % (cmd,)
  configs = []
  options = {}
  badopts = False
  while argv:
    opt = argv.pop(0)
    if opt == '--':
      break
    if not opt.startswith('-') or len(opt) < 2:
      argv.insert(0, opt)
      break
    with Pfx(opt):
      if opt == '-F':
        configs.append(argv.pop(0))
      elif opt == '-o':
        optarg = argv.pop(0)
        with Pfx(optarg):
          try:
            option, optvalue = parse_option(optarg)
          except ValueError as e:
            warning("invalid option: %s", e)
            badopts = True
            continue
          info("cmdline: %s = %s", option, optvalue)
          options[option] = optvalue
      else:
        warning("unrecognised option")
        badopts = True
        continue
  if not argv:
    warning("missing host")
    badopts = True
  else:
    host = argv.pop(0)
  if not configs:
    configs = [ envsub(cfg) for cfg in DEFAULT_CONFIGS ]
  if badopts:
    print(usage, file=sys.stderr)
    return 2
  xit = 0
  for config in configs:
    if not update_from_file(options, config, host):
      xit = 1
  if argv:
    for option in argv:
      print(option, options.get(option.lower(), ''))
  else:
    for option in sorted(options.keys()):
      print(option, options[option])
  return xit

if __name__ == '__main__':
  sys.exit(main(sys.argv))
