#!/bin/sh
#
# Daemon to run and restart a command that provides a service, such
# as an ssh port forward.
#       - Cameron Simpson <cs@zip.com.au> 10dec2012
#

set -ue

: ${LOGDIR:=$HOME/var/log}
: ${VARRUN:=$HOME/var/run}
: ${DEBUG:=''}

logdir=$LOGDIR/svc
name=
flag_disable=
flag_override=
pidfile=
trace=
setx=:
[ -z "$DEBUG" ] || { trace=set-x; setx='set -x'; }
once=
testrate=7
killtime=5
sigcmd=
testcmd=
dolock=
lockname=

cmd=`basename "$0"`
usage="Usage: $cmd [-1] [-l] [-L lockname] [-n name] [-t testcmd] [-x] command [args...]
  -1    Run command only once.
  -l    Use lock \"svcd-<name>\" to prevent multiple instances of this svcd.
  -L lockname
        Use lock \"lockname\" to prevent multiple instances of this svcd.
  -n name
        Specify a name for this svcd.
        If specified, also create a pid file at $VARRUN/name.pid for the
        command. This also causes svcd to consult the flags {NAME}_OVERRIDE
        and {NAME}_DISABLE.
  -p pidfile
        Specify pidfile instead of default.
  -s sigcmd
        Run the signature shell command \"sigcmd\" whose output is
        used to check for changed circumstances requiring the service
        to restart.
  -t testcmd
        Run the test shell command \"testcmd\" periodically to
        govern whether the command should be active.
  -T testrate
        Interval between test polls in seconds. Default: $testrate
  -x    Trace execution."

badopts=

opts=

while [ $# -gt 0 ]
do
  case $1 in
    -1) once=1 opts="$opts $1" ;;
    -l) dolock=1 ;;
    -L) dolock=1 lockname=$2; shift ;;
    -n) name=$2; shift ;;
    -p) pidfile=$2; shift ;;
    -s) sigcmd=$2; shift ;;
    -t) testcmd=$2; shift ;;
    -T) testrate=$2; shift ;;
    -x) trace=set-x setx='set -x' opts="$opts $1" ;;
    --) shift; break ;;
    -?*)echo "$cmd: unrecognised option: $1" >&2
        badopts=1
        ;;
    *)  break ;;
  esac
  shift
done

if [ $# = 0 ]
then
  echo "$cmd: missing command" >&2
  badopts=1
fi

if [ $dolock ]
then
  # derive lock name if unspecified
  if [ -z "$lockname" ]
  then
    if [ -z "$name" ]
    then
      echo "$cmd: no lock name (-L) and no svcd name (-n)" >&2
      badopts=1
    else
      lockname=svcd-$name
    fi
  fi
fi

[ $badopts ] && { echo "$usage" >&2; exit 2; }

uppername()
{ echo "$1" | tr -- '-[a-z]' '_[A-Z]'
}

# rerun ourself inside a lock if specified
[ $dolock ] \
&& exec $trace lock -1 "$lockname" "$0" $opts -n "$name" -t "$testcmd" -- "$@"

if [ -n "$name" ]
then
  # recompute various things with the service name if specified
  uname=$( uppername "$name" )
  [ -z "$pidfile" ] && pidfile=$VARRUN/$name.pid
  [ -n "$flag_disable" ] || flag_disable=${uname}_DISABLE
  [ -n "$flag_override" ] || flag_override=${uname}_OVERRIDE
  pfx="$cmd $name"
else
  # else just compute the prefix from the command
  pfx="$cmd $1"
fi

# sanity check - is this process already active elsewhere?
if [ -n "$pidfile" ] && pid=`ifpid -q -v "$pidfile"`
then
  echo "$cmd: $pidfile: already running, pid $pid:" `ps -o args -p "$pid" 2>/dev/null | sed 1d` >&2
  exit 1
fi

oldsignature=$( [ -z "$sigcmd" ] || sh -uec "$sigcmd" )

ok()
{
  # check the signature for change
  if signature=$( [ -z "$sigcmd" ] || sh -uec "$sigcmd" )
  then
    if [ "x$oldsignature" != "x$signature" ]
    then
      alert "SVCD $name: RESTART: signature $oldsignature ==> $signature" || :
      oldsignature=$signature
      return 1
    fi
  fi
  [ -n "$flag_override" ] && flag -w "$flag_override" && return 0
  [ -z "$flag_disable" ] || not flag -w "$flag_disable" || return 1
  [ -z "$testcmd" ] || sh -uec "$setx; $testcmd" || return 1
  return 0
}

# kill the process specified by $pidfile (if nonempty) otherwise $subpid
# wait for it to terminate
killsubproc()
{
  if [ -n "$pidfile" ]
  then
    if [ -s "$pidfile" ]
    then
      $trace killpidfile -W "$killtime" -- "$pidfile"
      rm -f "$pidfile"
    fi
  else
    [ -z "$subpid" ] || $trace killpids -W "$killtime" -- "$subpid"
  fi
}

subpid=
trap 'killsubproc; exit 1' 1 2 3 15

while : SVCD MAIN LOOP "$pfx"
do
  if ok
  then
    # dispatch actual service process
    pfx "$pfx" $trace "$@" &
    subpid=$!
    [ -n "$pidfile" ] && echo "$subpid" >"$pidfile"

    # dispatch monitor to terminate service daemon if no longer ok to run
    ( ( while : SVCD SUBPID MONITOR "$pfx"
        do
          sleep "$testrate"
          kill -0 "$subpid" 2>/dev/null || exit 0
          ok || break
        done
        kill -0 "$subpid" 2>/dev/null && killsubproc
      ) &
    )

    # wait for the subprocess
    # or check it isn't there
    # or kill it (and wait)
    wait "$subpid" || not kill -0 "$subpid" 2>/dev/null || killsubproc
    subpid=
    [ -n "$pidfile" ] && rm -f "$pidfile"

    [ $once ] && break
  fi
  $trace sleep "$testrate"
done

[ -n "$pidfile" ] && rm -f "$pidfile"

exit 0
