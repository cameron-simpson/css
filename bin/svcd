#!/bin/sh
#
# Daemon to run and restart a command that provides a service, such
# as an ssh port forward.
#       - Cameron Simpson <cs@zip.com.au> 10dec2012
#

set -ue

: ${LOGDIR:=$HOME/var/log}
: ${VARRUN:=$HOME/var/run}
: ${DEBUG:=''}

ousername=`id -un`
username=$ousername
rusername=$username
logdir=$LOGDIR/svc
name=
flag_disable=
flag_override=
flag_restart=
svcd_pidfile=
subp_pidfile=
trace=
setx=:
[ -z "$DEBUG" ] || { trace=set-x; setx='set -x'; }
once=
testrate=7
killtime=5
quiet=
sigcmd=
testcmd=
dolock=
lockname=

cmd=`basename "$0"`
usage="Usage:
  $cmd disable name
          Set the flag {NAME}_DISABLE, causing the matching svcd to shut down
          its daemon process.
  $cmd enable name
          Clear the flag {NAME}_DISABLE, allowing the matching svcd to start
          up its daemon process.
  $cmd restart name
          Set the flag {NAME}_RESTART, causing the matching svcd to shut down
          and then restart its daemon process.
  $cmd stop name
          Kill the svcd running the named daemon process and the daemon process.
  $cmd [-1] [-l] [-L lockname] [-n name] [-t testcmd] [-x] command [args...]
    -1    Run command only once.
    -l    Use lock \"svcd-<name>\" to prevent multiple instances of this svcd.
    -L lockname
          Use lock \"lockname\" to prevent multiple instances of this svcd.
    -n name
          Specify a name for this svcd.
          Also create a subprocess pid file at $VARRUN/name.pid for the command.
          This also causes svcd to consult the flags {NAME}_OVERRIDE
          and {NAME}_DISABLE and {NAME}_RESTART.
    -p svcd-pidfile
          Specify $cmd pid file instead of default.
    -P subp-pidfile
          Specify $cmd subprocess pid file instead of default.
    -q    Quiet. Do not issue alerts.
    -s sigcmd
          Run the signature shell command \"sigcmd\" whose output is
          used to check for changed circumstances requiring the service
          to restart.
    -t testcmd
          Run the test shell command \"testcmd\" periodically to
          govern whether the command should be active.
    -T testrate
          Interval between test polls in seconds. Default: $testrate
    -u username
          Run command as the specified username.
    -U username
          Run test and related commands as the specified username.
    -x    Trace execution."

uppername()
{ echo "$1" | tr -- '-[a-z]' '_[A-Z]'
}

# process {disable|enable|restart|stop} specially if present
if [ $# -gt 0 ]
then
  case "$1" in
    disable|enable|restart|stop)
      op=$1; shift
      if [ $# = 0 ]
      then
        echo "$cmd: $op: missing name" >&2
      else
        name=$1; shift
        if [ $# -gt 0 ]
        then
          echo "$cmd: $op: extra arguments after name: $*" >&2
        else
          # usage correct, act on the operation
          uname=$( uppername "$name" )
          case $op in
            disable)    $race flag -w "${uname}_DISABLE" 1 ;;
            enable)     $race flag -w "${uname}_DISABLE" 0 ;;
            restart)    $race flag -w "${uname}_RESTART" 1 ;;
            stop)       $trace killpidfile -W "$killtime" -- "$VARRUN/svcd-$name.pid" ;;
            *)          echo "$cmd: $op: UNHANDLED!" >&2; exit 1 ;;
          esac
          exit
        fi
      fi
      echo "$usage" >&2
      exit 2
      ;;
  esac
fi

badopts=

opts=

while [ $# -gt 0 ]
do
  case $1 in
    -1) once=1 opts="$opts $1" ;;
    -l) dolock=1 ;;
    -L) dolock=1 lockname=$2; shift ;;
    -n) name=$2; shift ;;
    -p) svcd_pidfile=$2; shift ;;
    -P) subp_pidfile=$2; shift ;;
    -q) quiet=1 opts="$opts $1" ;;
    -s) sigcmd=$2; shift ;;
    -t) testcmd=$2; shift ;;
    -T) testrate=$2; shift ;;
    -u) username=$2; shift ;;
    -U) rusername=$2; shift ;;
    -x) trace=set-x setx='set -x' opts="$opts $1" ;;
    --) shift; break ;;
    -?*)echo "$cmd: unrecognised option: $1" >&2
        badopts=1
        ;;
    *)  break ;;
  esac
  shift
done

if [ $# = 0 ]
then
  echo "$cmd: missing command" >&2
  badopts=1
fi

if [ $dolock ]
then
  # derive lock name if unspecified
  if [ -z "$lockname" ]
  then
    if [ -z "$name" ]
    then
      echo "$cmd: no lock name (-L) and no svcd name (-n)" >&2
      badopts=1
    else
      lockname=svcd-$name
    fi
  fi
fi

[ $badopts ] && { echo "$usage" >&2; exit 2; }

# if command target user is not current user, prefix to commands to run as target
if [ "x$username" = "x$ousername" ]
then  command_as=
else  command_as="sux -u $username --"
fi

# if related command target user is not current user, prefix to commands to run as target
if [ "x$username" = "x$rusername" ]
then  rel_as=
else  rel_as="sux -u $rusername --"
fi

# rerun ourself inside a lock if specified
[ $dolock ] \
&& exec $trace lock -1 "$lockname" "$0" $opts -n "$name" -p "$subp_pidfile" -P "$svcd_pidfile" -s "$sigcmd" -t "$testcmd" -T "$testrate" -u "$username" -U "$rusername" -- "$@"

if [ -n "$name" ]
then
  # recompute various things with the service name if specified
  uname=$( uppername "$name" )
  : ${subp_pidfile:=$VARRUN/$name.pid}
  : ${svcd_pidfile:=$VARRUN/svcd-$name.pid}
  : ${flag_disable:-${uname}_DISABLE}
  : ${flag_override:=${uname}_OVERRIDE}
  : ${flag_restart:=${uname}_RESTART}
fi

# sanity check - is this process already active elsewhere?
if [ -n "$svcd_pidfile" ] && pid=`ifpid -q -v "$svcd_pidfile"`
then
  echo "$cmd: $svcd_pidfile: already running, pid $pid:" `ps -o args -p "$pid" 2>/dev/null | sed 1d` >&2
  exit 1
fi

# issue an alert message
lert()
{
  [ $quiet ] || $rel_as alert "SVCD $name: $*" || :
}

oldsignature=$( [ -z "$sigcmd" ] || $rel_as sh -uec "$sigcmd" )

ok()
{
  # check the signature for change
  if signature=$( [ -z "$sigcmd" ] || $rel_as sh -uec "$sigcmd" )
  then
    if [ "x$oldsignature" != "x$signature" ]
    then
      lert "signature $oldsignature ==> $signature"
      oldsignature=$signature
      return 1
    fi
  fi
  [ -n "$flag_override" ] && $rel_as flag -w "$flag_override" && return 0
  [ -z "$flag_disable" ] || not $rel_as flag -w "$flag_disable" || return 1
  [ -z "$testcmd" ] || $rel_as sh -uec "$setx; $testcmd" || return 1
  # restart flag returns not-ok and resets the flag
  if [ -n "$flag_restart" ] && $rel_as flag -w "$flag_restart"
  then
    lert "RESTART: flag $flag_restart"
    $rel_as flag "$flag_restart" 0
    return 1
  fi
  return 0
}

# kill the process specified by $subp_pidfile (if nonempty) otherwise $subpid
# wait for it to terminate
killsubproc()
{
  if [ -n "$subp_pidfile" ]
  then
    if [ -s "$subp_pidfile" ]
    then
      ( short_pidfile=$(printf '%s\n' "$subp_pidfile" | entilde)
        lert "kill $short_pidfile:" $(cat "$subp_pidfile")
      ) &
      $trace killpidfile -W "$killtime" -- "$subp_pidfile"
      rm -f "$subp_pidfile"
    fi
  else
    if [ -n "$subpid" ]
    then
      lert "stop $subpid"
      $trace killpids -W "$killtime" -- "$subpid"
    fi
  fi
}

tidy()
{
  [ -n "$subp_pidfile" ] && rm -f "$subp_pidfile"
  [ -n "$svcd_pidfile" ] && rm -f "$svcd_pidfile"
}

[ -n "$svcd_pidfile" ] && echo $$ >"$svcd_pidfile"

subpid=
trap 'killsubproc; tidy; exit 1' 1 2 3 15

while : SVCD MAIN LOOP
do
  if ok
  then
    # dispatch actual service process
    $trace $command_as "$@" &
    subpid=$!
    lert "spawned pid $subpid: $*"
    [ -n "$subp_pidfile" ] && echo "$subpid" >"$subp_pidfile"

    # dispatch monitor to terminate service daemon if no longer ok to run
    ( ( while : SVCD SUBPID MONITOR
        do
          sleep "$testrate"
          kill -0 "$subpid" 2>/dev/null || exit 0
          ok || break
        done
        kill -0 "$subpid" 2>/dev/null && killsubproc
      ) &
    )

    # wait for the subprocess
    # or check it isn't there
    # or kill it (and wait)
    wait "$subpid" || not kill -0 "$subpid" 2>/dev/null || killsubproc
    subpid=
    [ -n "$subp_pidfile" ] && rm -f "$subp_pidfile"

    [ $once ] && break
  fi
  $trace sleep "$testrate"
done

tidy

exit 0
