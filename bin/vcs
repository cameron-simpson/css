#!/bin/sh -ue
#
# Do simple things with revision controlled source.
# - Cameron Simpson <cs@cskk.id.au> 25apr2007
#
# Huge revsision. - cameron 11may2017
#

set -ue

: ${TMPDIR:=/tmp}
: ${EDITOR:=vi}
: ${VCS_FORMAT_GLOG_GIT:='%<(25)%ae %s%n%ci %h<-%p%d%n'}
: ${VCS_FORMAT_GLOG_HG:='{author|email} {desc|firstline}\n{date|isodate} {rev}:{node|short}<-{ifeq(p2node|short,"000000000000",p1node|short,join(parents))}{ifeq(branch,"default",""," [{branch}]")}{ifeq(activebookmark,"","","@{activebookmark}")}{ifeq(count(tags),0,""," ({join(tags)})")}\n\n'}

cmd=$(basename "$0")
usage="Usage: $cmd [-d dir] [-V vcs_type] [command [args...]]
  -d dir        Working directory, default: .
  -V vcs_type   Specify the VCS type to use.
                An empty string asks $cmd to figure this out.
  Commands:
    branch      Report current branch name.
    branches    Report all branch names.
    diff        Run the VCS diff command.
    glog        Report a graphical change log.
    info        Report VCS type, top and branch.
    modified    Report the names of modified files.
    report      (Default.) Report brief summary.
    status      Report tree status.
    tags        Report tag names.
    top         Report top of tree.
    type        Report type of tree."

wd=.
vcs_top=
vcs_type=
trace=command
##[ -t 2 ] && trace=set-x

badopts=

while [ $# -gt 0 ]
do
  case $1 in
    -d) wd=$2; shift ;;
    -V) vcs_type=$2; shift ;;
    --) shift; break ;;
    -?*)echo "$cmd: unrecognised option: $1" >&2
        badopts=1
        ;;
    *)  break ;;
  esac
  shift
done

[ -d "$wd/" ] || { echo "$cmd: not a directory: $wd" >&2; badopts=1; }

[ $badopts ] && { echo "$usage" >&2; exit 2; }

# enter working directory
cd "$wd"

# locate VCS top
case "$vcs_type" in
  hg)   findup_test='[ -e "$FINDUP_DIR/.hg" ]' ;;
  git)  findup_test='[ -e "$FINDUP_DIR/.git" ]' ;;
  ?*)   echo "$cmd: unsupported VCS \"$vcs_type\"" >&2; exit 1 ;;
  *)    findup_test='[ -e "$FINDUP_DIR/.hg" -o -e "$FINDUP_DIR/.git" ]' ;;
esac
vcs_top=$(
    set -ue
    findup -d . -c "$findup_test"
) || {
  echo "$cmd: $wd: cannot locate VCS top" >&2
  exit 1
}

[ -n "$vcs_type" ] || {
  if [ -e "$vcs_top/.hg" ]
  then  vcs_type=hg
  else
    if [ -e "$vcs_top/.git" ]
    then  vcs_type=git
    else  echo "$cmd: cannot infer VCS type from top dir $vcs_top" >&2
          exit 1
    fi
  fi
}

if [ $# = 0 ]
then    op=report
else    op=$1; shift
fi

hg(){   $trace hg ${1+"$@"}; }
git(){  $trace git ${1+"$@"}; }

# Compute working directory VCS type.
# All other commands are split on type below.
case "$op" in
  info)
    if [ $# -gt 0 ]
    then
      echo "$cmd: $op: extra arguments after dir: $*" &2
      badopts=1
    else
      vcs_branch=$("$0" -V "$vcs_type" branch)
      printf 'top %s\ntype %s\nbranch %s\n' "$vcs_top" "$vcs_type" "$vcs_branch"
      case "$vcs_type" in
        hg)
          bookmark=$(hg bookmark | sed -n '/^ \* /!d; s///; s/ .*//; p')
          printf 'bookmark %s\n' "$bookmark"
          ;;
      esac
    fi
    ;;
  top)
    printf '%s\n' "$vcs_top"
    ;;
  type)
    printf '%s\n' "$vcs_type"
    ;;
  *)
    # variant for each of the following operations
    case "$op,$vcs_type" in
      # report current branch
      branch,git)   git branch | sed -n 's/^\* //p' ;;
      branch,hg)    hg branch ;;
      # report all branches
      branches,git) git branch ;;
      branches,hg)  hg branches ${1+"$@"} ;;
      # current diff
      diff,git)     git diff ${1+"$@"} ;;
      diff,hg)      hg diff ${1+"$@"} ;;
      get-branches,git)
                    remote=${1:-origin}
                    git branch -r \
                    | sed "s/^  //;/^$remote\\//!d; / /d" \
                    | while read -r rbr
                      do
                        lbr=${rbr##$remote/}
                        if git branch | grep "^. $lbr\$" >/dev/null
                        then
                          echo "$cmd: $op: $rbr: local branch already exists"
                        else
                          git branch --track "$lbr" "$rbr" || break
                        fi
                      done
                    ;;
      # graph log
      glog,git)     git log \
                      --graph "--format=tformat:$VCS_FORMAT_GLOG_GIT" \
                      ${1+"$@"}
                    ;;
      glog,hg)      hg log -G --template "$VCS_FORMAT_GLOG_HG" \
                      ${1+"$@"}
                    ;;
      # report modified files
      modified,git) ( cd "$vcs_top"
                      git status --porcelain | awk '$1 == "M" { print $2 }'
                    )
                    ;;
      modified,hg)  hg status -n -am ${1+"$@"} ;;
      # report and/or status
      report,git | status,git | st,git )
                    git status ${1+"$@"}
                    ;;
      report,hg)    hg summary
                    hg status -C ${1+"$@"} | grep '^[^?]'
                    ;;
      status,hg | st,hg)
                    hg status -C ${1+"$@"}
                    ;;
      # report tags
      tags,git)     [ $# -gt 0 ] || set -- -l; git tag "$@" ;;
      tags,hg)      hg tags ${1+"$@"} ;;
      # update to revision
      up,git|update,git)
                    if [ $# = 1 ]
                    then
                      git co "$1"
                    else
                      echo "$cmd: $op: expected a single revision" >&2
                      badopts=1
                    fi
                    ;;
      up,hg|update,hg)
                    if [ $# = 1 ]
                    then
                      hg update -r "$1"
                    else
                      echo "$cmd: $op: expected a single revision" >&2
                      badopts=1
                    fi
                    ;;
      *)            echo "$cmd: unrecognised command for $vcs_type: $op" >&2
                    badopts=1
                    ;;
    esac
    ;;
esac

xit=$?

[ $badopts ] && { echo "$usage" >&2; exit 2; }

exit $xit
