#!/usr/bin/env python
#
# Command script for venti-ish implementation.
#       - Cameron Simpson <cs@zip.com.au> 01may2007
#
# =head1 NAME
#
# vt - access vt stores, a Venti-like content addressed storage pool
#
# =head1 SYNOPSIS
#
#   vt [options...] ar tar-options paths...
#   vt [options...] cat filerefs...
#   vt [options...] catblock [-i] hashcodes...
#   vt [options...] listen port
#   vt [options...] ls [-R] dirrefs...
#   vt [options...] mount dirref mountpoint
#   vt [options...] scan datafile
#   vt [options...] pull stores...
#   vt [options...] unpack dirrefs...
#
# =head1 DESCRIPTION
#
# I<vt> is a command accessing vt stores in various ways.
#
# A store is a content addressed pool of blocks
# with a filesystem abstraction layered on top of it.
#
#
# Command script for venti-ish implementation.
#       - Cameron Simpson <cs@zip.com.au> 01may2007
#

from __future__ import with_statement
import sys
import os
import os.path
from getopt import getopt, GetoptError
import datetime
from cs.logutils import Pfx, exception, error, debug, setup_logging, logTo, D
from cs.venti import totext, fromtext
from cs.venti.block import IndirectBlock, decodeBlocks
from cs.venti.debug import dumpBlock
from cs.venti.store import Store
from cs.venti.cache import CacheStore, MemCacheStore
from cs.venti.dir import Dir, resolve

def main(argv):
  import cs.misc
  setup_logging()
  cmd = cs.misc.cmd
  usage = '''Usage:
    %s [options...] cat filerefs...
    %s [options...] catblock [-i] hashcodes...
    %s [options...] listen port
    %s [options...] ls [-R] dirrefs...
    %s [options...] mount dirref mountpoint
    %s [options...] scan datafile
    %s [options...] pack paths...
    %s [options...] pack -o file.vt path
    %s [options...] pull stores...
    %s [options...] unpack dirrefs...
    Options:
      -C store    Use this as a front end cache store.
                  "-" means no front end cache.
      -M          Don't use an additional MemCacheStore front end.
      -S store    Specify the store to use:
                    /path/to/dir  GDBMStore
                    tcp:[host]:port TCPStore
                    |sh-command   StreamStore via sh-command
''' % (cmd, cmd, cmd, cmd, cmd, cmd, cmd, cmd, cmd, cmd)

  badopts = False

  dflt_cache = os.environ.get('VT_STORE_CACHE')
  dflt_vt_store = os.environ.get('VT_STORE')
  dflt_log = os.environ.get('VT_LOGFILE')
  useMemCache = True

  try:
    opts, args = getopt(argv[1:], 'C:MS:')
  except GetoptError, e:
    error("unrecognised option: %s: %s"% (e.opt, e.msg))
    badopts = True
    opts, args = [], []

  # =head1 OPTIONS
  #
  # =over 4
  #
  for opt, val in opts:
    # =item B<-C> I<store>
    #
    # Specify a caching store.
    # The special name "-" means no caching store should be used.
    # If B<-C> is not used
    # the environment variable B<VT_STORE_CACHE> may specify the caching store.
    #
    if opt == '-C':
      if val == '-':
        dflt_cache = None
      else:
        dflt_cache = val
    # =item B<-M>
    #
    # Do not use the in-memory caching store.
    # Default is to place an in-memory cache ahead of the other stores.
    #
    elif opt == '-M':
      useMemCache = False
    # =item B<-S> I<store>
    #
    # Use the specified I<store>.
    # If B<-S> is not used
    # the environment variable B<VT_STORE> specifies the store.
    #
    elif opt == '-S':
      dflt_vt_store = val
    else:
      assert False, "unsupported option: %s" % (opt,)

  # =back
  #
  # =head1 Store Names
  #
  # Three of four planned store names are supported at present:
  #
  # =over 4
  #
  # =item B</>I<pathname>
  #
  # A full path to a directory specifies a local filesystem store
  # in the directory B</>I<pathname>.
  #
  # =item B<tcp:>[I<host>]B<:>I<port>
  #
  # A name commencing with B<tcp:> specifies a TCP connection to a vt daemon
  # listening on the specified I<host> and I<port>.
  # If I<host> is omitted, B<127.0.0.1> is assumed.
  #
  # =item B<unix:/>I<pathname>
  #
  # B<UNIMPLEMENTED>.
  # A name commencing with B<unix:> specifies the pathname of a UNIX domain
  # socket on which a vt daemon is listening.
  #
  # =item B<|>I<shell-command>
  #
  # A name commencing with shell pipe symbol specifies a proxy command
  # to connect to a vt daemon. The command string is handed to B</bin/sh>
  # and should accept vt requests on standard input and write vt responses to
  # standard output.
  #
  # =back
  #

  if dflt_log is not None:
    logTo(dflt_log, delay=True)

  xit = None
  S = None

  if len(args) < 1:
    error("missing command")
    badopts = True
  else:
    op = args.pop(0)
    with Pfx(op):
      try:
        op_func = getattr(sys.modules[__name__], "cmd_" + op)
      except AttributeError:
        error("unknown operation \"%s\"", op)
        badopts = True
      else:
        if op in ("scan", "init"):
          # run without a context store
          try:
            xit = op_func(args)
          except GetoptError, e:
            error("%s", e)
            badopts = True
        else:
          if dflt_vt_store is None:
            error("no $VT_STORE and no -S option")
            badopts = True
          else:
            try:
              S = Store(dflt_vt_store)
            except:
              exception("can't open store \"%s\"", dflt_vt_store)
              badopts = True
            else:
              if dflt_cache is not None:
                try:
                  C = Store(dflt_cache)
                except:
                  exception("can't open cache store \"%s\"", dflt_cache)
                  badopts = True
                else:
                  S = CacheStore(S, C)
              if not badopts:
                # put an in-memory cache in front of the main cache
                if useMemCache:
                  S = CacheStore(S, MemCacheStore())
                with S:
                  try:
                    xit = op_func(args)
                  except GetoptError, e:
                    error("%s", e)
                    badopts = True

  if S:
    S.close()

  if badopts:
    sys.stderr.write(usage)
    return 2

  assert xit is not None, "exit code not set by operation"
  return xit

# =head1 COMMANDS
#
# =over 4
#

# =item B<ar> tar-like-options I<pathnames...>
#
# Archive or retrieve files.
#
def cmd_ar(args):
  if len(args) < 1:
    raise GetoptError, "missing options"
  opts = args.pop(0)
  if len(opts) == 0:
    raise GetoptError, "empty options"

  badopts = False
  verbose = False
  arfile = None
  mode = opts[0]
  for opt in opts[1:]:
    if opt == 'f':
      arfile = args.pop(0)
    elif opt == 'v':
      verbose = True
    else:
      error("%s: unsupported option", opt)
      badopts = True

  if len(args) < 1:
    error("missing pathnames")
    badopts = true

  if badopts:
    raise GetoptError, "bad options"

  xit = 0

  import cs.venti.archive
  if arfile is not None and arfile == '-':
    arfile = None

  if mode == 'u':
    for path in args:
      try:
        cs.venti.archive.archive(arfile, path, verbose)
      except IOError, e:
        error("archive %s: %s" % (path, e))
        xit = 1
  elif mode == 'x':
    if arfile is None:
      raise GetoptError, "missing arfile: stdin mode not yet implemented"
    with Pfx("xf %s" % (arfile,)):
      for path, E in cs.venti.archive.retrieve(arfile, args, verbose):
        if E is None:
          error("retrieve %s: not found" % (path,))
          xit = 1
        else:
          print "X - %s - %s" % (E.name, E)
  else:
    raise GetoptError, "%s: unsupported mode" % (mode,)

  return xit

# =item B<cat> I<filerefs...>
#
# Emit the data content of the supplied I<filerefs> on the standard output.
#
def cmd_cat(args):
  if not args:
    raise GetoptError, "missing filerefs"
  for path in args:
    cat(path)
  return 0

# =item B<catblock> [B<-i>] I<hashcodes...>
#
# Emit the content of the blocks specified by the supplied I<hashcodes>.
# If the B<-i> (indirect) option is supplied,
# consider the hashcode to specify an indirect block and emit
# the data content of the leaf blocks.
#
def cmd_catblock(args):
  indirect = False
  if len(args) > 0 and args[0] == "-i":
    indirect = True
    args.pop(0)
  if not args:
    raise GetoptError, "missing hashcodes"
  for arg in args:
    data = S[fromtext(arg)]
    if indirect:
      IB = IndirectBlock()
      IB.extend(decodeBlocks(data))
      dumpBlock(IB)
    else:
      sys.stdout.write(data)
  return 0

# =item B<init> <dirpath>
#
# Initialise a directory for use as a store, using the GDBM backend.
#
def cmd_init(args):
  if not args:
    raise GetoptError, "missing dirpath"
  dirpath = args.pop(0)
  if args:
    raise GetoptError, "extra arguments after dirpath: %s" % (' '.join(args),)
  with Pfx(dirpath):
    if not os.path.isdir(dirpath):
      raise GetoptError, "not a directory"
    with Store("file:"+dirpath):
      pass
  return 0

# =item B<listen> {B<->|[I<host>]B<:>I<port>}
#
# Start a vt daemon.
#
# The argument "-" specifies a single use daemon reading vt
# requests from its standard input and writing replies to its
# standard output, as it might run from inetd(8) or
# xinetd(8), or directly from a proxy shell command.
#
# An argument of the form I<host>B<:>I<port> specifies that the
# daemon should listen on the specified I<host> address and I<port>
# for connections.  if I<host> is omitted it defaults to B<127.0.0.1>.
#
def cmd_listen(args):
  if len(args) != 1:
    raise GetoptError, "expected a port"
  arg = args[0]
  if arg == '-':
    from cs.venti.stream import StreamDaemon
    daemon = StreamDaemon(S, sys.stdin, sys.stdout)
    daemon.join()
  else:
    cpos = arg.rfind(':')
    if cpos >= 0:
      host = arg[:cpos]
      port = arg[cpos+1:]
      if len(host) == 0:
        host = '127.0.0.1'
      port = int(port)
      import cs.venti.tcp
      with cs.venti.tcp.Server((host, port), S) as srv:
        srv.serve_forever()
    else:
      raise GetoptError, "invalid listen argument, I expect \"-\" or \"[host]:port\", got \"%s\"" % (arg,)
  return 0

# =item B<ls> [B<-R>] I<dirrefs...>
#
# Do a directory listing of the specified I<dirrefs>.
# The B<-R> (recursive) option requests a recurive directory listing.
#
def cmd_ls(args):
  recurse = False
  if args and args[0] == "-R":
    recurse = True
    args.pop(0)
  if not args:
    raise GetoptError, "missing dirrefs"
  first = True
  for path in args:
    if first:
      first = False
    else:
      print
    D, name = resolve(path)
    if name is not None:
      D = D.chdir1(name)
    ls(path, D, recurse, sys.stdout)
  return 0

# =item B<mount> I<dirref> I<mountpoint>
#
# B<INCOMPLETE>.
# Mount the specified I<dirref> as on the specified I<mountpoint> directory.
# Requires FUSE support.
#
def cmd_mount(args):
  if len(args) != 2:
    raise GetoptError, "expected dirref and mountpoint"
  dirref, mountpoint = args
  print "mount", args[0], args[1], "..."
  if not os.path.isdir(mountpoint):
    error("%s: mountpoint is not a directory", mountpoint)
    return 1
  E = S.namei(args[0]+'/')
  if not E.isdir:
    error("%s: dirref - expected directory, not file", dirref)
    return 1
  import cs.venti.vtfuse
  cs.venti.vtfuse.fusemount(args[1], S, E)
  return 0

# =item B<pull> I<stores...>
#
# Update our store with all the available content from the specified I<stores>.
# Note that some stores may not list all their content, or any.
# This is mostly useful for updating a master store from a store
# which has been updated offline.
#
def cmd_pull(args):
  if not args:
    raise GetoptError, "missing stores"
  raise NotImplementedError

# =item B<scan> I<datafile>
#
# Read the specified I<datafile> as a vt block storage file,
# a sequence of compressed data blocks.
# Report on standard output
# the block hashcode, I<datafile> file offset and compressed size.
#
def cmd_scan(args):
  if len(args) != 1:
    raise GetoptError, "missing datafile"
  datafile = args[0]
  from cs.venti.datafile import DataFile
  with Pfx(datafile):
    dfp = DataFile(datafile)
    for offset, flags, data in dfp.scanData():
      print totext(defaults.S.hash(data)), offset, "0x%02x" % (flags,), len(data)
    dfp.close()
  return 0

# =item B<unpack> I<dirrefs...>
#
# Unpack the directory specified by each I<dirref> into the current
# working directory.
# This is the inverse of the B<pack> command.
# Currently, to unpack a B<.vt> file the most succinct command is this:
#
#   vt unpack `awk '{ dirref=$1 } END { print dirref }' file.vt`
#
def cmd_unpack(args):
  if len(args) < 1:
    raise GetoptError, "missing dirrefs"
  xit = 0
  for path in args:
    with (path):
      D, name = resolve(path)
      if len(name) > 0:
        D = D.chdir1(name)
      for subD, _, files in D.walk(topdown=True):
        with subD:
          if len(subD.path) > 0 and not os.path.isdir(subD.path):
            print "mkdir", subD.path
            os.makedirs(subD.path)
          files.sort()
          for fname in files:
            with fname:
              if len(fname) == 0 or fname == '.' or fname == '..' or '/' in fname:
                error("illegal filename")
              fpath = os.path.join(subD.path, fname)
              with open(fpath, mode='w') as outfp:
                for b in subD[fname].getBlock().leaves(S):
                  outfp.write(b)
  return xit

# =back
#

def lsDirent(fp, E, name):
  B = E.getBlock()
  st = E.stat()
  ##print "st=%s" % (st,)
  st_mode, st_ino, st_dev, st_nlink, st_uid, st_gid, st_size, \
    st_atime, st_mtime, st_ctime = st
  ##print "st_mtime=%s" % `st_mtime`
  ##print "st_size=%s" % `st_size`
  ##print "name=%s" % `name`
  t = datetime.datetime.fromtimestamp(int(st_mtime))
  fp.write("%c %-41s %s %-6d %s\n" \
           % (('d' if E.isdir() else 'f'),
              B, t, st_size, name))

def ls(path, D, recurse, fp=None):
  if fp is None:
    fp = sys.stdout
  fp.write(path)
  fp.write(":\n")
  if not recurse:
    debug("ls(): getting dirs and files...")
    names = D.dirs()+D.files()
    debug("ls(): got dirs and files = %s" % (names,))
    names.sort()
    for name in names:
      debug("ls(): D=%s (%s), name=%s" % (D, type(D), name))
      E = D[name]
      lsDirent(fp, E, name)
  else:
    dirs = D.dirs()
    dirs.sort()
    files = D.files()
    files.sort()
    for name in files:
      E = D[name]
      lsDirent(fp, E, name)
      assert not E.isdir(), name+" should not be a directory!"
    for name in dirs:
      ls(os.path.join(path, name), D.chdir1(name), recurse, fp)

def cat(path, fp=None):
  if fp is None:
    fp = sys.stdout
  D, name = resolve(path)
  if name is not None:
    D = D[name]
  block = D.getBlock()
  for B in block.leaves():
    fp.write(B.blockdata())

if __name__ == '__main__':
  sys.exit(main(sys.argv))

# =head1 EXAMPLES
#
# Run a daemon for a master store:
#
#  vt -C - -S /var/spool/venti listen :9999
#
# Store a directory in that store:
#
#  vt -S tcp:127.0.0.1:9999 vt pack directory-name
#
# Run a local store on a roaming laptop with internet connectivity,
# pushing updates back to the master store, keeping a local on-disc cache
# in B<~/.venti/store>:
#
#  vt -C ~/.venti/store -M -S '|exec ssh home-server exec nc 127.0.0.1 9999' listen 9999
#
# Use the store on the roaming laptop via the local daemon:
#
#  VT_STORE=tcp:127.0.0.1:9999
#  export VT_STORE
#  vt command...
#
# Use the remote store and local cache without an intermediate daemon:
#
#  VT_STORE='|exec ssh home-server exec nc 127.0.0.1 9999'
#  VT_STORE_CACHE=$HOME/.venti/store
#  export VT_STORE VT_STORE_CACHE
#  vt command...
#
# This last has more efficient operations at the price of a larger startup
# latency (the ssh connection) and the downside that only one command can
# use the cache store at a time because it is not a sharable data structure
# except via a vt daemon.
#
# =head1 BUGS
#
# The TODO list is very long, see:
#
#  http://csbp.backpackit.com/pub/1356606
#
# The command does not cope well with an incomplete store if it traverses
# into the missing portion;
# one example is using a cache without the more complete backend master store.
#
# =head1 ENVIRONMENT VARIABLES
#
# B<VT_STORE>, the default store to use.
#
# B<VT_STORE_CACHE>, a default cache store.
#
# =head1 SEE ALSO
#
# The Venti file storage system: http://en.wikipedia.org/wiki/Venti
#
# =head1 AUTHOR
#
# Cameron Simpson E<lt>cs@zip.com.auE<gt>
#
