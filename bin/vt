#!/usr/bin/env python
#
# Command script for venti-ish implementation.
#       - Cameron Simpson <cs@zip.com.au> 01may2007
#
# =head1 NAME
#
# vt - access vt stores, a Venti-like content addressed storage pool
#
# =head1 SYNOPSIS
#
#   vt [options...] ar tar-options paths...
#   vt [options...] cat filerefs...
#   vt [options...] catblock [-i] hashcodes...
#   vt [options...] listen port
#   vt [options...] ls [-R] dirrefs...
#   vt [options...] mount dirref mountpoint
#   vt [options...] scan datafile
#   vt [options...] pull stores...
#   vt [options...] unpack dirrefs...
#
# =head1 DESCRIPTION
#
# I<vt> is a command accessing vt stores in various ways.
#
# A store is a content addressed pool of blocks
# with a filesystem abstraction layered on top of it.
#
#
# Command script for venti-ish implementation.
#       - Cameron Simpson <cs@zip.com.au> 01may2007
#

from __future__ import with_statement
import sys
import os
import os.path
from getopt import getopt, GetoptError
import datetime
from cs.logutils import Pfx, exception, error, debug, setup_logging, logTo, D
from cs.venti import totext, fromtext, defaults
from cs.venti.block import IndirectBlock, decodeBlocks
from cs.venti.debug import dumpBlock
from cs.venti.store import Store
from cs.venti.cache import CacheStore, MemCacheStore
from cs.venti.dir import Dir, resolve

def main(argv):
  import cs.misc
  setup_logging()
  cmd = cs.misc.cmd
  usage = '''Usage:
    %s [options...] cat filerefs...
    %s [options...] catblock [-i] hashcodes...
    %s [options...] listen port
    %s [options...] ls [-R] dirrefs...
    %s [options...] mount dirref mountpoint
    %s [options...] scan datafile
    %s [options...] pack paths...
    %s [options...] pack -o file.vt path
    %s [options...] pull stores...
    %s [options...] unpack dirrefs...
    Options:
      -C store    Use this as a front end cache store.
                  "-" means no front end cache.
      -M          Don't use an additional MemCacheStore front end.
      -S store    Specify the store to use:
                    /path/to/dir  GDBMStore
                    tcp:[host]:port TCPStore
                    |sh-command   StreamStore via sh-command
''' % (cmd, cmd, cmd, cmd, cmd, cmd, cmd, cmd, cmd, cmd)

  badopts = False

  dflt_cache = os.environ.get('VT_STORE_CACHE')
  dflt_vt_store = os.environ.get('VT_STORE')
  dflt_log = os.environ.get('VT_LOGFILE')
  useMemCache = True

  try:
    opts, args = getopt(argv[1:], 'C:MS:')
  except GetoptError, e:
    error("unrecognised option: %s: %s"% (e.opt, e.msg))
    badopts = True
    opts, args = [], []

  # =head1 OPTIONS
  #
  # =over 4
  #
  for opt, val in opts:
    # =item B<-C> I<store>
    #
    # Specify a caching store.
    # The special name "-" means no caching store should be used.
    # If B<-C> is not used
    # the environment variable B<VT_STORE_CACHE> may specify the caching store.
    #
    if opt == '-C':
      if val == '-':
        dflt_cache = None
      else:
        dflt_cache = val
    # =item B<-M>
    #
    # Do not use the in-memory caching store.
    # Default is to place an in-memory cache ahead of the other stores.
    #
    elif opt == '-M':
      useMemCache = False
    # =item B<-S> I<store>
    #
    # Use the specified I<store>.
    # If B<-S> is not used
    # the environment variable B<VT_STORE> specifies the store.
    #
    elif opt == '-S':
      dflt_vt_store = val
    else:
      assert False, "unsupported option: %s" % (opt,)

  # =back
  #
  # =head1 Store Names
  #
  # Three of four planned store names are supported at present:
  #
  # =over 4
  #
  # =item B</>I<pathname>
  #
  # A full path to a directory specifies a local filesystem store
  # in the directory B</>I<pathname>.
  #
  # =item B<tcp:>[I<host>]B<:>I<port>
  #
  # A name commencing with B<tcp:> specifies a TCP connection to a vt daemon
  # listening on the specified I<host> and I<port>.
  # If I<host> is omitted, B<127.0.0.1> is assumed.
  #
  # =item B<unix:/>I<pathname>
  #
  # B<UNIMPLEMENTED>.
  # A name commencing with B<unix:> specifies the pathname of a UNIX domain
  # socket on which a vt daemon is listening.
  #
  # =item B<|>I<shell-command>
  #
  # A name commencing with shell pipe symbol specifies a proxy command
  # to connect to a vt daemon. The command string is handed to B</bin/sh>
  # and should accept vt requests on standard input and write vt responses to
  # standard output.
  #
  # =back
  #

  if dflt_log is not None:
    logTo(dflt_log, delay=True)

  xit = None
  S = None

  if len(args) < 1:
    error("missing command")
    badopts = True
  else:
    op = args.pop(0)
    with Pfx(op):
      try:
        op_func = getattr(sys.modules[__name__], "cmd_" + op)
      except AttributeError:
        error("unknown operation \"%s\"", op)
        badopts = True
      else:
        if op in ("scan", "init"):
          # run without a context store
          try:
            xit = op_func(args)
          except GetoptError, e:
            error("%s", e)
            badopts = True
        else:
          if dflt_vt_store is None:
            error("no $VT_STORE and no -S option")
            badopts = True
          else:
            try:
              S = Store(dflt_vt_store)
            except:
              exception("can't open store \"%s\"", dflt_vt_store)
              badopts = True
            else:
              if dflt_cache is not None:
                try:
                  C = Store(dflt_cache)
                except:
                  exception("can't open cache store \"%s\"", dflt_cache)
                  badopts = True
                else:
                  S = CacheStore(S, C)
              if not badopts:
                # put an in-memory cache in front of the main cache
                if useMemCache:
                  S = CacheStore(S, MemCacheStore())
                with S:
                  try:
                    xit = op_func(args)
                  except GetoptError, e:
                    error("%s", e)
                    badopts = True

  if S:
    S.close()

  if badopts:
    sys.stderr.write(usage)
    return 2

  assert xit is not None, "exit code not set by operation"
  return xit

# =head1 COMMANDS
#
# =over 4
#

# =item B<ar> tar-like-options I<pathnames...>
#
# Archive or retrieve files.
#
def cmd_ar(args):
  if len(args) < 1:
    raise GetoptError, "missing options"
  opts = args.pop(0)
  if len(opts) == 0:
    raise GetoptError, "empty options"

  badopts = False
  verbose = False
  arfile = None
  mode = opts[0]
  for opt in opts[1:]:
    if opt == 'f':
      arfile = args.pop(0)
    elif opt == 'v':
      verbose = True
    else:
      error("%s: unsupported option", opt)
      badopts = True

  if mode == 'u' and len(args) < 1:
    error("missing pathnames")
    badopts = True

  if badopts:
    raise GetoptError, "bad options"

  xit = 0

  import cs.venti.archive
  if arfile is not None and arfile == '-':
    arfile = None

  if mode == 't':
    if arfile is None:
      raise GetoptError, "missing arfile: stdin mode not yet implemented"
    if args:
      paths = args
    else:
      paths = None
    with Pfx("tf %s" % (arfile,)):
      cs.venti.archive.toc(arfile, paths, verbose)
  elif mode == 'u':
    for path in args:
      try:
        ok = cs.venti.archive.archive(arfile, path, verbose, trust_size_mtime=True)
      except IOError, e:
        error("archive %s: %s" % (path, e))
        xit = 1
      else:
        if not ok:
          xit = 1
  elif mode == 'x':
    if arfile is None:
      raise GetoptError, "missing arfile: stdin mode not yet implemented"
    if args:
      paths = args
    else:
      paths = None
    with Pfx("xf %s" % (arfile,)):
      for path, E in cs.venti.archive.retrieve(arfile, paths):
        if verbose:
          print path
        if E is None:
          error("retrieve %s: not found" % (path,))
          xit = 1
        else:
          print "X - %s - %s" % (E.name, E)
  else:
    raise GetoptError, "%s: unsupported mode" % (mode,)

  return xit

# =item B<cat> I<filerefs...>
#
# Emit the data content of the supplied I<filerefs> on the standard output.
#
def cmd_cat(args):
  if not args:
    raise GetoptError, "missing filerefs"
  for path in args:
    cat(path)
  return 0

# =item B<catblock> [B<-i>] I<hashcodes...>
#
# Emit the content of the blocks specified by the supplied I<hashcodes>.
# If the B<-i> (indirect) option is supplied,
# consider the hashcode to specify an indirect block and emit
# the data content of the leaf blocks.
#
def cmd_catblock(args):
  indirect = False
  if len(args) > 0 and args[0] == "-i":
    indirect = True
    args.pop(0)
  if not args:
    raise GetoptError, "missing hashcodes"
  for arg in args:
    data = S[fromtext(arg)]
    if indirect:
      IB = IndirectBlock()
      IB.extend(decodeBlocks(data))
      dumpBlock(IB)
    else:
      sys.stdout.write(data)
  return 0

# =item B<init> <dirpath>
#
# Initialise a directory for use as a store, using the GDBM backend.
#
def cmd_init(args):
  if not args:
    raise GetoptError, "missing dirpath"
  dirpath = args.pop(0)
  if args:
    raise GetoptError, "extra arguments after dirpath: %s" % (' '.join(args),)
  with Pfx(dirpath):
    if not os.path.isdir(dirpath):
      raise GetoptError, "not a directory"
    with Store("file:"+dirpath):
      pass
  return 0

# =item B<listen> {B<->|[I<host>]B<:>I<port>}
#
# Start a vt daemon.
#
# The argument "-" specifies a single use daemon reading vt
# requests from its standard input and writing replies to its
# standard output, as it might run from inetd(8) or
# xinetd(8), or directly from a proxy shell command.
#
# An argument of the form I<host>B<:>I<port> specifies that the
# daemon should listen on the specified I<host> address and I<port>
# for connections.  if I<host> is omitted it defaults to B<127.0.0.1>.
#
def cmd_listen(args):
  if len(args) != 1:
    raise GetoptError, "expected a port"
  arg = args[0]
  if arg == '-':
    from cs.venti.stream import StreamDaemon
    daemon = StreamDaemon(S, sys.stdin, sys.stdout)
    daemon.join()
  else:
    cpos = arg.rfind(':')
    if cpos >= 0:
      host = arg[:cpos]
      port = arg[cpos+1:]
      if len(host) == 0:
        host = '127.0.0.1'
      port = int(port)
      import cs.venti.tcp
      with cs.venti.tcp.Server((host, port), S) as srv:
        srv.serve_forever()
    else:
      raise GetoptError, "invalid listen argument, I expect \"-\" or \"[host]:port\", got \"%s\"" % (arg,)
  return 0

# =item B<ls> [B<-R>] I<dirrefs...>
#
# Do a directory listing of the specified I<dirrefs>.
# The B<-R> (recursive) option requests a recurive directory listing.
#
def cmd_ls(args):
  recurse = False
  if args and args[0] == "-R":
    recurse = True
    args.pop(0)
  if not args:
    raise GetoptError, "missing dirrefs"
  first = True
  for path in args:
    if first:
      first = False
    else:
      print
    D, name = resolve(path)
    if name is not None:
      D = D.chdir1(name)
    ls(path, D, recurse, sys.stdout)
  return 0

# =item B<mount> I<dirref> I<mountpoint>
#
# B<INCOMPLETE>.
# Mount the specified I<dirref> as on the specified I<mountpoint> directory.
# Requires FUSE support.
#
def cmd_mount(args):
  if len(args) != 2:
    raise GetoptError, "expected dirref and mountpoint"
  dirref, mountpoint = args
  print "mount", args[0], args[1], "..."
  if not os.path.isdir(mountpoint):
    error("%s: mountpoint is not a directory", mountpoint)
    return 1
  E = S.namei(args[0]+'/')
  if not E.isdir:
    error("%s: dirref - expected directory, not file", dirref)
    return 1
  import cs.venti.vtfuse
  cs.venti.vtfuse.fusemount(args[1], S, E)
  return 0

# =item B<pull> I<stores...>
#
# Update our store with all the available content from the specified I<stores>.
# Note that some stores may not list all their content, or any.
# This is mostly useful for updating a master store from a store
# which has been updated offline.
#
def cmd_pull(args):
  if not args:
    raise GetoptError, "missing stores"
  raise NotImplementedError

# =item B<scan> I<datafile>
#
# Read the specified I<datafile> as a vt block storage file,
# a sequence of compressed data blocks.
# Report on standard output
# the block hashcode, I<datafile> file offset and compressed size.
#
def cmd_scan(args):
  if len(args) != 1:
    raise GetoptError, "missing datafile"
  datafile = args[0]
  from cs.venti.datafile import DataFile
  from cs.venti.hash import Hash_SHA1
  with Pfx(datafile):
    dfp = DataFile(datafile)
    for offset, flags, data in dfp.scanData():
      print Hash_SHA1.fromData(data), offset, flags, len(data)
    dfp.close()
  return 0

# =item B<unpack> I<dirrefs...>
#
# Unpack the directory specified by each I<dirref> into the current
# working directory.
# This is the inverse of the B<pack> command.
# Currently, to unpack a B<.vt> file the most succinct command is this:
#
#   vt unpack `awk '{ dirref=$1 } END { print dirref }' file.vt`
#
def cmd_unpack(args):
  if len(args) < 1:
    raise GetoptError, "missing dirrefs"
  xit = 0
  for path in args:
    with (path):
      D, name = resolve(path)
      if len(name) > 0:
        D = D.chdir1(name)
      for subD, _, files in D.walk(topdown=True):
        with subD:
          if len(subD.path) > 0 and not os.path.isdir(subD.path):
            print "mkdir", subD.path
            os.makedirs(subD.path)
          files.sort()
          for fname in files:
            with fname:
              if len(fname) == 0 or fname == '.' or fname == '..' or '/' in fname:
                error("illegal filename")
              fpath = os.path.join(subD.path, fname)
              with open(fpath, mode='w') as outfp:
                for b in subD[fname].getBlock().leaves(S):
                  outfp.write(b)
  return xit

# =back
#

def lsDirent(fp, E, name):
  B = E.getBlock()
  st = E.stat()
  ##print "st=%s" % (st,)
  st_mode, st_ino, st_dev, st_nlink, st_uid, st_gid, st_size, \
    st_atime, st_mtime, st_ctime = st
  ##print "st_mtime=%s" % `st_mtime`
  ##print "st_size=%s" % `st_size`
  ##print "name=%s" % `name`
  t = datetime.datetime.fromtimestamp(int(st_mtime))
  fp.write("%c %-41s %s %-6d %s\n" \
           % (('d' if E.isdir() else 'f'),
              B, t, st_size, name))

def ls(path, D, recurse, fp=None):
  if fp is None:
    fp = sys.stdout
  fp.write(path)
  fp.write(":\n")
  if not recurse:
    debug("ls(): getting dirs and files...")
    names = D.dirs()+D.files()
    debug("ls(): got dirs and files = %s" % (names,))
    names.sort()
    for name in names:
      debug("ls(): D=%s (%s), name=%s" % (D, type(D), name))
      E = D[name]
      lsDirent(fp, E, name)
  else:
    dirs = D.dirs()
    dirs.sort()
    files = D.files()
    files.sort()
    for name in files:
      E = D[name]
      lsDirent(fp, E, name)
      assert not E.isdir(), name+" should not be a directory!"
    for name in dirs:
      ls(os.path.join(path, name), D.chdir1(name), recurse, fp)

def cat(path, fp=None):
  if fp is None:
    fp = sys.stdout
  D, name = resolve(path)
  if name is not None:
    D = D[name]
  block = D.getBlock()
  for B in block.leaves():
    fp.write(B.blockdata())

if __name__ == '__main__':
  sys.exit(main(sys.argv))

# =head1 EXAMPLES
#
# Run a daemon for a master store:
#
#  vt -C - -S /var/spool/venti listen :9999
#
# Store a directory in that store:
#
#  vt -S tcp:127.0.0.1:9999 vt pack directory-name
#
# Run a local store on a roaming laptop with internet connectivity,
# pushing updates back to the master store, keeping a local on-disc cache
# in B<~/.venti/store>:
#
#  vt -C ~/.venti/store -M -S '|exec ssh home-server exec nc 127.0.0.1 9999' listen 9999
#
# Use the store on the roaming laptop via the local daemon:
#
#  VT_STORE=tcp:127.0.0.1:9999
#  export VT_STORE
#  vt command...
#
# Use the remote store and local cache without an intermediate daemon:
#
#  VT_STORE='|exec ssh home-server exec nc 127.0.0.1 9999'
#  VT_STORE_CACHE=$HOME/.venti/store
#  export VT_STORE VT_STORE_CACHE
#  vt command...
#
# This last has more efficient operations at the price of a larger startup
# latency (the ssh connection) and the downside that only one command can
# use the cache store at a time because it is not a sharable data structure
# except via a vt daemon.
#
# =head1 BUGS
#
# The TODO list is very long, see:
#
#  http://csbp.backpackit.com/pub/1356606
#
# The command does not cope well with an incomplete store if it traverses
# into the missing portion;
# one example is using a cache without the more complete backend master store.
#
# =head1 ENVIRONMENT VARIABLES
#
# B<VT_STORE>, the default store to use.
#
# B<VT_STORE_CACHE>, a default cache store.
#
# =head1 SEE ALSO
#
# The Venti file storage system: http://en.wikipedia.org/wiki/Venti
#
# =head1 AUTHOR
#
# Cameron Simpson E<lt>cs@zip.com.auE<gt>
#
