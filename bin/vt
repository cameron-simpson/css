#!/usr/bin/python -tt
#
# Command script for venti-ish implementation.
#       - Cameron Simpson <cs@zip.com.au> 01may2007
#
# =head1 NAME
#
# vt - access vt stores, a Venti-like content addressed storage pool
#
# =head1 SYNOPSIS
#
#   vt [options...] cat filerefs...
#   vt [options...] catblock [-i] hashcodes...
#   vt [options...] listen port
#   vt [options...] ls [-R] dirrefs...
#   vt [options...] mount dirref mountpoint
#   vt [options...] scan datafile
#   vt [options...] pack paths...
#   vt [options...] pack -o file.vt path
#   vt [options...] pull stores...
#   vt [options...] unpack dirrefs...
#
# =head1 DESCRIPTION
#
# I<vt> is a command accessing vt stores in various ways.
#
# A store is a content addressed pool of blocks
# with a filesystem abstraction layered on top of it.
#

from sys import argv, exit, stdin, stderr, stdout, exit
import os
import os.path
import atexit
from getopt import getopt, GetoptError
import datetime
from cs.venti import tohex, fromhex
from cs.venti.store import Store, pullFrom
from cs.venti.cache import CacheStore, MemCacheStore
from cs.misc import cmd, cmderr, setcmd, warn, debug, progress
import cs.upd; cs.upd.default()

usage='''Usage:
  %s [options...] cat filerefs...
  %s [options...] catblock [-i] hashcodes...
  %s [options...] listen port
  %s [options...] ls [-R] dirrefs...
  %s [options...] mount dirref mountpoint
  %s [options...] scan datafile
  %s [options...] pack paths...
  %s [options...] pack -o file.vt path
  %s [options...] pull stores...
  %s [options...] unpack dirrefs...
  Options:
    -C store    Use this as a front end cache store.
                "-" means no front end cache.
    -M          Don't use an additional MemCacheStore front end.
    -S store    Specify the store to use:
                  /path/to/dir  GDBMStore
                  tcp:[host]:port TCPStore
                  |sh-command   StreamStore via sh-command
''' % (cmd,cmd,cmd,cmd,cmd,cmd,cmd,cmd,cmd,cmd)

badopts=False

dflt_cache=os.environ.get('VT_STORE_CACHE')
dflt_vt_store=os.environ.get('VT_STORE')
useMemCache=True

S=None
def closeStore():
  if S is not None:
    S.close()
atexit.register(closeStore)

try:
  opts, args = getopt(argv[1:],'C:MS:')
except GetoptError, e:
  cmderr("unrecognised option: %s: %s"% (e.opt, e.msg))
  badopts=True
  opts, args = (), ()

# =head1 OPTIONS
#
# =over 4
#
for (opt,val) in opts:
  # =item B<-C> I<store>
  #
  # Specify a caching store.
  # The special name "-" means no caching store should be used.
  # If B<-C> is not used
  # the environment variable B<VT_STORE_CACHE> may specify the caching store.
  #
  if opt == '-C':
    if val == '-':
      dflt_cache=None
    else:
      dflt_cache=val
  # =item B<-M>
  #
  # Do not use the in-memory caching store.
  # Default is to place an in-memory cache ahead of the other stores.
  #
  elif opt == '-M':
    useMemCache=False
  # =item B<-S> I<store>
  #
  # Use the specified I<store>.
  # If B<-S> is not used
  # the environment variable B<VT_STORE> specifies the store.
  #
  elif opt == '-S':
    dflt_vt_store=val
  else:
    assert False, "unsupported option: %s" % opt

# =back
#
# =head1 Store Names
#
# Three of four planned store names are supported at present:
#
# =over 4
#
# =item B</>I<pathname>
#
# A full path to a directory specifies a local filesystem store
# in the directory B</>I<pathname>.
#
# =item B<tcp:>[I<host>]B<:>I<port>
#
# A name commencing with B<tcp:> specifies a TCP connection to a vt daemon
# listening on the specified I<host> and I<port>.
# If I<host> is omitted, B<127.0.0.1> is assumed.
#
# =item B<unix:/>I<pathname>
#
# B<UNIMPLEMENTED>.
# A name commencing with B<unix:> specifies the pathname of a UNIX domain socket
# on which a vt daemon is listening.
#
# =item B<|>I<shell-command>
#
# A name commencing with shell pipe symbol specifies a proxy command
# to connect to a vt daemon. The command string is handed to B</bin/sh>
# and should accept vt requests on standard input and write vt responses to
# standard output.
#
# =back
#

if len(args) < 1:
  cmderr("missing command")
  badopts=True
  op=None
else:
  # =head1 COMMANDS
  #
  # =over 4
  #
  op=args.pop(0)
  setcmd("%s: %s" % (cmd,op))
  if op == "cat":
    # =item B<cat> I<filerefs...>
    #
    # Emit the data content of the supplied I<filerefs> on the standard output.
    #
    if len(args) < 1:
      cmderr("missing filerefs")
      badopts=True
  elif op == "catblock":
    # =item B<catblock> [B<-i>] I<hashcodes...>
    #
    # Emit the content of the blocks specified by the supplied I<hashcodes>.
    # If the B<-i> (indirect) option is supplied,
    # consider the hashcode to specify an indirect block and emit
    # the data content of the leaf blocks.
    #
    indirect=False
    if len(args) > 0 and args[0] == "-i":
      indirect=True
      args.pop(0)
    if len(args) < 1:
      cmderr("missing hashcodes")
      badopts=True
  elif op == "listen":
    # =item B<listen> {B<->|[I<host>]B<:>I<port>}
    #
    # Start a vt daemon.
    #
    # The argument "-" specifies a single use daemon reading vt requests from
    # its standard input and writing replies to its standard output,
    # as it might run from inetd(8) or xinetd(8), or directly from a proxy shell command.
    #
    # An argument of the form I<host>B<:>I<port> specifies that the daemon
    # should listen on the specified I<host> address and I<port> for connections.
    # if I<host> is omitted it defaults to B<127.0.0.1>.
    #
    if len(args) != 1:
      cmderr("expected a port")
      badopts=True
  elif op == "ls":
    # =item B<ls> [B<-R>] I<dirrefs...>
    #
    # Do a directory listing of the specified I<dirrefs>.
    # The B<-R> (recursive) option requests a recurive directory listing.
    #
    recurse=False
    if len(args) > 0 and args[0] == "-R":
      recurse=True
      args.pop(0)
    if len(args) < 1:
      cmderr("missing dirrefs")
      badopts=True
  elif op == "mount":
    # =item B<mount> I<dirref> I<mountpoint>
    #
    # B<INCOMPLETE>.
    # Mount the specified I<dirref> as on the specified I<mountpoint> directory.
    # Requires FUSE support.
    #
    if len(args) != 2:
      cmderr("expected dirref and mountpoint")
      badopts=True
  elif op == "pack":
    # =item B<pack> {B<-o> I<file.vt> I<pathname> | I<pathnames...>}
    #
    # Store each specified I<pathname> in the store.
    #
    # With the B<-o> (output) option, store a single pathname
    # in the store and record the resulting I<dirref> in the file I<file.vt>.
    # If the file I<file.vt> already exists,
    # do an incremental store against the last I<dirref> currently stored in the I<file.vt>;
    # files with the same size and mtime in I<pathname> as in their copies in the store
    # are not opened - they are presumed to be unchanged.
    # This is similar to the vac(1) command in the Venti system.
    #
    # Without the B<-o> option,
    # each I<pathname> is stored and the resulting I<dirref> reported on the standard output.
    #
    if len(args) > 0 and args[0] == "-o":
      if len(args) < 2:
        cmderr("-o: missing file.vt")
        badopts=True
      elif len(args) < 3:
        cmderr("missing path")
        badopts=True
      elif len(args) > 3:
        cmderr("extra arguments after path: %s" % " ".join(args[3:]))
        badopts=True
    elif len(args) < 1:
      cmderr("missing paths")
      badopts=True
  elif op == "pull":
    # =item B<pull> I<stores...>
    #
    # Update our store with all the available content from the specified I<stores>.
    # Note that some stores will not list all their content, or any.
    # This is mostly useful for updating a master store from a store which has been updated offline.
    #
    if len(args) < 1:
      cmderr("missing stores")
      badopts=True
  elif op == "scan":
    # =item B<scan> I<datafile>
    #
    # Read the specified I<datafile> as a vt block storage file,
    # a sequence of compressed data blocks.
    # Report on standard output
    # the block hashcode, I<datafile> file offset and compressed size.
    #
    if len(args) != 1:
      cmderr("missing datafile")
      badopts=True
  elif op == "unpack":
    # =item B<unpack> I<dirrefs...>
    #
    # Unpack the directory specified by each I<dirref> into the current working directory.
    # This is the inverse of the B<pack> command.
    # Currently, to unpack a B<.vt> file the most succinct command is this:
    #
    #   vt unpack `awk '{ hash=$1 } END { print hash }' file.vt`
    #
    if len(args) < 1:
      cmderr("missing dirrefs")
      badopts=True
  else:
    cmderr("unrecognised command")
    badopts=True
  # =back
  #

if dflt_vt_store is None:
  if op != "scan":
    cmderr("no $VT_STORE and no -S option")
    badopts=True

if badopts:
  stderr.write(usage)
  exit(2)

S=Store(dflt_vt_store)

if dflt_cache is not None:
  ##progress("push cache store %s" % dflt_cache)
  C=Store(dflt_cache)
  S=CacheStore(S,C)

# put an in-memory cache in front of the main cache
if useMemCache:
  S=CacheStore(S,MemCacheStore())

##progress("S=%s"%S)

def gethexarg(path):
  slash=path.find('/')
  if slash < 0:
    hexarg=path
    path=''
  else:
    hexarg=path[:slash]
    slash+=1
    while slash < len(path) and path[slash] == '/':
      slash+=1
    path=path[slash:]
  from cs.venti.blocks import str2BlockRef
  debug("fromhex(%s)..." % hexarg)
  fhex=fromhex(hexarg)
  bref=str2BlockRef(fhex)
  return bref, path

def resolve(path, domkdir=False):
  bref, path = gethexarg(path)
  from cs.venti.fs import FS
  return FS(S,bref).root.resolve(path,domkdir)

def path2bref(path,domkdir=False):
  bref, path = gethexarg(path)
  debug("bref=%s, path=%s"%(bref,path))
  if len(path) > 0:
    from cs.venti.fs import FS
    F=FS(S,bref)
    debug("F=%s, F.root=%s" % (F,F.root))
    D, name = F.root.resolve(path,domkdir)
    if D is None or name not in D:
      debug("resolve fails")
      return None
    return D.name2bref(name)
  return bref

def vtopen(path, mode='r', domkdir=False):
  bref, path = gethexarg(path)
  if len(path) > 0:
    D, name = FS(S,bref).root.resolve(path,domkdir)
    return D.open(name,mode)
  import cs.venti.file
  return cs.venti.file.open(S,mode,bref)

def lsDirent(fp,E,name):
  bref=E.bref()
  st=E.stat()
  ##print "st=%s" % (st,)
  st_mode, st_ino, st_dev, st_nlink, st_uid, st_gid, st_size, \
    st_atime, st_mtime, st_ctime = st
  ##print "st_mtime=%s" % `st_mtime`
  ##print "st_size=%s" % `st_size`
  ##print "name=%s" % `name`
  t=datetime.datetime.fromtimestamp(int(st_mtime))
  fp.write("%c %-41s %s %-6d %s\n" \
           % (('d' if D.isdir(name) else 'f'),
              bref, t, st_size, name))

def ls(path,D,recurse,fp=None):
  if fp is None:
    fp=stdout
  ##warn("ls %s: bref=%s"%(path,("s:"+tohex(bref) if type(bref) is str else "bref.h:"+tohex(bref.h))))
  fp.write(path)
  fp.write(":\n")
  if not recurse:
    names=D.dirs()+D.files()
    names.sort()
    for name in names:
      E=D[name]
      lsDirent(fp,E,name)
  else:
    dirs=D.dirs(); dirs.sort()
    files=D.files(); files.sort()
    for name in files:
      E=D[name]
      lsDirent(fp,E,name)
      assert not D.isdir(name), name+" should not be a directory!"
    for name in dirs:
      ##fp.write("\n")
      ls(os.path.join(path,name),D.chdir1(name),recurse,fp)

def cat(path,fp=None):
  if fp is None:
    fp=stdout
  bref=path2bref(path)
  if bref is None:
    cmderr("%s: no such file or directory" % path)
  else:
    for b in bref.leaves(S):
      fp.write(b)

def storeDir(path,targetRef=None,ignoreTimes=False,deleteMissing=False,overWrite=False):
  from cs.venti.fs import FS
  import cs.venti.store
  assert isinstance(S, cs.venti.store.BasicStore), "S=%s"%S
  D=FS(S,targetRef).updateDir(path,
                    ignoreTimes=ignoreTimes,
                    deleteMissing=deleteMissing,
                    overWrite=overWrite)
  return D.sync()

if op == "pack":
  if len(args) == 0 or args[0] != '-o':
    from cs.venti.file import storeFile
    for path in args:
      if os.path.isdir(path):
        ref=storeDir(path)
      else:
        ##import cProfile
        ##cProfile.run("global ref; ref=storeFile(S,open(path))")
        ##print "ref=%s" % ref
        ref=storeFile(S,open(path))
      stdout.write(tohex(ref.encode()))
      if len(args) > 1:
        stdout.write('\t')
        stdout.write(path)
      stdout.write('\n')
  else:
    archive=args[1]
    path=args[2]
    from cs.venti.blocks import str2BlockRef
    import datetime
    if archive is None:
      archive="%s.vt" % os.path.basename(path)
    target=None
    if os.path.isfile(archive):
      hexarg=None
      for line in open(archive):
        assert line[-1] == '\n'
        words=line[:-1].strip().split(' ')
        if len(words) == 0:
          continue
        if words[0].startswith("#"):
          continue
        hexarg=words[0]
      if hexarg is not None:
        target=str2BlockRef(fromhex(hexarg))
    assert os.path.isdir(path)
    saved=storeDir(path,targetRef=target,ignoreTimes=False,deleteMissing=True,overWrite=True)
    open(archive,mode='a').write("%s %s %s\n" % (saved, datetime.datetime.now(), path))

elif op == "cat":
  for path in args:
    cat(path)

elif op == "catblock":
  for hexarg in args:
    if indirect:
      bl
    else:
      stdout.write(S[fromhex(hexarg)])

elif op == "scan":
  from cs.venti.datafile import scanFile
  for h, offset, zsize in scanFile(open(args[0])):
    print tohex(h), offset, zsize

elif op == "pull":
  for arg in args:
    pullFrom(S,Store(arg))

elif op == "listen":
  assert len(args) == 1
  arg=args[0]
  if arg == '-':
    from cs.venti.stream import StreamDaemon
    daemon=StreamDaemon(S,stdin,stdout)
    daemon.start()
    daemon.join()
  else:
    cpos=arg.rfind(':')
    if cpos >= 0:
      host=arg[:cpos]
      port=arg[cpos+1:]
      if len(host) == 0:
        host='127.0.0.1'
      port=int(port)
      import cs.venti.tcp
      srv=cs.venti.tcp.Server((host,port),S)
      srv.serve_forever()
    else:
      cmderr("invalid listen argument, I expect \"-\" or \"[host]:port\", got \"%s\"" % arg)
      exit(1)

elif op == "ls":
  first=True
  for path in args:
    if first:
      first=False
    else:
      print
    print "ls", path, "..."
    D, name = resolve(path)
    D=D.chdir1(name)
    ls(path,D,recurse,stdout)

elif op == "mount":
  print "mount", args[0], args[1], "..."
  if not os.path.isdir(args[1]):
    cmderr("%s: mountpoint is not a directory" % args[1])
    exit(1)
  E=S.namei(args[0]+'/')
  assert E.isdir, "%s: %s: expected directory, not file"%(cmd,args[0])
  import cs.venti.vtfuse
  cs.venti.vtfuse.fusemount(args[1],S,E)

elif op == "unpack":
  for path in args:
    D, name = resolve(path)
    if len(name) > 0:
      D=D.chdir1(name)
    for subD, dirs, files in D.walk(topdown=True):
      if len(subD.path) > 0 and not os.path.isdir(subD.path):
        print "mkdir", subD.path
        os.makedirs(subD.path)
      files.sort()
      for fname in files:
        assert len(fname) > 0 and fname != '.' and fname != '..' and fname.find('/') < 0, \
          "%s: unpack: %s: illegal filename \"%s\"" % (cmd, subD.path, fname)
        fpath=os.path.join(subD.path,fname)
        print "extract", fpath
        outfp=open(fpath,mode='w')
        for b in subD[fname].bref().leaves(S):
          outfp.write(b)
        outfp.close()

else:
  cmderr("unsupported command")
  exit(2)

S.close()
debug("%s: exit main command"%cmd)

# =head1 EXAMPLES
#
# Run a daemon for a master store:
#
#  vt -C - -S /var/spool/venti listen :9999
#
# Store a directory in that store:
#
#  vt -S tcp:127.0.0.1:9999 vt pack directory-name
#
# Run a local store on a roaming laptop with internet connectivity,
# pushing updates back to the master store, keeping a local on-disc cache
# in B<~/.venti/store>:
#
#  vt -C ~/.venti/store -M -S '|exec ssh home-server exec nc 127.0.0.1 9999' listen 9999
#
# Use the store on the roaming laptop via the local daemon:
#
#  VT_STORE=tcp:127.0.0.1:9999
#  export VT_STORE
#  vt command...
#
# Use the remote store and local cache without an intermediate daemon:
#
#  VT_STORE='|exec ssh home-server exec nc 127.0.0.1 9999'
#  VT_STORE_CACHE=$HOME/.venti/store
#  export VT_STORE VT_STORE_CACHE
#  vt command...
#
# This last has more efficient operations at the price of a larger startup
# latency (the ssh connection) and the downside that only one command can
# use the cache store at a time because it is not a sharable data structure
# except via a vt daemon.
#
# =head1 BUGS
#
# The TODO list is very long, see:
#
#  http://csbp.backpackit.com/pub/1356606
#
# The command does not cope well with an incomplete store if it traverses into the missing portion;
# one example is using a cache without the more complete backend master store.
#
# =head1 ENVIRONMENT VARIABLES
#
# B<VT_STORE>, the default store to use.
#
# B<VT_STORE_CACHE>, a default cache store.
#
# =head1 SEE ALSO
#
# The Venti file storage system: http://en.wikipedia.org/wiki/Venti
#
# =head1 AUTHOR
#
# Cameron Simpson E<lt>cs@zip.com.auE<gt>
#
