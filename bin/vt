#!/usr/bin/env py30+
#
# Command script for venti-ish implementation.
#       - Cameron Simpson <cs@zip.com.au> 01may2007
#
# =head1 NAME
#
# vt - access vt stores, a Venti-like content addressed storage pool
#
# =head1 SYNOPSIS
#
#   vt [options...] ar tar-options paths...
#   vt [options...] cat filerefs...
#   vt [options...] catblock [-i] hashcodes...
#   vt [options...] listen {-|host:port}
#   vt [options...] ls [-R] dirrefs...
#   vt [options...] mount dirref mountpoint
#   vt [options...] scan datafile
#   vt [options...] pull stores...
#   vt [options...] unpack dirrefs...
#
# =head1 DESCRIPTION
#
# I<vt> is a command accessing vt stores in various ways.
#
# A store is a content addressed pool of blocks
# with a filesystem abstraction layered on top of it.
#

from __future__ import with_statement
import sys
import os
import os.path
from getopt import getopt, GetoptError
import datetime
import shutil
from cs.debug import ifdebug, dump_debug_threads
from cs.lex import hexify
import cs.logutils
from cs.logutils import Pfx, exception, error, warning, debug, setup_logging, logTo, D, X, nl
from cs.venti import totext, fromtext, defaults
from cs.venti.block import Block, IndirectBlock, dump_block
from cs.venti.store import Store
from cs.venti.cache import CacheStore, MemoryCacheStore
from cs.venti.paths import dirent_dir, dirent_file, dirent_resolve, resolve
from cs.venti.archive import CopyModes, update_archive, toc_archive, last_Dirent, copy_out_dir

def main(argv):
  setup_logging(upd_mode=False)
  cmd = cs.logutils.cmd
  usage = '''Usage:
    %s [options...] ar tar-options paths..
    %s [options...] cat filerefs...
    %s [options...] catblock [-i] hashcodes...
    %s [options...] dump filerefs
    %s [options...] listen {-|host:port}
    %s [options...] ls [-R] dirrefs...
    %s [options...] mount dirref mountpoint
    %s [options...] pack paths...
    %s [options...] scan datafile
    %s [options...] pull stores...
    %s [options...] unpack dirrefs...
    Options:
      -C store    Use this as a front end cache store.
                  "-" means no front end cache.
      -M          Don't use an additional MemoryCacheStore front end.
      -S store    Specify the store to use:
                    /path/to/dir  GDBMStore
                    tcp:[host]:port TCPStore
                    |sh-command   StreamStore via sh-command
      -q          Quiet; not verbose. Default if stdout is not a tty.
      -v          Verbose; not quiet. Default it stdout is a tty.
''' % (cmd, cmd, cmd, cmd, cmd, cmd, cmd, cmd, cmd, cmd, cmd)

  badopts = False

  # verbose if stdout is a tty
  try:
    verbose = sys.stdout.isatty()
  except:
    verbose = False

  dflt_cache = os.environ.get('VT_STORE_CACHE')
  dflt_vt_store = os.environ.get('VT_STORE')
  dflt_log = os.environ.get('VT_LOGFILE')
  useMemoryCacheStore = True

  try:
    opts, args = getopt(argv[1:], 'C:MS:qv')
  except GetoptError as e:
    error("unrecognised option: %s: %s"% (e.opt, e.msg))
    badopts = True
    opts, args = [], []

  # =head1 OPTIONS
  #
  # =over 4
  #
  for opt, val in opts:
    # =item B<-C> I<store>
    #
    # Specify a caching store.
    # The special name "-" means no caching store should be used.
    # If B<-C> is not used
    # the environment variable B<VT_STORE_CACHE> may specify the caching store.
    #
    if opt == '-C':
      if val == '-':
        dflt_cache = None
      else:
        dflt_cache = val
    # =item B<-M>
    #
    # Do not use the in-memory caching store.
    # Default is to place an in-memory cache ahead of the other stores.
    #
    elif opt == '-M':
      useMemoryCacheStore = False
    # =item B<-S> I<store>
    #
    # Use the specified I<store>.
    # If B<-S> is not used
    # the environment variable B<VT_STORE> specifies the store.
    #
    elif opt == '-S':
      dflt_vt_store = val
    # =item B<-q>
    #
    # Quiet; not verbose. Default if stdout is not a tty.
    #
    elif opt == '-q':
      verbose = False
    # =item B<-v>
    #
    # Verbose; not quiet. Default it stdout is a tty.
    #
    elif opt == '-v':
      verbose = True
    else:
      raise RuntimeError("unhandled option: %s" % (opt,))

  # =back
  #
  # =head1 Store Names
  #
  # Three of four planned store names are supported at present:
  #
  # =over 4
  #
  # =item B</>I<pathname>
  #
  # A full path to a directory specifies a local filesystem store
  # in the directory B</>I<pathname>.
  #
  # =item B<tcp:>[I<host>]B<:>I<port>
  #
  # A name commencing with B<tcp:> specifies a TCP connection to a vt daemon
  # listening on the specified I<host> and I<port>.
  # If I<host> is omitted, B<127.0.0.1> is assumed.
  #
  # =item B<unix:/>I<pathname>
  #
  # B<UNIMPLEMENTED>.
  # A name commencing with B<unix:> specifies the pathname of a UNIX domain
  # socket on which a vt daemon is listening.
  #
  # =item B<|>I<shell-command>
  #
  # A name commencing with shell pipe symbol specifies a proxy command
  # to connect to a vt daemon. The command string is handed to B</bin/sh>
  # and should accept vt requests on standard input and write vt responses to
  # standard output.
  #
  # =back
  #

  if dflt_log is not None:
    logTo(dflt_log, delay=True)

  # log message function(msg, *args)
  if verbose:
    log = nl
  else:
    log = silent

  xit = None
  S = None

  if len(args) < 1:
    error("missing command")
    badopts = True
  else:
    op = args.pop(0)
    with Pfx(op):
      try:
        op_func = getattr(sys.modules[__name__], "cmd_" + op)
      except AttributeError:
        error("unknown operation \"%s\"", op)
        badopts = True
      else:
        if op in ("scan", "init"):
          # run without a context store
          try:
            xit = op_func(args)
          except GetoptError as e:
            error("%s", e)
            badopts = True
        else:
          if dflt_vt_store is None:
            error("no $VT_STORE and no -S option")
            badopts = True
          else:
            try:
              S = Store(dflt_vt_store)
            except:
              exception("can't open store \"%s\"", dflt_vt_store)
              badopts = True
            else:
              if dflt_cache is not None:
                try:
                  C = Store(dflt_cache)
                except:
                  exception("can't open cache store \"%s\"", dflt_cache)
                  badopts = True
                else:
                  S = CacheStore(S, C)
              if not badopts:
                # put an in-memory cache in front of the main cache
                if useMemoryCacheStore:
                  S = CacheStore(S, MemoryCacheStore())
                with S:
                  try:
                    xit = op_func(args, verbose=verbose, log=log)
                  except GetoptError as e:
                    error("%s", e)
                    badopts = True

  if badopts:
    sys.stderr.write(usage)
    return 2

  if not isinstance(xit, int):
    raise RuntimeError("exit code not set by operation: %r" % (xit,))

  if ifdebug():
    dump_debug_threads()

  return xit

# =head1 COMMANDS
#
# =over 4
#

# =item B<ar> tar-like-options I<pathnames...>
#
# Archive or retrieve files. Options: B<v> - verbose, B<A> - all
# files, not just ones with new size/mtime, B<f> - specify archive
# file.
#
def cmd_ar(args, verbose=None, log=None):
  if len(args) < 1:
    raise GetoptError("missing options")
  opts = args.pop(0)
  if len(opts) == 0:
    raise GetoptError("empty options")

  badopts = False
  modes = CopyModes(trust_size_mtime=True)
  modes.trust_size_mtime = True
  arpath = '-'
  mode = opts[0]
  for opt in opts[1:]:
    if opt == 'f':
      arpath = args.pop(0)
    elif opt == 'q':
      verbose = False
    elif opt == 'v':
      verbose = True
    elif opt == 'A':
      modes.trust_size_mtime = False
    else:
      error("%s: unsupported option", opt)
      badopts = True

  if (mode == 'c' or mode == 'u') and len(args) < 1:
    error("missing pathnames")
    badopts = True

  if badopts:
    raise GetoptError("bad options")

  # log message function(msg, *args)
  if verbose:
    log = nl
  else:
    log = silent

  xit = 0
  
  if mode == 't':
    if args:
      ospaths = args
    else:
      ospaths = None
    with Pfx("tf %s" % (arpath,)):
      toc_archive(arpath, ospaths)
  elif mode == 'c' or mode == 'u':
    for ospath in args:
      try:
        update_archive(arpath, ospath, modes, create_archive=True, arsubpath=ospath, log=log)
      except IOError as e:
        error("archive %s: %s" % (ospath, e))
        xit = 1
  elif mode == 'x':
    if args:
      ospaths = args
    else:
      ospaths = ('.',)
    xit = 0
    with Pfx("xf %s" % (arpath,)):
      with Pfx(arpath):
        last_entry = last_Dirent(arpath)
        if last_entry is None:
          error("no entries in archive")
          return 1
      when, rootE = last_entry
      for ospath in ospaths:
        with Pfx(ospath):
          E, Eparent, tail = resolve(rootE, ospath)
          if tail:
            error("not in archive")
            xit = 1
            continue
          log("ar x %s", ospath)
          if E.isdir:
            with Pfx("makedirs"):
              try:
                os.makedirs(ospath, exist_ok=True)
              except OSError as e:
                error("%s", e)
                xit = 1
                continue
            copy_out_dir(E, ospath, modes, log=log)
          else:
            if os.path.exists(ospath):
              error("already exists")
              xit = 1
              continue
            osparent = os.path.dirname(ospath)
            if not os.path.isdir(osparent):
              with Pfx("makedirs(%s)", osparent):
                try:
                  os.makedirs(osparent)
                except OSError as e:
                  error("%s", e)
                  xit = 1
                  continue
            copy_out_file(E, ospath, modes, log=log)
  else:
    raise GetoptError("%s: unsupported mode" % (mode,))

  return xit

# =item B<cat> I<filerefs...>
#
# Emit the data content of the supplied I<filerefs> on the standard output.
#
def cmd_cat(args, verbose=None, log=None):
  if not args:
    raise GetoptError("missing filerefs")
  for path in args:
    cat(path)
  return 0

# =item B<catblock> [B<-i>] I<hashcodes...>
#
# Emit the content of the blocks specified by the supplied I<hashcodes>.
# If the B<-i> (indirect) option is supplied,
# consider the hashcode to specify an indirect block and emit
# the data content of the leaf blocks.
#
def cmd_catblock(args, verbose=None, log=None):
  indirect = False
  if len(args) > 0 and args[0] == "-i":
    indirect = True
    args.pop(0)
  if not args:
    raise GetoptError("missing hashcodes")
  for hctext in args:
    h = S.hashclass(fromtext(hctext))
    if indirect:
      B = IndirectBlock(hashcode)
    else:
      B = Block(hashcode)
    for subB in B.leaves:
      sys.stdout.write(subB.data)
  return 0

# =item B<dump> I<filerefs...>
#
# Do a Block dump of the filerefs.
#
def cmd_dump(args, verbose=None, log=None):
  if not args:
    raise GetoptError("missing filerefs")
  for path in args:
    dump(path)
  return 0

# =item B<init> <dirpath>
#
# Initialise a directory for use as a store, using the GDBM backend.
#
def cmd_init(args, verbose=None, log=None):
  if not args:
    raise GetoptError("missing dirpath")
  dirpath = args.pop(0)
  if args:
    raise GetoptError("extra arguments after dirpath: %s" % (' '.join(args),))
  with Pfx(dirpath):
    if not os.path.isdir(dirpath):
      raise GetoptError("not a directory")
    with Store("file:"+dirpath):
      pass
  return 0

# =item B<listen> {B<->|[I<host>]B<:>I<port>}
#
# Start a vt daemon.
#
# The argument "-" specifies a single use daemon reading vt
# requests from its standard input and writing replies to its
# standard output, as it might run from inetd(8) or
# xinetd(8), or directly from a proxy shell command.
#
# An argument of the form I<host>B<:>I<port> specifies that the
# daemon should listen on the specified I<host> address and I<port>
# for connections.  if I<host> is omitted it defaults to B<127.0.0.1>.
#
def cmd_listen(args, verbose=None, log=None):
  if len(args) != 1:
    raise GetoptError("expected a port")
  arg = args[0]
  if arg == '-':
    from cs.venti.stream import StreamDaemon
    RS = StreamStore("%s listen -" % (cmd,), sys.stdin, sys.stdout,
                     local_store=S)
    RS.join()
  else:
    cpos = arg.rfind(':')
    if cpos >= 0:
      host = arg[:cpos]
      port = arg[cpos+1:]
      if len(host) == 0:
        host = '127.0.0.1'
      port = int(port)
      import cs.venti.tcp
      with cs.venti.tcp.Server((host, port), S) as srv:
        srv.serve_forever()
    else:
      raise GetoptError("invalid listen argument, I expect \"-\" or \"[host]:port\", got \"%s\"" % (arg,))
  return 0

# =item B<ls> [B<-R>] I<dirrefs...>
#
# Do a directory listing of the specified I<dirrefs>.
# The B<-R> (recursive) option requests a recurive directory listing.
#
def cmd_ls(args, verbose=None, log=None):
  recurse = False
  if args and args[0] == "-R":
    recurse = True
    args.pop(0)
  if not args:
    raise GetoptError("missing dirrefs")
  first = True
  for path in args:
    if first:
      first = False
    else:
      print
    D = dirent_dir(path)
    ls(path, D, recurse, sys.stdout)
  return 0

# =item B<mount> I<dirref> I<mountpoint>
#
# B<INCOMPLETE>.
# Mount the specified I<dirref> as on the specified I<mountpoint> directory.
# Requires FUSE support.
#
def cmd_mount(args, verbose=None, log=None):
  if len(args) != 2:
    raise GetoptError("expected dirref and mountpoint")
  dirref, mountpoint = args
  print("mount", args[0], args[1], "...")
  if not os.path.isdir(mountpoint):
    error("%s: mountpoint is not a directory", mountpoint)
    return 1
  S = defaults.S
  E = S.namei(args[0]+'/')
  if not E.isdir:
    error("%s: dirref - expected directory, not file", dirref)
    return 1
  import cs.venti.vtfuse
  cs.venti.vtfuse.mount(args[1], E, S)
  return 0

# =item B<pack> I<paths>...
#
# Replace each I<path> with an archive file I<path>B<.vt> referring
# to the stored content of I<path>.
#
def cmd_pack(args, verbose=None, log=None):
  if not args:
    raise GetoptError("missing paths")
  xit = 0
  modes = CopyModes(trust_size_mtime=True)
  
  for ospath in args:
    with Pfx(ospath):
      if not os.path.exists(ospath):
        error("missing")
        xit = 1
        continue
      arpath = ospath + '.vt'
      try:
        update_archive(arpath, ospath, modes, create_archive=True, log=log)
      except IOError as e:
        error("%s" % (e,))
        xit = 1
        continue
      log("remove %r", ospath)
      if os.path.isdir(ospath):
        shutil.rmtree(ospath)
      else:
        os.remove(ospath)
  return xit

# =item B<pull> I<stores...>
#
# Update our store with all the available content from the specified I<stores>.
# Note that some stores may not list all their content, or any.
# This is mostly useful for updating a master store from a store
# which has been updated offline.
#
def cmd_pull(args, verbose=None, log=None):
  if not args:
    raise GetoptError("missing stores")
  raise NotImplementedError

# =item B<scan> I<datafile>
#
# Read the specified I<datafile> as a vt block storage file,
# a sequence of compressed data blocks.
# Report on standard output
# the block hashcode, I<datafile> file offset and compressed size.
#
def cmd_scan(args, verbose=None, log=None):
  if len(args) != 1:
    raise GetoptError("missing datafile")
  datafile = args[0]
  from cs.venti.datafile import DataFile
  from cs.venti.hash import Hash_SHA1
  with Pfx(datafile):
    dfp = DataFile(datafile)
    for offset, flags, data in dfp.scanData():
      print(Hash_SHA1.fromData(data), offset, flags, len(data))
    dfp.close()
  return 0

# =item B<unpack> I<archive>B<.vt>
#
# Unpack the archive file I<archive>B<.vt> as I<archive>.
#
def cmd_unpack(args, verbose=None, log=None):
  if len(args) < 1:
    raise GetoptError("missing archive name")
  arpath = args.pop(0)
  arbase, arext = os.path.splitext(arpath)
  X("arbase=%r, arext=%r", arbase, arext)
  if arext != '.vt':
    raise GetoptError("archive name does not end in .vt: %r" % (arpath,))
  if len(args) > 0:
    raise GetoptError("extra arguments after archive name %r" % (arpath,))
  if os.path.exists(arbase):
    error("archive base already exists: %r", arbase)
    return 1
  with Pfx(arpath):
    last_entry = last_Dirent(arpath)
    if last_entry is None:
      error("no entries in archive")
      return 1
  when, rootE = last_entry
  with Pfx(arbase):
    if rootE.isdir:
      os.mkdir(arbase)
      copy_out_dir(rootE, arbase, CopyModes(do_mkdir=True), log=log)
    else:
      copy_out_file(rootE, arbase, log=log)
  return 0

# =back
#

def lsDirent(fp, E, name):
  ''' Transcribe a Dirent as an ls-style listing.
  '''
  B = E.block
  st = E.stat()
  st_mode, st_ino, st_dev, st_nlink, st_uid, st_gid, st_size, \
    st_atime, st_mtime, st_ctime = st
  t = datetime.datetime.fromtimestamp(int(st_mtime))
  fp.write("%c %-41s %s %6d %s\n" \
           % (('d' if E.isdir else 'f'),
              hexify(B.hashcode), t, st_size, name))

def ls(path, D, recurse, fp=None):
  ''' Do an ls style directory listing with optional recursion.
  '''
  if fp is None:
    fp = sys.stdout
  fp.write('\n')
  fp.write(path)
  fp.write(":\n")
  if not recurse:
    debug("ls(): getting dirs and files...")
    names = D.dirs()+D.files()
    debug("ls(): got dirs and files = %s" % (names,))
    names.sort()
    for name in names:
      debug("ls(): D=%s (%s), name=%s" % (D, type(D), name))
      E = D[name]
      lsDirent(fp, E, name)
  else:
    dirs = D.dirs()
    dirs.sort()
    files = D.files()
    files.sort()
    for name in files:
      E = D[name]
      if E.isdir:
        warning("%s: expected file, found directory", name)
      lsDirent(fp, E, name)
    for name in dirs:
      ls(os.path.join(path, name), D.chdir1(name), recurse, fp)

def cat(path, fp=None):
  ''' Write a file to the output, like cat(1).
  '''
  if fp is None:
    with os.fdopen(sys.stdout.fileno(), "wb") as bfp:
      return cat(path, bfp)
  else:
    F = dirent_file(path)
    block = F.block
    for B in block.leaves:
      fp.write(B.data)

def dump(path, fp=None):
  if fp is None:
    fp = sys.stdout
  E, subname = dirent_resolve(path)
  if subname:
    E = E[subname]
  dump_block(E.block, fp)

def silent(msg, *args, file=None):
  ''' Dummy function to discard messages.
  '''
  pass

if __name__ == '__main__':
  sys.exit(main(sys.argv))

# =head1 EXAMPLES
#
# Run a daemon for a master store:
#
#  vt -C - -S /var/spool/venti listen :9999
#
# Store a directory in that store:
#
#  vt -S tcp:127.0.0.1:9999 vt pack directory-name
#
# Run a local store on a roaming laptop with internet connectivity,
# pushing updates back to the master store, keeping a local on-disc cache
# in B<~/.venti/store>:
#
#  vt -C ~/.venti/store -M -S '|exec ssh home-server exec nc 127.0.0.1 9999' listen 9999
#
# Use the store on the roaming laptop via the local daemon:
#
#  VT_STORE=tcp:127.0.0.1:9999
#  export VT_STORE
#  vt command...
#
# Use the remote store and local cache without an intermediate daemon:
#
#  VT_STORE='|exec ssh home-server exec nc 127.0.0.1 9999'
#  VT_STORE_CACHE=$HOME/.venti/store
#  export VT_STORE VT_STORE_CACHE
#  vt command...
#
# This last has more efficient operations at the price of a larger startup
# latency (the ssh connection) and the downside that only one command can
# use the cache store at a time because it is not a sharable data structure
# except via a vt daemon.
#
# =head1 BUGS
#
# The TODO list is very long, see:
#
#  http://csbp.backpackit.com/pub/1356606
#
# The command does not cope well with an incomplete store if it traverses
# into the missing portion;
# one example is using a cache without the more complete backend master store.
#
# =head1 ENVIRONMENT VARIABLES
#
# B<VT_STORE>, the default store to use.
#
# B<VT_STORE_CACHE>, a default cache store.
#
# =head1 SEE ALSO
#
# The Venti file storage system: http://en.wikipedia.org/wiki/Venti
#
# =head1 AUTHOR
#
# Cameron Simpson E<lt>cs@zip.com.auE<gt>
#
