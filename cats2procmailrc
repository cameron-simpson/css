#!/usr/bin/perl
#
# Convert my categories file to procmail recipes.
#	- Cameron Simpson <cs@zip.com.au> 02mar2001
#

=head1 NAME

cats2procmailrc - generate a procmail recipe from my mail categories file

=head1 SYNOPSIS

cats2procmailrc [B<-L>] [B<-a> I<alert>] [B<-m> I<maildomains>] [B<-t> I<type>] E<lt>categories E<gt>procmailrc

=head1 DESCRIPTION

I<cats2procmailrc> reads a human friendly mail category description file
and emits a matching procmail(1) recipe to implement it.
The intent it to have an extremely succinct file
of easily editable one line rules,
generally of the form:

	folder	tag	pattern

I build my B<.procmailrc> with the following myke(1) rule:

	procmailrc:	$@.pre $(HOME)/scripts/cats2procmailrc categories
		( cat $@.pre \
		  echo \
		  cats2procmailrc \\
		  	-a 'my-alert-cmd %' \\
		  	-t mh -m research.canon.com.au <categories \
		) >$@

Which starts with a few small manual rules from B<procmailrc.pre>
and adds the automatic rules by converting my categories file.

=head1 OPTIONS

=over 4

=item b<-L>

Put the tag into the B<X-Label> header field
instead of as a prefix to the subject line.

=item B<-a> I<alert>

Specify a shell command to run as the alert function (see L<FILE FORMAT> below),
such as mailblink(1).
The character percent (B<'%'>) is replaced by the I<folder> name.

=item B<-m> I<maildomains>

Specify the default mail domain for rule addresses lacking an B<@I<domain>>.
The default comes from the environment variable B<$SITENAME>.
In fact this may be a list of domains if you have some equvalents,
separated by commas.

=item B<-t> I<type>

Specify the default mailbox type.
If the mailbox exists the type is deduced automatically,
but otherwise uses this default, which may be one of
B<unix>, B<maildir> or B<mh>.
The default is B<unix>.

=back

=head1 FILE FORMAT

=head2 LINE FORMAT

Blank lines and lines beginning with an octothorpe ('#') are ignored.

Lines of the form:

	VARIABLE=value

are passed through unchanged.

Lines of the form:

	< filename

interpolate raw procmailrc files.

Other lines are of the form:

	[+][!]folder tag pattern
	[+][!]who@where tag pattern
	[+][!]|progname tag pattern

A leading plus sign (B<'+'>) means that this rule should be a continue rule,
and not abort processing.

A leading exclaimation mark (B<'!'>) means that mail items matching this rule
should generate an alert.
The alert can be any action you desire, such as the mailblink(1) command;
see the B<-a> option.
For me, this means a single line summary of the mail item
appears in yellow in a small log window
I have at the top of my screen for mail items I should read I<now>.

The I<folder> names the folder in which to place the mail item.
Normail UNIX mail files,
MH style directories and Maildir style directories are autodetetected.
If the I<folder> contains an "at" (B<@>) character
it is considered an email address
and the mail item is forwarded to that address instead of being dropped in a folder.

If instead of a I<folder>
a pipe (`B<|>') and a programs name are used
then the message is piped to the specified program.
The I<tag> is supplied as the sole argument to the I<program>.

The I<tag> is placed at the start of the mail's B<Subject> line for ready recognition in mixed folders.
The special tag dot (".") suppresses this action.

The I<pattern> selects the mail items.

=head2 Example Rules

The usual form is simply an address (see RFC822 and RFC2822)
to be present in the B<To>, B<CC> or B<BCC> header lines.
If the address string lacks an at ("@") then an at and the value of the environment variable B<$SITENAME>
is appended.
So I have rules like this:

	!attn	Personal	cs
	!attn	Personal	cameron@research.canon.com.au
	attn	EFF-Cafe-News   cafe-news@eff.org
	crypto  AUCrypto        aucrypto@suburbia.net

matching B<cs@zip.com.au>, B<cameron@research.canon.com.au>, B<cafe-news@eff.org>
and B<aucrypto@suburbia.net> respectively. The "Personal" items generate an alert.

It is also possible to select on a different header line
by prefixing the I<pattern> string with a header name, viz:

	applix  ApplixWare      sender:owner-applixware-list@applix.com

which selects for an address in the B<Sender> header line.

The I<pattern> may also be an arbitrary regular expression in egrep(1) syntax.
In this case the I<pattern> starts with a slash ("/")
and optionally ends in a slash, viz:

	!adzap  AdZap           subject:/(noads|add?[-  s]*zap|squid_?redir|zapp(er|ing)|wrapzap)/

which matches mail items with subjects regarding my adzap program.

A typical use of the "at" sign is in conjunction with the plus sign above
to copy particular mail items to another account while still delivering locally.
For example:

	+fred@that.isp.com . fred@this.isp.com
	fredmail Fred fred@this.isp.com

to accept mail aimed at B<fred@this.isp.com> and also copy it to B<fred@that.isp.com>.

=head1 ENVIRONMENT

MAILDIR, the directory containing mail folders.

SITENAME, the local mail domain (eg B<research.canon.com.au> for my current workplace).

=head1 SEE ALSO

procmail(1), procmailrc(1), procmailex(1), egrep(1)

=head1 AUTHOR

Cameron Simpson E<lt>cs@zip.com.auE<gt>

=cut

##BEGIN { use cs::DEBUG; cs::DEBUG::using(__FILE__);
##      }

use strict vars;
use Getopt::Std;

($::cmd=$0) =~ s:.*/::;
$::Usage="Usage: $::cmd [-a alert] [-m domains] [-t {unix|mh|maildir}] <categories >procmailrc
	-L		Use X-Label: header instead of Subject: for tag.
	-a alert	Command line to generate the alert.
			The mail item is present on standard input.
	-m domains	Select default mail domain(s).
	-t type		Select default mailbox type.
";

$::X_Label=0;
$::DfltSfx="";		# unix style by default
$::DfltType=UNIX;	# unix style by default
@::DfltDom=$ENV{SITENAME};
undef $::DfltAlert;
$::RcvStore='/usr/lib/nmh/rcvstore';	# path to MH rcvstore command

{ my $badopts=0;

  if (! getopts("a:Lm:t:"))
  { warn "$::cmd: bad options\n";
    $badopts=1;
  }

  if (defined $::opt_L)
  { $::X_Label=1;
  }

  if (defined $::opt_a)
  { $::DfltAlert=$::opt_a;
  }

  if (defined $::opt_m)
  { @::DfltDom=grep(length,split(/[\s,|]+/, $::opt_m));
  }

  if (defined $::opt_t)
  { $::DfltType = uc($::opt_t);

    if ($::DfltType eq UNIX)
    { $::DfltSfx='';
    }
    elsif ($::DfltType eq MAILDIR)
    { $::DfltSfx='/';
    }
    elsif ($::DfltType eq MH)
    { $::DfltSfx='/.';
    }
    else
    { warn "$::cmd: -t: bad mailbox type \"$::DfltType\"\n\tI know: UNIX MAILBOX MH.\n";
      $badopts=1;
    }
  }

  if (@ARGV)
  { warn "$::cmd: extra arguments: @ARGV\n";
    $badopts=1;
  }

  die $::Usage if $badopts;
}

my $doalert;
my $sfx;
my $type;
my $flags;
my $deliver;
my $cont;

CAT:
while (<STDIN>)
{
  chomp;
  s/^\s+//;
  s/^#.*//;
  next CAT if ! length;

  # VARIABLE=value
  if (/^[a-z]\w*=/)
  { print "$_\n";
    next CAT;
  }

  # < filename
  if (/^<\s*/)
  { $_=$';
    s/\s+$//;
    if (! open(INCLUDE, "< $_\0"))
    { warn "$::cmd: line $.: can't open \"$_\": $!\n";
      next CAT;
    }
    print "\n";
    while (defined($_=<INCLUDE>))
    { print;
    }
    close(INCLUDE);
    print "\n";
    next CAT;
  }

  # leading "+" means continue after rule
  $cont='';
  if (/^\+\s*/)
  { $cont='c';
    $_=$';
  }

  # leading "!" means alert this message
  $doalert=0;
  if (/^\!\s*/)
  { $doalert=1;
    $_=$';

    if (! defined $::DfltAlert || ! length $::DfltAlert)
    { warn "$::cmd: line $.: no alert shell command defined1\n";
      $doalert=0;
    }
  }

  # we expect "mailbox tag rule"
  if (! /^(\S+)\s+(\S+)\s+(\S.*\S)/)
  { warn "$::cmd: stdin, line $.: bad line: $_\n";
    next CAT;
  }

  my($folder,$key,$ptn)=($1,$2,$3);
  $folder='attn' if $folder eq '.';

  my @hdrs;
  if ($ptn =~ /^(\w[-,\w]*):/)
  { $ptn=$';
    @hdrs=split(/,+/, $1);
  }
  else
  { @hdrs=('to','cc','bcc');
  }

  if ($ptn =~ m:^/(.*)/?$:)
  { $ptn=$1;
  }
  else
  { $ptn.="\@.*(".join('|',@::DfltDom).")" if $ptn !~ /\@/;
  }

  $ptn =~ s/\.[^*]/\\$&/g;

  my $hregexp = '('.join('|',@hdrs).')';

  if ($folder =~ /^\|/)
  { $deliver="$folder '$key'";
  }
  elsif ($folder =~ /\@/)
  { $deliver="! $folder";
  }
  else
  { $type=foldertype($folder);
    
    if ($type eq MH)
    # procmail doesn't do .mh_sequences support
    { $deliver="| $::RcvStore +$folder -unseen";
    }
    else
    { $sfx=foldersfx($folder);
      $deliver="$folder$sfx";
    }
  }

  $flags=($deliver =~ /^\|/ ? "w" : "");

  print <<X
: 0$cont
* ^$hregexp:.*$ptn
{
X
  ;

  if ($doalert)
  { my $alertfn = $::DfltAlert;
    $alertfn =~ s/\%/$folder/g;
    print <<X

  : 0hc
  | $alertfn
X
    ;
  }

  if ($key ne '.')
  # note that we strip the typical mailing list [tag] stuff if using our own key
  {
    if ($::X_Label)
    {
      print <<X
  :0 whf
  | formail -A "X-Label: $key" 
X
      ;
    }
    else
    {
      print <<X

  : 0whf
  | sed -e 's/^Subject: *\\[[^ ]*\\] */Subject: /' -e 's/^Subject: *[Rr][Ee] *: *\\[[^ ]*\\] */Subject: Re: /' -e 's/^Subject:/& [$key]/'
X
      ;
    }
  }

  print <<X

  : 0$flags:
  $deliver
X
  ;

  print <<X
}

X
  ;
}

exit 0;

sub foldersfx
{ my($type)=@_;

  if ($type eq UNIX)	{ return ""; }
  if ($type eq MAILDIR)	{ return "/"; }
  if ($type eq MH)	{ return "/."; }
  die "$0: can't determine folder suffix for type \"$type\"";
}

sub foldertype
{ my($folder)=@_;

  $folder="$ENV{MAILDIR}/$folder" unless $folder =~ m:^/:;
  if (! stat($folder))
  { return $::DfltType;
  }

  if (! -d _)
  { return UNIX;
  }

  if (-e "$folder/.mh_sequences")
  { return MH;
  }

  return MAILDIR;
}
