#!/bin/sh -u
#
# Yet another audio CD ripper. Easiest way to learn the tools :-)
# Like mkcd and mkiso, this is meant to be a no brainer command line.
#	- Cameron Simpson <cs@zip.com.au> 12mar2001
#
# Add MP3 mode, basicly for my brother.	 -cameron 25aug2001
# Support multiple encodings, add -k option, switch to WAV as
# intermediate file format.		- cameron 16mar2003
# Log completed tracks to the INDEX file if present. - cameron 27oct2005
#
# =head1 NAME
#
# cdrip - extract tracks from an audio CD and encode as Ogg, MP3 and/or FLAC
#
# =head1 SYNOPSIS
#
# cdrip [-q qual] [-b bps] [-d device] [-e enclist] [-l lock] [-j jobs] [-K]
#
# =head1 DESCRIPTION
#
# I<cdrip> is a script to extract and encode audio CDs.
# Normally it is sufficient to cd to your audio archive directory,
# insert your audio CD in the CDROM drive and say:
#
#	cdrip
#
# I<cdrip> will consult the FreeDB database for track and album titles,
# and extract and encode the tracks.
#
# Note: B<cdrip> is a wrapper. See the PREREQUISITES section below for needed software.
#

: ${TMPDIR:=/tmp}
: ${EDITOR:=vi}
: ${NAME:=''}
: ${CDRIP_TRACKFMT:='%02d - %s'}	# track number then title
: ${CDRIP_DEV:=/dev/cdrom}
: ${CDRIP_ENC:=ogg}			# comma separated list of ogg,mp3,flac
: ${CDRIP_BPS:=192}
: ${CDRIP_QUAL=6}
: ${CDRIP_LOCK:=''}
: ${CDRIP_OPTS:=''}
: ${CDDBSERVER:=au.freedb.org:8880}
export CDDBSERVER

dev=$CDRIP_DEV
enclist=$CDRIP_ENC
bps=$CDRIP_BPS
qual=$CDRIP_QUAL
lock=$CDRIP_LOCK
trackfmt=$CDRIP_TRACKFMT
oggencqual=
lamequal=
flacqual=--best
keep=
jobs=1
nice=10
cdpara_noise=-q

cmd=`basename "$0"`
usage="Usage: $cmd [-q qual] [-b bps] [-d device] [-e enclist] [-l lock] [-j jobs] [-K]
	-v		Verbose.
	-q qual		Variable bitrate quality rating.
			Default: $qual
	-b kbps		Fixed bitrate kilobits per second for the encoding.
			Default: variable bit rate using quality.
	-d device	Device holding the CD. Default: $dev
	-e enclist	Select encoding(s), comma separated.
			Supported: ogg,mp3,flac. Default: $enclist
	-K		Keep the WAV file around.
	-j jobs		Use this many CPUs for the encoding phase.
			(jobs > 1) implies \"-l $cmd\".
	-l lock		Do encoding completely asynchronously, using \"lock\"
			as the lock name basis.
	-n nice		Extra niceness for the encoder. Default: $nice"

set x -b "$bps" -q "$qual" $CDRIP_OPTS ${1+"$@"}; shift

#
# =head1 OPTIONS
#
# =over 4
#
badopts=
while [ $# -gt 0 ]
do
    case $1 in
	# =item B<-v>
	#
	# Verbose.
	# Make rippers more noisy.
	#
	-v)	cdpara_noise=-e ;;
	#
	# =item B<-b> I<kbps>
	#
	# Fixed bitrate kilobits per second for the encoding.
	# Default: variable bit rate using quality (B<-q> below).
	#
	-b)	[ -n "$2" ] && { oggencqual="-b $2" lamequal="-b $2"; }
		shift ;;
	# =item B<-q> I<quality>
	#
	# Variable bitrate quality level.
	# Default: B<6> or the value of B<$CDRIP_QUAL>.
	# Note: this is the oggenc(1) quality numbering (1 is bad, 9 is good).
	# Lame(1)'s quality numbering goes the other way.
	# The script converts as appropriate, but this should be bourne in mind if encoding to MP3.
	# Flac(1) encoding uses this to control the compression level.
	#
	-q)	if [ -n "$2" ]
		then
		  oggencqual="-q $2"
		  lamequal="-v -V `expr 9 - $2`"
		  case "$2" in
		    9)		flacenc=-8 ;; # we do not go to 11
		    [0-8])	flacenc=-$2 ;;
		    *)		echo "$cmd: unsupported quality: $1 $2" >&2
				badopts=1
				;;
		  esac
		fi
		shift ;;
	# =item B<-d> I<device>
	#
	# The device from which to read the audio CD.
	# Default: B</dev/cdrom> or the value of B<$CDRIP_DEV>.
	#
	-d)	dev=$2 ;shift ;;
	# =item B<-e> I<encodings>
	#
	# Comma separated list of encoding formats to produce.
	# Supported: ogg, mp3, flac.
	# Default: B<ogg>, or the value of B<$CDRIP_ENC>.
	#
	-e)	enclist=
		for e in `echo "$2" | tr , ' '`
		do
		  case $e in
		    mp3|ogg|flac)
			enclist="$enclist $e" ;;
		    *)	echo "$cmd: unrecognised encoding: $e" >&2
			echo "	I known ogg, mp3 and flac" >&2
			badopts=1
			;;
		  esac
		done
		shift
		;;
	# =item B<-l> I<lock>
	#
	# Base name of the lock to use for asynchronous background decoding.
	# You can use this if you can pull the audio data from the CD faster than
	# your machine can encode the data to the desired format
	# (eg a fast CDROM in a slow machine).
	# This will background every encoder, each of which will obtain the named lock
	# with the lock(1cs) command before running, thus not thrashing your machine
	# to death.
	# Use of this option may allow you to queue up many CDs by pulling the data in
	# ahead of completion of the encoding.
	# Default: synchronous encoding - the encoding will still run in parallel
	# with pulling data from the CD, but encoding of each track will
	# still wait for the previous encoding to finish, and ripping of the
	# track after will in turn be delayed under encoding of this track can be dispatched.
	#
	-l)	lock=$2; shift ;;
	# =item B<-j> I<jobs>
	#
	# Run I<jobs> encoders at once.
	# This implies use of a set of locks.
	# Useful on multi-CPU machines.
	#
	-j)	jobs=$2; shift ;;
	# =item B<-K>
	#
	# Keep the WAV files of the raw audio from the CD around after encoding.
	#
	-K)	keep=1 ;;
	--)	shift ;break ;;
	-?*)	echo "$cmd: unrecognised option: $1" >&2
		badopts=1
		;;
	*)	break ;;
    esac
    shift
done
#
# =back
#

case "$lock" in
  *[\ \	]*)	echo "$cmd: no whitespace in lock names! (\"$lock\")" >&2
		badopts=1
		;;
esac

[ $# = 0 ] || { echo "$cmd: extra arguments: $* ">&2
		abdopts=1
	      }

[ $badopts ] && { echo "$usage" >&2; exit 2; }

if [ "$jobs" -gt 1 -a -z "$lock" ]
then
    lock=$cmd
fi

byNAME=
[ -n "$NAME" ] && byNAME=" by $NAME"

toc=$TMPDIR/cdtoc.$$
cdtoc "$dev" >"$toc" || { rm -f "$toc"; exit 1; }

grep '^[^#]' <"$toc" | grep -v '^[0-9][0-9]* '
ask "Edit TOC before use" && $EDITOR "$toc"

exec <"$toc"
rm "$toc"

sed -e 's;//*; -- ;g' -e 's/   */ /g' \
| ( read artist	|| exit 1
    read album	|| exit 1

    encpid=
    xit=0
    nextjob=1
    while read track secs offset \
       && read title \
       && read xtra
    do
      dir=$artist/$album
      case $track in
	  [0-9])	wtrack=0$track ;;
	  *)		wtrack=$track ;;
      esac
      ftitle=`printf "$trackfmt" "$track" "$title"`

      echo "Ripping track #$track: $dir/$ftitle ..."

      needenc=
      for enc in $enclist
      do  out=$dir/$ftitle.$enc
	  if [ -s "$out" ]
	  then  echo "$cmd: $out already exists" >&2
	  else  needenc="$needenc $enc"
	  fi
      done

      # skip if no encodings OR keep-raw mode on
      [ -n "$needenc" -o -n "$keep" ] || continue

      raw=$dir/$ftitle.wav

      [ -d "$dir/." ] || mkdir -p "$dir" || { xit=1; continue; }
      ripcomment="Ripped$byNAME with cdparanoia on `date`"

      [ -s "$raw" ] \
      || (set -x; cdparanoia $cdpara_noise -d "$dev" -w "$track" "$raw") \
      || { echo "cdparanoia failed" >&2
	   tail -20 cdp.err >&2
	   [ $keep ] || rm -f "$raw"
	   xit=1
	   continue
	 }

      firstenc=1
      linksgood=1
      for enc in $needenc
      do
	out=$dir/$ftitle.$enc
	[ -s "$out" ] && { echo "$cmd: existing file $out, skipping" >&2
			   continue
			 }

	if [ -z "$lock" ]
	then
	    [ -n "$encpid" ] && kill -0 "$encpid" 2>/dev/null \
	      && { echo; echo "waiting for previous encoder ..."; }
	    wait
	fi

	if [ $firstenc ]; then firstenc=
			  else ls -ld "$raw"
	fi

	# set up command line for each encoding
	link=$raw-4$enc
	if ln "$raw" "$link"
	then
	    set rmafter $"link" "$@"
	    in=$link
	else
	    echo "$cmd: can't link raw to $link" >&2
	    linksgood=
	    link=
	    in=$raw
	fi
	case $enc in
	  flac)
	    set flac $flacenc -o "$out" "$in"
	    ;;
	  ogg)
	    set oggenc $oggencqual -a "$artist" -N "$track" -t "$title" -l "$album"
	    # This fiddling is because oggenc blows up with long comments.
	    commentf=.tmp$$c
	    { [ -n "$xtra" ] && echo "$xtra"
	      echo "$ripcomment"
	      echo "Encoded$byNAME with `oggenc -v` [$oggencqual] on `date`"
	    } >"$commentf"

	    while read -r comment
	    do  [ -n "$comment" ] && set "$@" -c "COMMENT=$comment"
	    done <"$commentf"
	    rm "$commentf"

	    set "$@" -o "$out" "$in"
	    ;;
	  mp3)
	    set lame -h $lamequal -p "$in" "$out"
	    if [ -n "$link" ]
	    then
	      ( # dispatch job to id3 tag the file after encoding
		while [ -s "$link" ]
		do  sleep 1
		done
		if [ -s "$out" ]
		then
		  set -x
		  id3ed -s "$title" -n "$artist" -a "$album" \
			-c "Encoded$byNAME with `lame -v 2>&1 | sed 1q` [$lamequal] on `date`" \
			-k "$track" "$out" </dev/null
		fi
	      ) &
	    fi
	    ;;
	  *)
	    echo "$cmd: unimplemented encoding \"$enc\"!" >&2
	    xit=1
	    continue
	    ;;
	esac

	[ -n "$link" ] && set rmafter "$link" "$@"
	[ -n "$lock" ] && { set alog cdrip lock "$lock@$HOST-$nextjob" "$@"
			    nextjob=`expr \( $nextjob \) \% $jobs + 1`
			  }
	set nice -n "$nice" "$@"

	if ( set -x; exec "$@" )
	then [ -s INDEX ] && printf "%s\n" "$out" >>INDEX
	else echo "Encode of \"$raw\" fails." >&2
	     rm -f "$out"
	     exit 1
	fi &
	encpid=$!

      done

      [ $keep ] \
      || [ -z "$lock" -o -n "$linksgood" ] && (set -x; exec rm "$raw")
    done

    [ -z "$lock" ] && wait

    exit $xit
  )

xit=$?

eject "$dev"
necho ''

exit $xit

#
# =head1 PREREQUISITES
#
# B<cdrip> is a wrapper for the extraction and encoding programs,
# which must also be installed.
# You need:
#
# =over 4
#
# =item B<cdparanoia>
#
# The program used to pull the audio data from the CD, available here:
#
#	http://freshmeat.net/projects/cdparanoia/?topic_id=118%2C113
#
# =item B<oggenc>
#
# The program used to encode CD audio to Ogg Vorbis files, available here:
#
#	http://freshmeat.net/projects/oggenc/?topic_id=113
#
# =item B<lame>
#
# The program used to encode CD audio to MP3 files, available here:
#
#	http://freshmeat.net/projects/lame/?topic_id=113%2C123
#
# =item B<css>
#
# B<cdrip> uses a bunch of utility scripts from this (B<lock>, B<rmafter>, etc).
# Fortunately, B<cdrip> itself is part of this collection
# so the easiest thing is just to grab it and put its B<bin> directory at the end of your B<$PATH>.
# It is available here:
#
#	http://freshmeat.net/projects/css-cameronsimpsonsscripts/?topic_id=45%2C137%2C253%2C861
#
# =back
#
# =head1 ENVIRONMENT
#
# EDITOR, the program used to edit the table of contents if desired. Default: B<vi>.
#
# NAME, your name. Noted as the ripper if not empty.
#
# CDRIP_OPTS, a list of default options to prepend to the command line options
# to specify default behaviour. Alternatively the separate environment variables below may be used.
# Options specified in B<CDRIP_OPTS> will override the defaults below if both are used.
#
# CDRIP_DEV, the device from which to read the audio CD. Default: B</dev/cdrom>.
#
# CDRIP_ENC, a comma separated list of encoding formats to produce.
# Default: B<ogg>.
# Known: B<ogg> and <mp3>.
#
# CDRIP_LOCK, the base name for the lock to use between encoders.
#
# CDRIP_QUAL, the default quality to aim for. Default: B<6>.
#
# CDRIP_BPS, the default fixed bitrate to aim for. Default: B<192>.
#
# Note that quality and bits-per-second interact.
# If specified on the command line, the later of B<-b> and B<-q> is used.
# If you're using the environment variables, a non-empty B<CDRIP_QUAL> will always win over B<CDRIP_BPS>.
# Command line options win over environment variables.
# The best way to get a fixed rate encoding from the environment variables
# is to use B<CDRIP_OPTS> to specify a B<-b> option.
#
# CDDBSERVER, in the form I<server>B<:>I<port>, used by cdtoc(1cs) to obtain album and track information.
#
# CDRIP_TRACKFMT, printf(1) format string expecting a B<%d> and a B<%s> in that order.
# Default: B<%02d - %s>
#
# =head1 SEE ALSO
#
# oggenc(1), lame(1), flac(1), cdparanoia(1), mkiso(1cs), mkcd(1cs), cdtoc(1cs), cdsubmit(1cs)
#
# =head1 AUTHOR
#
# Cameron Simpson <cs@zip.com.au> 12mar2001
#
