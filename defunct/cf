#!/usr/bin/perl
#
# Conform a machine.
#	-d	Run in daemon mode (the target end of the rsh).
#
#	- Cameron Simpson <cs@cskk.id.au>
#

use strict qw(vars);

use POSIX;
use File::Find;
require 'flush.pl';
require 'open2.pl';

($::cmd=$0) =~ s:.*/::;

$::Warehouse='/usr/local/misc/cisra/install';
$::CFCmd='/usr/local/script/cf';
# $::CFCmd='/home/install/install/cf.new';
$::Packages="$::Warehouse/PACKAGES";
$::InstallBase='/usr/local';
$::Rsh='/bin/ssh';

$::SidewaysSfx='old';
$::MoveSideways=0;

$::Usage="Usage:\t$::cmd -d
		-d	Daemon mode; the far end of the rsh link.
	$::cmd [-i[backup]] host packages...
		-i	Install packages; default is simply to check.
			Move old targets to target.backup.n if backup specified.
";

my(@options)=qw(ARCH);
my($Daemon)=0;
$::Install=0;

my($badopts)=0;

ARGV:
  while (@ARGV)
	{ $_=shift @ARGV;

	  if (! /^-./)		{ unshift(@ARGV,$_);
				  last ARGV;
				}

	  if ($_ eq '-d')	{ $Daemon=1; }
	  elsif ($_ eq '-i')	{ $::Install=1; }
	  elsif (/^-i/)		{ $::Install=1;
				  $::SidewaysSfx=$';
				  $::MoveSideways=1;
				  push(@options,SIDEWAYS);
				}
	  elsif (/^-D(\w+)=/)	{ $ENV{$1}=$'; }
	  else			{ warn "$::cmd: $_: unrecognised option\n";
				  $badopts=1;
				}
	}

if (! $Daemon)
	{ if (! @ARGV)
		{ warn "$::cmd: missing host\n";
		  $badopts=1;
		}
	  else
	  { $::Host=shift @ARGV;
	    if (! @ARGV)
		{ warn "$::cmd: missing packages\n";
		  $badopts=1;
		}
	    else
	    { @::Packages=@ARGV;
	      @ARGV=();
	    }
	  }
	}

if (@ARGV)
	{ warn "$::cmd: extra arguments: @ARGV\n";
	  $badopts=1;
	}

die $::Usage if $badopts;

$::Context=($Daemon ? "$::cmd-daemon" : $::cmd);
exit ($Daemon ? Daemon() : Conform(@options));

sub Daemon
	{ my($Xit)=0;

	  # open(STDERR,"| sed 's/^/100 Daemon: /' >/dev/tty") || die;
	  # open(STDERR,'> /dev/ttyq14') || die;

	  { my($oldsel)=select(STDERR);
	    $|=1;
	    select($oldsel);
	  }

	  my($type,$target);

	  while (<STDIN>)
		{ chomp;
		  # warn "input: \"$_\"\n";

		  if (/^\s*option\s+/)
			{ $_=$';

			  my(@errs,@opts);

			  while (/^(\w+)=(([^\s\\]|\\.)*)\s*/)
				{ my($opt,$val);

				  $opt=$1; $val=$2; $_=$';
				  $val =~ s/\\(.)/$1/g;

				  push(@opts,$opt);

				  # warn "Daemon: option $opt=$val\n";
				  if ($opt eq SIDEWAYS)
					{ $::SidewaysSfx=$val;
					  $::MoveSideways=1;
					}
				  elsif ($opt =~ /^[A-Z]+$/)
					{ $ENV{$opt}=$val;
					}
				  else
				  { push(@errs,"don't understand option $opt, ignoring value \"$val\"\n");
				  }
				}

			  if (@errs)
				{ printcode("402",
					"Unrecognised options",
					@errs);
				}
			  else	{ printcode("201","Set options [@opts]");
				}
			}
		  elsif (/^\s*check\s+(dir|soft|file)\s+(\S+)\s*/)
			{ $type=$1; $target=$2;
			  $_=$';

			  my(%attrs)=parseAttrs($_);
			  my(@errs);

			  if (@errs=check($target,$type,%attrs))
				{ printcode("401",
					"Target $type $target doesn't match",
					@errs);
				  $Xit=1;
				}
			  else
			  { printcode("201","Target $type $target OK");
			  }
			}
		  elsif (/^\s*install\s+(dir|soft|file)\s+(\S+)\s*/)
			{ $type=$1; $target=$2;
			  $_=$';
			  
			  my(%attrs)=parseAttrs($_);
			  my($data);

			  if ($type eq 'file')
				{ $data=readn(STDIN,$attrs{'size'});
				  die "$::cmd: premature EOF reading data component of $target\n"
					if $attrs{'size'} > length($data);
				  # warn "remote: read $attrs{'size'} bytes\n";
				}
			  else
			  { $data='';
			  }

			  my(@errs);

			  if (@errs=install($target,$type,$data,%attrs))
				{ printcode("402",
					"Target $type $target not installed",
					@errs);
				  $Xit=1;
				}
			  else
			  { printcode("201","Target $type $target INSTALLED");
			  }

			  $data='';	# release memory
			}
		  else
		  { printcode("501","Unrecognised request: $_");
		    # warn "can't parse \"$_\"\n";
		  }

		  flush(STDOUT);
		  flush(STDERR);
		}
#	  continue
#		{ warn "waiting after line $. for instructions\n";
#		}

	  return $Xit;
	}

sub Conform
	{ my(@options)=@_;
	  my($Xit)=0;

	  undef %::Packages;
	  if (! loadPackageFile($::Packages))
		{ warn "$::cmd: can't load package descriptions from $::Packages\n";
		  return 1;
		}

	  my(@rsh)=($::Rsh,$::Host,$::CFCmd,'-d');
	  # @rsh=('/bin/sh','-c',"tee cf.in|$::CFCmd -d|tee cf.out");
	  # warn "rsh=[@rsh]\n";

	  my($pid);

	  if (! defined ($pid = open2(FROMRSH, TORSH, @rsh)))
		{ warn "$::cmd: can't attach to \"@rsh\": $!\n";
		  $Xit=1;
		  return;
		}

	  select(TORSH);

	  # warn "pass options....\n";

	  my($opt,$val);

	  Option:
	    for $opt (@options)
		{ # warn "opt $opt ...\n";
		  if ($opt eq SIDEWAYS)		{ $val=$::SidewaysSfx; }
		  elsif ($opt =~ /^[A-Z]+$/)	{ $val=$ENV{$opt}; }
		  else				{ warn "$::cmd: don't know how to specify option \"$opt\"\n";
						  next Option;
						}

		  print TORSH "option $opt=", sloshquote($val), "\n";
		  flush(TORSH);
		  # warn "flushed\n";

		  { my($code,@text)=readcode(FROMRSH);
		    next Option if $code =~ /^2/; # option passed ok

		    warn "$::cmd: code $code ", join("\n\t",@text), "\n";
		  }

		  $Xit=1;
		}

	  if ($Xit != 0)
		{ warn "setup fails, aborting install\n";
		  return $Xit;
		}

	  # warn "checking: Packages=[@::Packages]\n";
	  my($pack);

	  PACKAGE:
	    for $pack (@::Packages)
		{ checkPackage($pack) || ($Xit=1);
		}

	  close(TORSH);

	  while (<FROMRSH>)
		{ warn "extra FROMRSH: $_";
		}

	  close(FROMRSH);

	  return $Xit;
	}

sub checkPackage
	{ my($pack)=@_;

	  # warn "checkPackage($pack)\n";

	  local($::CurrentPackage)=$pack;

	  if (! defined $::Packages{$pack})
		{ warn "$::cmd: no description for package \"$pack\"\n";
		  return 0;
		}

	  my($ok)=1;
	  my($p)=$::Packages{$pack};
	  my($t);

	  if (exists $::Pending{$pack})
	  	{ for $t (@{$::Pending{$pack}})
			{ { local($::Context)=$t->{Context};
			    expandDirTree($t->{Target},$t->{Src})
				|| ($ok=0);
			  }
			}
	  	  delete $::Pending{$pack};
	  	}

	  my($target);

	  Target:
	    for $target (sort keys %$p)
		{ checkTarget($p->{$target}) || ($ok=0);
		}

	  $ok;
	}

sub checkTarget
	{ my($t)=@_;
	  my($ok)=1;

	  local($::Context)=$t->{Context};

	  my($target)=$t->{Target};
	  # warn "checkTarget(t:$target)\n";

	  if (defined $::Checked{$target})
		# already checked
		{}
	  else
	  { $::Checked{$target}=1;

	    if ($t->{Type} eq PACKAGE)
		{ checkPackage($target) || ($ok=0);
		}
	    elsif ($t->{Type} eq LOCAL)
	      	{ checkAgainst($t->{Target},$t->{Src}) || ($ok=0);
		}
	    elsif ($t->{Type} eq SYMLINK)
		{ checkAttrs($t->{Target},$t->{Src},'soft','linktext' => $t->{Src})
			|| ($ok=0);
		}
	    else
	    { warn "$::cmd: $::Context: don't know how to check target \"$t->{Target}\", type is $t->{Type}";
	      $ok=0;
	    }
	  }

	  $ok;
	}

sub loadPackageFile	# fname -> void (updates %::Packages)
	{ my($fname)=@_;
	  my($ok)=1;

	  open(Packages,"< $fname\0")
		|| die "$::cmd: open($fname): $!\n";

	  local($::CurrentPackage);
	  my(@packagerefs);
	  my($pref,$tref,$package,$target,$src);
	  local($_);

	  { local($::Context);

	    LINE:
	      while (<Packages>)
		{ $::Context="$fname, line $.";
		  chomp;

		  s/#.*//;

		  if (/^:\s*(\w+)\s*/)
			{ packageFileConfig($1,$') || ($ok=0);
			  next LINE;
			}

		  if (/^[-\w.]+/)
			# leading package name ==> new package
			{ $::CurrentPackage=$&;	# package name
			  $_=$';
			}

		  s/^\s+//;
		  next LINE if /^$/;

		  $_=expand($_);

		  # +package
		  if (/^\+([-\w.]+)\s*$/)
			# reference sub-package
			{ noteTarget($1,Package) || ($ok=0);
			  # warn "$::CurrentPackage: add package $1\n";
			}
		  # this -> that
		  elsif (/^(\S+)\s+->\s+(\S+)/)
			{ $target=$1; $src=$2;
			  $target="$::InstallBase/$target"
				unless $target =~ m:^/:;
			  noteTarget($target,SYMLINK,$src) || ($ok=0);
			  # warn "$::CurrentPackage: add $target -> $src\n";
			}
		  else
		  { if (!  /^(\S+)\s+(\S+)\s*$/)
			{ warn "$::cmd: $::Context: skipping \"$_\"\n";
			  $ok=0;
			  next LINE;
			}

		    $target=$1; $src=$2;
		    # warn "$::CurrentPackage: add $target $src\n";

		    if ($target !~ m:^/:)
			{ $target="$::InstallBase/$target";
			}

		    if ($src !~ m:^/:)
			{ $src="$::Warehouse/$::CurrentPackage/$src";
			}

		    if ( ($target =~ m:/$:)
		       ^ ($src    =~ m:/$:) )
			{ warn "$::cmd: $::Context: target($target) and src($src) must be the same type\n";
			  $ok=0;
			  next LINE;
			}

		    if ($src =~ m:/$:)
			# directory, need contents
			{ noteTarget($target,DirTree,$src) || ($ok=0);
			}
		    else
		    # file
		    { noteTarget($target,LOCAL,$src) || ($ok=0);
		    }
		  }
		}
	  }

	  close(Packages);

	  return $ok;
	}


sub packageFileConfig
	{ my($command,$params)=@_;
	  my(@argv)=split(/\s+/,$params);
	  my($ok)=1;

	  if ($command eq 'host')
		{ my(@hosts)=split(/,+/,shift @argv);
		  my($h,$thisone);
		  local($_);

		  $thisone=0;
		  HOST:
		    for $h (@hosts)
			{ if ($h eq $::Host)
				{ $thisone=1;
				  last HOST;
				}
			}

		  if ($thisone)
			{ for (@argv)
				{ if (/^(\w+)=/)
					{ $ENV{$1}=$';
					  # warn "set \$$1=$'\n";
					}
				}
			}
		}
	  elsif ($command eq 'case')
		{ my($var)=shift @argv;
		  my(@cases)=split(/,+/,shift @argv);
		  my($thisone)=0;
		  local($_);

		  if (! defined $ENV{$var})	{ }
		  else
		  { $var=$ENV{$var};

		    CASE:
		      for (@cases)
			{ if ($_ eq $var)
				{ $thisone=1;
				  last CASE;
				}
			}

		    if ($thisone)
			{ for (@argv)
				{ if (/^(\w+)=/)
					{ $ENV{$1}=$';
					}
				}
			}
		  }
		}
	  else
	  { warn "$::cmd: unrecognised config command \"$command @argv\"\n";
	    $ok=0;
	  }

	  return $ok;
	}

sub checkAgainst
	{ my($target,$src)=@_;
	  my($type,%attrs);
	  my($ok)=1;

	  # warn "check $::Host:$target against $src: nargs=",scalar(@_),
	  #	"caller=[",join(':',caller),"]\n";

	  # stat src for info
	  my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
		$atime,$mtime,$ctime,$blksize,$blocks)=lstat($src);

	  if (! defined $dev)
		{ warn "$::cmd: can't lstat($src): $!\n";
		  return 0;
		}

	  if (-d _)	{ $type='dir'; }
	  elsif (-f _)	{ $type='file'; }
	  elsif (-l _)	{ $type='soft'; }
	  else		{ printf STDERR "$::cmd: odd type (mode=%6o) for $target\n",$mode;
			  $ok=0;
			  next Source;
			}

	  if ($type eq 'file' || $type eq 'dir')
	    	{ $attrs{'perm'}=sprintf("%4o",($mode&07777));
		}

	  if ($type eq 'file')
		{ $attrs{'id'}="$rdev:$dev:$ino";
		  $attrs{'size'}=$size;
		  $attrs{'mtime'}=$mtime;
		  $attrs{'atime'}=$atime; # not useful
		  $attrs{'uid'}=uid2login($uid);
		  $attrs{'gid'}=$gid;	# &gid2group($gid);
		}

	  if ($type eq 'soft')
		{ my($linktext);

		  if (! defined ($linktext=readlink($src)))
			{ warn "$::cmd: readlink($src): $!\n";
			  $ok=0;
			  next Source;
			}

		  $attrs{'linktext'}=$linktext;
		  # warn "$src linktext=[$linktext]\n";
		}

	  checkAttrs($target,$src,$type,%attrs) && $ok;
	}

sub checkAttrs
	{ my($target,$src,$type,%attrs)=@_;

	  # dispatch check

	  print TORSH "check $type $target";
	  my($key);

	  for $key (sort keys %attrs)
		{ print TORSH " $key $attrs{$key}";
		}
	  print TORSH "\n";
	  flush(TORSH);

	  my($code,@text)=readcode(FROMRSH);

	  return 1 if $code =~ /^2/;	# File matches.

	  # warn "$::cmd: code $code ", join("\n\t",@text), "\n";

	  return 0 unless $::Install;

	  # warn "decide to install $target\n";

	  my($data);

	  if ($type eq 'file')
		{ my($size)=$attrs{'size'};

		  if (!open(SOURCE,"< $src\0"))
			{ warn "$::cmd: open($src): $!\n",
					"\tcan't reinstall $target\n";
			  return 0;
			}

		  $data=readn(SOURCE,$size);
		  close(SOURCE);

		  die "$::cmd: read less than $size bytes from $src\n"
			if length($data) < $size;

		  # warn "got $size bytes from $src\n";
		}

	  print TORSH "install $type $target";
	  for $key (sort keys %attrs)
		{ print TORSH " $key $attrs{$key}";
		}
	  print TORSH "\n";

	  if ($type eq 'file')	{ print TORSH $data; }

	  flush(TORSH);

#	  warn "dispatched install request and data (",
#		length($data), " bytes)\n";

	  ($code,@text)=readcode(FROMRSH);

	  warn "$::cmd: code $code ", join("\n\t",@text), "\n";

	  return 0;
	}

sub readn	# FILE,n -> data
	{ my($FILE,$count)=@_;
	  my($sofar)=0;
	  local($_);
	  my($n,$toread,$data);

#	  warn "enter readn($count) ...\n";

	  $data='';

	  READ:
	    while ($sofar < $count)
		{ $toread=$count-$sofar;
		  if ($toread > 8192)	{ $toread=8192; }
		  $n=read($FILE,$_,$toread);
		  last READ if $n < 1;
#		  warn "readn($count): got $n bytes\n";
		  $sofar+=length;
		  $data.=$_;
		}

#	  warn "readn(FILE=$FILE,count=$count): length=",length($data),
#		", caller=[",join(' ',caller),"]\n";

	  $data;
	}

sub uid2login
	{ my($uid)=@_;
	  my($login);

	  # warn "uid2login(@_)...\n";
	  if (!defined($login=getpwuid($uid)))
		{ warn "$::cmd: can't get login for uid $uid\n";
		  return $uid;
		}
	  # warn "uid2login(@_)=>$login\n";

	  $login;
	}

sub login2uid
	{ my($login)=@_;
	  my($uid);

	  if ($login =~ /^\d+$/)
		{ $uid=$login+0; }
	  else	{ $uid=getpwnam($login); }

	  $uid;
	}

sub gid2group
	{ my($gid)=@_;
	  my($group);

	  if (!defined($group=getgrgid($gid)))
		{ warn "$::cmd: can't get group for gid $gid\n";
		  return $gid;
		}

	  $group;
	}

sub group2gid
	{ my($group)=@_;
	  my($gid);

	  if ($group =~ /^\d+$/)
		{ $gid=$group+0; }
	  else	{ $gid=getgrnam($group); }

	  $gid;
	}

sub printcode
	{ print &code;
	}

sub readcode	# FILE -> code,@text
	{ my($FILE)=shift;
	  my($code,@text);
	  local($_);

	  READCODE:
	    while (1)
		{
		  undef $_;
		  undef $code;
		  undef @text;

		  CODE:
		    while (1)
			{ return("500","Unexpected EOF") if ! defined ($_=<$FILE>);
			  chop;
			  # warn "readcode: [$_]\n";
			  if (/^(\d{3})/)
				{ $code=$1; $_=$';
				  last CODE;
				}

			  warn "$FILE, line $.: $_\n";
			}

		  while (/^-/)
			{ push(@text,$');
			  if (! defined ($_=<$FILE>))
				{ for (@text)
					{ $_="$code-$_";
					}
				  return ("500","Unexpected EOF, partial response follows",@text);
				}

			  chop;
			  # warn "readcode2: [$_]\n";

			  if (! /^$code/)
				{ for (@text)
					{ $_="$code-$_";
					}
				  return ("500","Unexpected data, corrupt response follows",@text,$_);
				}

			  $_=$';
			}

		  s/^ //;

		  push(@text,$_);

		  last READCODE unless $code =~ /^1/;
		}
	  
	  ($code,@text);
	}

sub code
	{ my($code,@text)=@_;
	  
	  if (@text == 1)	{ return "$code @text\n"; }

	  my($last)=pop @text;

	  "$code-"
	 .join("\n$code-",@text)
	 ."\n$code $last\n";
	}

sub parseAttrs
	{ my($attrs)=@_;
	  my(%attrs);

	  while ($attrs =~ /^\s*(\w+)\s+(\S+)/)
		{ $attrs{$1}=$2;
		  $attrs=$';
		}

	  %attrs;
	}

sub check
	{ my($target,$type,%attrs)=@_;

	  my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
		$atime,$mtime,$ctime,$blksize,$blocks)=lstat($target);

	  if (! defined $dev)
		{ return "$target missing? lstat says $!";
		}

	  my(@errs);

	  if ($type eq 'dir')
		{ if (! -d _)	{ push(@errs,"not a directory"); } }
	  elsif ($type eq 'file')
		{ if (! -f _)	{ push(@errs,"not a regular file"); } }
	  elsif ($type eq 'soft')
		{ if (! -l _)	{ push(@errs,"not a symbolic link"); } }
	  else	{ push(@errs,"can't check type $type");
		  return @errs;
		}

	  my($key,$attr);

	  for $key (sort keys %attrs)
		{ $attr=$attrs{$key};
		  if ($key eq 'size')
			{ if ($size != $attr)
			    { push(@errs,"size: expected $attr, found $size"); }
			}
		  elsif ($key eq 'atime')	# not useful to check
			{ if (1) {}
			  elsif ($atime != $attr)
			    { push(@errs,"atime: expected $attr, found $atime"); }
			}
		  elsif ($key eq 'mtime')
			{ if ($mtime != $attr)
			    { push(@errs,"mtime: expected $attr, found $mtime"); }
			}
		  elsif ($key eq 'perm')
			{ $attr=eval("0$attr");
			  if (($mode & 07777) != $attr)
				{ push(@errs,sprintf("perm: expected %4o, found %4o",$attr,($mode&07777))); }
			}
		  elsif ($key eq 'uid')
			{ $attr=&login2uid($attr);
			  if ($uid != $attr)
				{ push(@errs,"uid: expected $attr, found $uid");
				}
			}
		  elsif ($key eq 'gid')
			{ $attr=&group2gid($attr);
			  if (defined $attr && $gid != $attr)
				{ push(@errs,"gid: expected $attr, found $gid");
				}
			}
		  elsif ($key eq 'linktext')
			{ my($linktext);

			  if (! -l $target)
				{}
			  elsif (! defined($linktext = readlink $target))
				{ push(@errs,"$key: readlink($target): $!");
				}
			  elsif ($linktext ne $attr)
				{ push(@errs,"$key: expected $attr, found $linktext");
				}
			}
		  elsif ($key eq 'id')
			{ # ident is used at install phase to link files
			}
		  else{push(@errs,"can't check attribute \"$key\" ($attr)"); }
		}

	  @errs;
	}

sub install	# (target,type,data,%attrs) -> @errs;
	{ my($target,$type,$data,%attrs)=@_;
	  my(@errs,$ok);

#	  warn "INSTALL $target (type=$type)\n";
#	  for (keys %attrs) { warn "\t$_=[$attrs{$_}]\n"; }

	  if (-d $target)
		{ @errs=sideways($target);
		  return @errs if @errs;
		}
	  elsif (-e $target)
		{ if ($::MoveSideways)
			{ return @errs if @errs=sideways($target);
			  # warn "REMOTE: moved $target\n";
			}
		  elsif (! unlink($target))
			{ return "unlink($target): $!";
			}
		  else
		  { # warn "REMOTE: unlinked $target\n";
		  }
		}

	  { my($parent)=dirname($target);
	    -d $parent 
		|| mkdir($parent,0755)
		|| return "mkdir($parent,0755): $!";
	  }

	  if ($type eq 'dir')
		{ if (! mkdir($target,0755))
			{ return "mkdir($target,0755): $!";
			}
		}
	  elsif ($type eq 'soft')
		{ my($linktext)=$attrs{'linktext'};

		  if (!length($linktext))
			{ return (@errs,"no linktext, can't make $target");
			}

		  unlink($target);
		  if (! symlink($linktext,$target))
			{ return "symlink($linktext,$target): $!";
			}
		}
	  elsif ($type eq 'file')
		{ my($ident)=$attrs{'id'};
		  if (length $ident
		   && defined $::Installed{$ident}
		   && link($::Installed{$ident},$target))
			{}
		  else
		  { if (! open(FILE,"> $target\0"))
			{ return "open-for-write($target): $!";
			}

		    if (! print FILE $data)
			{ push(@errs,"can't write data to $target: $!");
			}

		    if (! close(FILE))
			{ push(@errs,"close (or more probably flush) of $target fails: $!");
			}

		    if (! @errs && length $ident)
			{ $::Installed{$ident}=$target;
			}
		  }
		}
	  else	{ return "$target: can't install objects of type $type";
		}

	  if ($type ne 'soft')
		# chowning/chmodding symlinks is a dangerous game
		{ if (defined($attrs{'uid'}) && defined($attrs{'gid'})
		   && ! chown(&login2uid($attrs{'uid'}),
			      &group2gid($attrs{'gid'}),
			      $target))
			{ push(@errs,"chown(uid=$attrs{'uid'},gid=$attrs{'gid'},$target): $!");
			}

		  if (defined $attrs{'perm'})
			{ my($mode)=eval "0$attrs{'perm'}";

			  if (! chmod($mode,$target))
				{ push(@errs,
					"chmod($attrs{'perm'},$target): $!");
				}
			}

		  if (defined $attrs{'mtime'})
			{ $attrs{'atime'}=time if ! defined $attrs{'atime'};
			  if (! utime($attrs{'atime'},$attrs{'mtime'},$target))
				{ push(@errs,
					"utime($attrs{'atime'},$attrs{'mtime'},$target): $!");
				}
			}
		}

	  if (@errs) { system("ls -ld $target >&2"); }

	  @errs;
	}

sub snarfdir	# dir -> subnames
	{ local(@::Snarf);
	  &File::Find::find(\&snarf,@_);
	  @::Snarf;
	}

sub snarf
	{ my($n)=$File::Find::name;
	  # warn "snarf: name=[$n]\n";
	  push(@::Snarf,$n) if -f $n || -l $n;
	}

sub expand
	{ local($_)=@_;
	  my($front,$var);

	  $front='';
	  while (/{(\w+)}/)
		{ $front.=$`;
		  $var=$1;
		  $_=$';
		  $front.=(defined $ENV{$var}
				? $ENV{$var}
				: "{$var}");
		}

	  $front.$_;
	}

sub normpath
	{ local($_)=@_;
	  my($front,@parts,@norm);

	  m:^/*:;
	  $front=$&; $_=$';
	  @parts=split(m:/+:,$_);

	  for (@parts)
		{ if ($_ eq '' || $_ eq '.')	{}
		  elsif ($_ eq '..')		{ pop(@norm); }
		  else				{ push(@norm,$_); }
		}

	  $front.join('/',@norm);
	}

# ensure a directory exists
sub mkdir	# (dir,umask) -> ok
	{ my($dir,$mode)=@_;

	  # warn "isdir($dir)?\n";
	  -d "$dir/."
		|| (mkdir(dirname($dir),$mode)
		 && (-d "$dir/."
		  || ( # (warn "mkdir($dir)\n"),
			mkdir($dir,0777)
		     && chmod($mode,$dir)
		     )
		    )
		   )
	  ;
	}

sub dirname	# (@pathnames) -> @dirnames
	{ my(@paths)=@_;
	  my($pfx);

	  for (@paths)
	  	{ m,^(/?/?)/*,; $pfx=$1; $_=$';	# collect leading slashes
	  	  s,/+$,,;			# strip trailing slashes
	  	  s,[^/]+$,,;			# strip basename
	  	  s,/+$,,;			# strip trailing slashes again
	  	  length($pfx) || ($pfx='./');	# no null paths
		  $_=$pfx.$_;			# prefix + tail
		  s/\/+$//;			# no trailing slashed
		}

	  wantarray ? @paths : pop(@paths);
	}

sub sideways
	{ my($old)=@_;
	  my($new,$n);

	  N: for ($n=1; 1; $n++)
		{ $new="$old.$::SidewaysSfx-$n";
		  next N if -e $new;
		  last N if rename($old,$new);
		  return "rename($old,$new): $!";
		}

	  return ();
	}

sub sloshquote
	{ local($_)=@_;
	  s/[\s\\]/\\$&/g;
	  $_;
	}

sub noteTarget
	{ my($target,$type,$src)=@_;

	  if (! defined $::Packages{$::CurrentPackage})
		{ $::Packages{$::CurrentPackage}={};
		}

	  my($p)=$::Packages{$::CurrentPackage};

	  if (defined $p->{$target})
		{ warn "$::cmd: $::CurrentPackage: $::Context: target $target already defined at $p->{$target}->{Context}\n";
		  return 0;
		}

	  my $s;

	  if ($type ne DirTree && defined ($s=$::Source{$target}))
		{ $s=$::Source{$target};
		  if ($type ne $s->{Type} || $src ne $s->{Src})
			{ warn "$::cmd: $::Context: new spec for $target doesn't match old one from $s->{Context}\n";
			  return 0;
			}
		}
	  else
	  { $s={};
	    $s->{Target}=$target;
	    $s->{Context}=$::Context;
	    $s->{Type}=uc($type);
	    $s->{Src}=$src;
	    $::Source{$target}=$s;

	    # warn "$::Context: $target $type $src\n";
	  }

	  # save reference
	  if ($type eq DirTree)
		{ if (! exists $::Pending{$::CurrentPackage})
			{ $::Pending{$::CurrentPackcage}=[];
			}

		  push(@{$::Pending{$::CurrentPackage}},$s);
		}
	  else
	  { $p->{$target}=$s;
	  }

	  # warn "$::Context: $::CurrentPackage: add $target\n";
	  return 1;
	}

sub expandDirTree
	{ my($target,$src)=@_;
	  my($ok)=1;

	  $src =~ s:/$::;
	  $target =~ s:/$::;

	  # warn "expandDirTree($target,$src)\n";

	  my(@subnames)=snarfdir("$src/.");
	  # warn "subnames($src)=[@subnames]\n";
	  for (@subnames)
		{ substr($_,$[,length($src)+1)='';
		  noteTarget(normpath("$target/$_"),LOCAL,"$src/$_")
			|| ($ok=0);
		}

	  $ok;
	}
