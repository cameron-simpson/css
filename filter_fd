#!/bin/sh -u
#
# Filter an output filedescriptor.
#	- Cameron Simpson <cs@zip.com.au> 06may1999
#
# Multiple fds. - cameron, 23may1999
#

: ${TMPDIR:=/tmp}

cmd=$0	## `basename "$0"` ## perhaps a bit much overhead for this one
usage="Usage: $cmd fd[,fd...] filter command [args...]"

badopts=

# unfold multiple fds into separate invocations
case $1 in
    *,*)
		[ $# -gt 1 ] || { echo "$cmd: missing filter\n" >&2
				  echo "$usage" >&2
				  exit 2
				}
    		fds=$1 filter=$2
		shift; shift
		# rewrite the command line
    		for fd in `echo "$fds" | tr , ' '`
    		do set -- "$0" "$fd" "$filter" ${1+"$@"}
		done
		# rerun
		exec "$@"
		;;
esac

fd=
filter=
case $1 in
    [0-7])	fd=$1; shift ;;
    8|9)	echo "$cmd: sorry, fds 8 and 9 are trashed by $0" >&2
		badopts=1
		;;
    *)		echo "$cmd: bad fd - should be numeric" >&2
		badopts=1
		;;
esac

if [ -n "$fd" ]
then
    if [ $# = 0 ]
    then
	echo "$cmd: missing filter" >&2
	badopts=1
    else
	filter=$1; shift
	[ $# = 0 ] && { echo "$cmd: missing command" >&2
			badopts=1
		      }
    fi
fi

[ $badopts ] && { echo "$usage" >&2; exit 2; }

## echo "$cmd:: fd=$fd, filter=[$filter], *=[$*]" >&2

eval "exec 9>&1 8>&$fd"

xitcode=$TMPDIR/xit.$$
>$xitcode

( exec 8>&-	## we don't need 8 in this half
  [ $fd != 1 ] && eval "exec $fd>&1 1>&9"
  exec 9>&-
  "$@"
  echo $? >$xitcode
) | ( exec 3<&0		# save stdin to protect from bg disconnect
      ( exec <&3 3<&-	# reconnect stdin
	exec 9>&-	## we don't need 9 in this half
	exec 1>&8 8>&-
	case "$filter" in
	  *\ *)	eval "$filter" ;;
	  *)	exec "$filter" ;;
	esac
      ) &
    )

# collect exit status
while [ ! -s $xitcode ]; do sleep 1; done
xit=`cat $xitcode` || xit=1
rm -f $xitcode

[ -n "$xit" ] || { echo "$cmd: can't get exit code for $*" >&2
		   xit=1
		 }

exit "$xit"
