#!/bin/sh -u
#
# Filter an output file descriptor through an arbitrary shell command.
#	- Cameron Simpson <cs@zip.com.au> 06may1999
#
# Multiple fds. - cameron, 23may1999
#

: ${TMPDIR:=/tmp}

cmd=$0	## `basename "$0"` ## perhaps a bit much overhead for this one
usage="Usage: $cmd fd[,fd...] filter command [args...]"

badopts=

# unfold multiple fds into separate invocations
case $1 in
  *,*)
    [ $# -gt 1 ] || { echo "$cmd: missing filter\n" >&2
                      echo "$usage" >&2
                      exit 2
                    }
    fds=$1 filter=$2
    shift; shift
    # rewrite the command line
    for fd in `echo "$fds" | tr , ' '`
    do set -- "$0" "$fd" "$filter" ${1+"$@"}
    done
    # rerun
    exec "$@"
    ;;
esac

fd=
filter=
case $1 in
  [0-7])fd=$1; shift ;;
  8|9)	echo "$cmd: sorry, fds 8 and 9 are trashed by $0" >&2
        badopts=1
        ;;
  *)	echo "$cmd: bad fd - should be numeric" >&2
        badopts=1
        ;;
esac

if [ -n "$fd" ]
then
    if [ $# = 0 ]
    then
	echo "$cmd: missing filter" >&2
	badopts=1
    else
	filter=$1; shift
	[ $# = 0 ] && { echo "$cmd: missing command" >&2
			badopts=1
		      }
    fi
fi

[ $badopts ] && { echo "$usage" >&2; exit 2; }

## echo "$cmd:: fd=$fd, filter=[$filter], *=[$*]" >&2

eval "exec 9>&1 8>&$fd"

xitcode=$TMPDIR/xit.$$
>$xitcode

( exec 8>&-	## we don't need 8 in this half
  [ $fd != 1 ] && eval "exec $fd>&1 1>&9"
  exec 9>&-
  "$@"
  echo $? >$xitcode
) | ( exec 3<&0		# save stdin to protect from bg disconnect
      ( exec <&3 3<&-	# reconnect stdin
	exec 9>&-	## we don't need 9 in this half
	exec 1>&8 8>&-
        eval "$filter"
      ) &
    )

# close stdout, repoint to stderr just in case
exec 1>&2

# collect exit status
while [ ! -s $xitcode ]; do sleep 1; done
xit=`cat $xitcode` || xit=1
rm -f $xitcode

[ -n "$xit" ] || { echo "$cmd: can't get exit code for $*" >&2
		   xit=1
		 }

exit "$xit"
