#!/usr/bin/perl -w
#
# Read image paths on stdin, update index file.
#	- Cameron Simpson <cs@zip.com.au> 19jun2004
#

use strict qw(vars);

use cs::Upd;
use Getopt::Std;
use Image::Size;

my $upd = -t STDOUT;
my $indexfile = "INDEX";
my $mode = APPEND;
my @exts = (JPG,PNG,GIF);

$::Usage="Usage: $::cmd [-apu] [-e exts] [-f file] [{-|dirs...}]
	-a	Append mode - just append to the existing list.
	-p	Prune mode - drop images from the list now missing or empty.
	-u	Update mode - update the size data for existing list.
		Default mode: $mode
	-e exts	Comma separated list of case insensitive file extensions.
		Default: @exts
	-f file	Index filename. Default: $indexfile
		\"-\" means just write the index data to stdout.
	Saying \"-\" instead of dirs... reads paths from stdin.
";

{ my $badopts=0;
  my %opt;

  if (! getopts('apuef:',\%opt))
  { warn "$::cmd: bad options\n";
    $badopts=1;
  }

  if ($opt{'a'})	{ $mode=APPEND; }
  if ($opt{'p'})	{ $mode=PRUNE; }
  if ($opt{'u'})	{ $mode=UPDATE; }
  if (defined $opt{'e'}){ @exts=map(uc,grep(length,split(/[,\s]+/,$opt{'e'})));
			  die "$::cmd: can't have an empty extension list!"
				if ! @exts;
			}
  if (defined $opt{'f'}){ $indexfile=$opt{'f'}; }

  if (! @ARGV)
  { @ARGV=('.');
  }

  if ("@ARGV" ne '-')
  { open(STDIN,'-|','set-x','find',@ARGV,'(','-type','d','-name','.?*','-prune',')','-o','(','-type','f','-size','+0','-print',')')
	|| die "$::cmd: can't pipe from find: $!";
  }

  die $::Usage if $badopts;
}

%::IMX=();
%::IMY=();

my @stdin=();

nl("read new image list ...") if $upd;
INPUT:
while (defined($_=<STDIN>))
{
  chomp;
  s:^\./+::;
  next INPUT unless m:\.([^./]+)$:;	# skip stuff with no extension
  my $ext = uc($1);
  next INPUT unless grep($_ eq $ext, @exts); # skip unsupported extensions
  out($_) if $upd;
  push(@stdin,$_);
}
##close(STDIN); # trips "STDIN reopened" warning later:-(
out('') if $upd;

if (! @stdin)
{ nl("no new files") if $upd;
  exit 0;
}

my($err,$x,$y,$impath,@s);

if ($mode ne APPEND && $indexfile ne '-')
{
  nl("loading existing list ...") if $upd;
  if (open(INDEX,"< $indexfile"))
  {
    OLDINDEX:
    while (defined($_=<INDEX>))
    { chomp;
      out("$indexfile, $.: $_") if $upd && $. % 10 == 0;

      # skip bad lines
      next OLDINDEX if !/^(\d+) (\d+) (\S.*)/;

      ($x,$y,$impath)=($1,$2,$3);

      # prune missing/empty files
      next OLDINDEX if ! (@s=stat($impath));
      next OLDINDEX if ! -f _ || ! -s _;

      if ($mode eq UPDATE)
      {
	($x,$y,$err)=eval { imgsize($impath) };
	if ($@)
	{ warn "$::cmd: imsize($impath): $@\n";
	  ($x,$y)=(0,0);	# save repolling on subsequent passes
	}
      }

      $::IMX{$impath}=$x;
      $::IMY{$impath}=$y;
    }
    close(INDEX);
    out('') if $upd;
  }
  else
  { $err = "$!";
    if (-e $indexfile)
    { die "$::cmd: can't read $indexfile: $err";
    }
  }
}

@stdin=sort @stdin;
nl("update new images ...") if $upd;

my $n=0;
my $nn=@stdin;

NEWIMAGE:
for $impath (@stdin)
{
  $n++;

  $impath =~ s:^\./+::;
  out(int($n*100/$nn)."%: $impath") if $upd && $n % 10 == 0;

  # skip known images
  next NEWIMAGE if exists $::IMX{$impath};

  # skip missing/empty images
  next NEWIMAGE if ! (@s=stat($impath));
  next NEWIMAGE if ! -f _ || ! -s _;

  ($x,$y,$err)=eval { imgsize($impath) };
  if ($@)
  { warn "$::cmd: imsize($impath): $@\n";
    ($x,$y)=(0,0);	# record; saves repolling on subsequent passes
  }

  if (! defined $x)
  { warn "updimlist: $impath: $err (possible errno \"$!\")\n";
    next NEWIMAGE;
  }

  $::IMX{$impath}=$x;
  $::IMY{$impath}=$y;
}
out('') if $upd;

out("update $indexfile ...") if $upd;
if ($indexfile eq '-')
{ if (!open(INDEX,">&STDOUT"))
  { die "$::cmd; dup(STDOUT,INDEX): $!";
  }
}
elsif (!open(INDEX,($mode eq APPEND ? ">> $indexfile\0" : "> $indexfile\0")))
{ die "$::cmd: open($indexfile): $!\n";
}

for $impath (sort keys %::IMX)
{ print INDEX "$::IMX{$impath} $::IMY{$impath} $impath\n";
}
close(INDEX);
exit 0;
