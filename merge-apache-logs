#!/usr/bin/python -tt
#
# Merge Apache access logs named on the command line.
#       - Cameron Simpson <cs@zip.com.au> 30aug2007
#

import sys
from getopt import getopt, GetoptError
from datetime import datetime, timedelta
from cs.misc import cmd, cmderr

usage='''Usage: %s [-O] logfiles
  -M    Accept multiple leading IP addresses on a line, emit the last.
  -O    Require strict ordering in the input log files.
''' % cmd

requireOrdering=False
multiAddrs=False
badopts=False

try:
  opts, args = getopt(sys.argv[1:], 'MO')
except GetoptError, e:
  cmderr(e)
  badopts=True

if not badopts:
  for opt, value in opts:
    if opt == '-M':
      multiAddrs=True
    elif opt == '-O':
      requireOrdering=True
    else:
      assert True, "%s: unhandled option: %s" % (cmd, opt)

  if len(args) < 1:
    cmderr("missing logfiles")
    badopts=True

if badopts:
  sys.stderr.write(usage)
  sys.exit(2)

zones={}
def aptime(logline):
  fields = logline.split(' ')
  if len(fields) < 5:
    cmderr("bad log line: %s" % logline)
    return None

  humantime, tzinfo = fields[3:5]
  if len(humantime) != 21 or not humantime.startswith('['):
    cmderr("bad human time (%s) in log line: %s" % (humantime, logline))
    return None

  try:
    dt=datetime.strptime(humantime, "[%d/%b/%Y:%H:%M:%S")
  except ValueError, e:
    cmderr(str(e))
    return None

  global zones
  if tzinfo not in zones:
    if len(tzinfo) != 6 \
    or tzinfo[0] not in '+-' \
    or not tzinfo[1:5].isdigit() \
    or not tzinfo.endswith(']'):
      cmderr("bad timezone offset (%s) in log line: %s" % (humantime, logline))
      return None

    tzoff=(int(tzinfo[1:3])*60+int(tzinfo[3:5]))*60
    if tzinfo[0] == '+':
      tzoff = -tzoff
    zones[tzinfo]=timedelta(0,tzoff)

  tzoff=zones[tzinfo]
  dt += tzoff

  ##print "%s %s => %s" % (humantime, tzinfo, dt.isoformat())

  return dt

class LogFile:
  def __init__(self,filename):
    self.filename=filename
    if filename.endswith('.gz'):
      import gzip
      self.fp=gzip.open(filename)
    else:
      self.fp=open(filename)
    self.lineno=0

  def lines(self):
    global cmd, requireOrdering, multiAddrs
    if multiAddrs:
      import re
      leadingAddrRe = re.compile(r'[^ ,]*, *')

    olddt=None
    for line in self.fp:
      self.lineno+=1
      if line[-1] != '\n':
        cmderr("%s, line %d: unexpected EOF: %s" \
            % (self.filename, self.lineno, line))
        break

      line=line[:-1]

      if multiAddrs:
        m=leadingAddrRe.match(line)
        while m is not None:
          line=line[m.end():]
          m=leadingAddrRe.match(line)

      dt=aptime(line)
      if dt is None:
        continue

      if requireOrdering:
        assert olddt is None or olddt <= dt, \
              "%s: %s, line %d: out of order timestamps: %s" \
              % (cmd, self.filename, self.lineno, line)
      olddt=dt

      yield line, dt

queues = [ LogFile(arg).lines() for arg in args ]
lines  = [None] * len(queues)

while len(queues) > 0:
  choice = None
  i=0
  while i < len(queues):
    if lines[i] is None:
      try:
        nline, ndt = queues[i].next()
      except StopIteration:
        # EOF on file, remove file from queue
        del queues[i]
        del lines[i]
        continue
      lines[i] = (nline, ndt)

    if choice is None or lines[i][1] < lines[choice][1]:
      choice=i

    i+=1

  if choice is not None:
    print lines[choice][0]
    lines[choice]=None
  else:
    assert len(queues) == 0
