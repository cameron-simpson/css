#!/usr/bin/python
#
# Recode of mklinks in Python, partly for the exercise and partly to
# improve the algorithm.
#	- Cameron Simpson <cs@zip.com.au> 21may2006
#

import sys
import os
import os.path
import stat
import filecmp
import md5
from cs.misc import progress, warn, verbose, debug, chomp, tmpdirn, tmpfilename

sizeinfo={}
identinfo={}
pathinfo={}

noAction=False

def st_ident(st):
  return str(st[stat.ST_DEV])+":"+str(st[stat.ST_INO])

class FileInfo:
  def __init__(self,path,st):
    self.path=path
    self.paths=[]
    self.ident=st_ident(st)
    self.size=st[stat.ST_SIZE]
    self.mtime=st[stat.ST_MTIME]
    self.md5pfx=None
    self.addpath(path)
    debug("new FileInfo ident =",self.ident,"size =",str(self.size),":",path)

  def addpath(self,path):
    self.paths.append(path)
    pathinfo[path]=self

  def getmd5pfx(self):
    if self.md5pfx is None:
      self.md5pfx=md5pfx(self.path)
    return self.md5pfx

  def subsume(self,other):
    for path in other.paths:
      other.paths.remove(path)
      linkto(self.path,path)

    # discard mention of other
    if other in sizeinfo[self.size]: sizeinfo[self.size].remove(other)
    identinfo[other.ident]=self.path

# fetch md5 hash of first 8192 bytes of the file
def md5pfx(path,size=8192):
  ##progress("md5", path)
  return md5.new(file(path).read(size)).digest()

def linkto(srcpath,dstpath):
  progress(srcpath,"=>",dstpath)
  dstdir=os.path.dirname(dstpath)
  global noAction
  if not noAction:
    tmpf=tmpfilename(dstdir)
    ##assert not os.path.lexists(tmpf) # not in python 2.3 :-)
    try:
      lstat(tmpf)
    except OSError:
      pass
    else:
      assert False, "%s: already exists!" % tmpf
    os.link(srcpath,tmpf)
    os.rename(tmpf,dstpath)
  pathinfo[srcpath].addpath(dstpath)

def do(path):
  ''' Process each file in the directory tree.
      If a file is known by dev:ino,
	if another file is preferred,
	  replace with other file
	  add this path to other file list
	else
	  add this path to this file list
      else
	if this is the first file of this size
	  stash it, but don't open it for prefix md5
	else
	  o
  '''
  ##progress("DO", path)
  try:
    st=os.lstat(path)
  except os.OSerr, e:
    cmderr(path+": "+str(e))
    return

  if not stat.S_ISREG(st[stat.ST_MODE]):
    return

  ident=st_ident(st)
  if ident in identinfo:
    # known file
    info=identinfo[ident]
    if type(info) is str:
      # known to be replaceable - replace
      ##progress("know to replace",path,"by",info)
      linkto(info,path)
      return

    # just note new path for this file
    debug("note new instance of",info.path,":",path)
    info.addpath(path)
    return

  # new file, note it
  info=identinfo[ident]=FileInfo(path,st)

  size=st[stat.ST_SIZE]
  if size not in sizeinfo:
    # new size, nothing to compare to; save and return
    debug("new size",size,"on file",path)
    sizeinfo[size]=[info]
    return

  # existing size - compare against files of same size
  md5=info.getmd5pfx()
  for other in sizeinfo[size]:
    ##warn("cmp", path, "vs", other.path)
    if md5 == other.getmd5pfx() and filecmp.cmp(path,other.path):
      # same contents
      # keep newest file
      if info.mtime >= other.mtime:
        # we are newer (or as new)
        # push us to the front of the comparison list
        # discard the older file
        sizeinfo[size].insert(0,info)
        info.subsume(other)
        return

      # we are older - keep newer file
      ##progress("I am older, subsume", other.path)
      other.subsume(info)
      return

  # no other file matches - add this file to the size list
  debug("no matches, size",size,"+",path)
  sizeinfo[size].append(info)

def slotfile(size):
  slot=0
  while size > 0:
    size/=16
    slot+=1

  global slotfiles
  global slotpaths
  while slot >= len(slotfiles):
    slotfiles.append(None)
    slotpaths.append(None)

  ##print "slot =", slot, "len(slotfiles) =", len(slotfiles)
  if slotfiles[slot] is None:
    slotpaths[slot]=os.path.join(slotdir,str(slot))
    slotfiles[slot]=file(slotpaths[slot],'w')

  return slotfiles[slot]

def scatter(path):
  st=os.lstat(path)
  if not stat.S_ISREG(st[stat.ST_MODE]):
    return
  f=slotfile(st[stat.ST_SIZE])
  f.write(path)
  f.write('\n')

splitMode=False
slotdir=None
if sys.argv[1] == "--split":
  splitMode=True
  del sys.argv[1]
  slotfiles=[]
  slotpaths=[]
  slotdir=tmpdirn()

for path in sys.argv[1:]:
  if path == "-":
    for line in sys.stdin:
      line=chomp(line)
      if splitMode:
        scatter(line)
      else:
	do(line)
  else:
    for dirpath, dirnames, filenames in os.walk(path):
      progress(dirpath)
      filenames.sort()
      for name in filenames:
	subpath=os.path.join(dirpath,name)
	if splitMode:
	  scatter(subpath)
	else:
	  do(subpath)
      dirnames.sort()

if splitMode:
  for slotfile in slotfiles:
    if slotfile:
      slotfile.close()

  slotpaths.reverse()	# do big files first
  for path in slotpaths:
    if path:
      progress("mklinks - <"+path)
      os.system("exec <"+path+"; rm "+path+"; exec "+sys.argv[0]+" -")

if slotdir:
  os.rmdir(slotdir)
