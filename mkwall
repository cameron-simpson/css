#!/bin/sh -u
#
# Construct a wallpaper image by resizing a source image and padding.
# Pulled from rootbg and updated to use GraphicsMagick.
# Writes new image to a persistent cache in PNG format and prints the pathname.
#	- Cameron Simpson <cs@zip.com.au> 11sep2003
#

: ${BG:=black}
: ${TMPDIR:=/tmp}
: ${WALLPAPER_SHADE:=100}
: ${XINERAMA:=''}

# set $bgx and $bgy
eval `bgsize -v | sed 's/^d/bg/'`

doauto=1

cmd=`basename "$0"`
usage="Usage: $cmd [-g geom] [-bg bg-colour] imagefiles..."

badopts=

shade=$WALLPAPER_SHADE

while [ $# -gt 0 ]
do
  case "$1" in
    +a)	doauto= ;;
    -bg)BG=$2; shift ;;
    -sh)shade=$2; shift ;;
    -g)	geom=$2; shift
	ok=1
	bgx=`expr "x$geom" : 'x\([1-9][0-9]*\)x[1-9][0-9]*$'` || ok=
	bgy=`expr "x$geom" : 'x[1-9][0-9]*x\([1-9][0-9]*\)$'` || ok=
	[ $ok ] \
	    || { echo "$cmd: bad geometry for -g: expected XxY, found \"$geom\"" >&2
		 badopts=1
	       }
	;;
    --)	shift; break ;;
    -?*)echo "$cmd: unrecognised option: $1" >&2; badopts=1 ;;
    *)	break ;;
  esac
  shift
done

if [ $# = 0 ]
then
  echo "$cmd: missing imagefile" >&2
  badopts=1
else
  if [ $doauto ] && [ $# -eq 1 ] && [ $XINERAMA ]
  then  set -- "$1" "$1"
	bgx=`expr "$bgx" '*' "$XINERAMA_NX"` || exit 1
  fi
  if [ $# -eq 1 ]
  then montage=
  else montage=1
  fi
fi

[ $badopts ] && { echo "$usage" >&2; exit 2; }

##########################################
# Multiple images - assemble into montage.
if [ $montage ]
then
    xit=0
    [ $# = 2 ] || { echo "$cmd: only two images supported at present" >&2
		    exit 2
		  }
    hx=`expr $bgx / 2` || exit 1
    bg1=`mkwall +a -g "${hx}x${bgy}" "$1"` || exit 1

    if [ "x$1" = "x$2" ]
    then  bg2=$bg1
    else  bg2=`mkwall +a -g "${hx}x${bgy}" "$2"` || exit 1
    fi

    tmpf=$TMPDIR/$cmd$$.png
    # +label
    gm montage \
		-tile 2x1 \
		+label \
		-resize "${bgx}x${bgy}" \
		-geometry "${hx}x${bgy}+0+0" "$bg1" \
		-geometry "${hx}x${bgy}+0+0" "$bg2" \
		"png:$tmpf" || exit 1
    montage=`filecache "$tmpf"` || exit 1
    rm "$tmpf"
    echo "$montage"
    exit $xit
fi

##########################################
# Single image - scale to fit.
imagefile=$1; shift

# if stdin-ish name, fetch and convert to PNG
case "$imagefile" in
  X:*|-|*:-|\|* | http://* | ftp://* )
    imagefile=`fileof "$imagefile"` || exit 1
    imagefile=`pngof  "$imagefile"` || exit 1
    ;;
esac

# get image size
ix= iy=
eval `imsize-gm "$imagefile" | awk '{print "ix="$1 " iy="$2}'`
[ -n "$ix" -a -n "$iy" ] \
	|| { echo "$cmd: can't deduce source image size" >&2; exit 1; }

convname=pngof
set gm convert "$imagefile"

convname=$convname/sh$shade
if [ "x$shade" != x100 ]
then
  ## -modulate does the wrong thing ## set "$@" -modulate "$shade"
  case "$shade" in
    [0-9])	mulshade=0.0$shade ;;
    [0-9][0-9]*)mulshade=0.$shade ;;
    *)		echo "$cmd: upsupported shade \"$shade\", expected 0-99" >&2
		exit 1
		;;
  esac
  set "$@" \
      -normalize \
      -operator red Multiply "$mulshade" \
      -operator green Multiply "$mulshade" \
      -operator blue Multiply "$mulshade"
fi

convname=$convname/${bgx}x${bgy}
bx=0 by=0
if [ "x${bgx}x${bgy}" != "x${ix}x${iy}" ]
then
  # must rescale

  # compute width of borders
  awkf="BEGIN { ix=$ix; iy=$iy; bgx=$bgx; bgy=$bgy
       "'       w=bgx; h=bgy
	      }
	END   { if (ix > bgx || iy > bgy)
		  # too big - shrink
		  if (ix/bgx > iy/bgy)
		    # shrink X more than Y
		    h=int(iy * (bgx/ix))
		  else
		    # shrink Y more than X
		    w=int(ix * (bgy/iy))
		else
		# smaller image - scale up
		if (bgx/ix < bgy/iy)
		  # scale X less - use that
		  h=iy*bgx/ix
		else
		  # scale Y less
		  w=ix*bgy/iy

		w+=w%2
		h+=h%2
		bx=int((bgx-w)/2)
		by=int((bgy-h)/2)
		print "bx="bx " by="by
	      }'

  eval `awk "$awkf" </dev/null`

  set "$@" -geometry "${bgx}x${bgy}"
fi

convname=$convname/pad-${bx}x${by}-$BG
if [ "$bx" -gt 0 -o "$by" -gt 0 ]
then
    set "$@" -bordercolor "$BG" -border "${bx}x${by}"
fi

exec convof -C "$convname" -discard "$imagefile" "$@" -quality 100 png:-
