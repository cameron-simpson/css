#!/usr/bin/perl
#
# Shuffle and select pages of well-formed PostScript.
#	- Cameron Simpson, February 1992
#
# Notes:
#	The select range selects on the input physical pages, but the -r and
#	-num,... options apply before pages are rejected by the selector.
#
#	Ditroff/psdit output defines the font select operators at their
#	first use, so if you select pages with pshuf rather than through the
#	-o option to troff you probably need to select the first physical
#	page in addition to the desired pages. Locate the pattern:
#		^/f\..*def$
#	in the PostScript output. I could, I guess, add a hack to grab these
#	and move them into the Prolog, but jeez...
#

($cmd=$0) =~ s,.*/,,;
$usage="Usage: $cmd [-r] [-o page-range] [-num,num,...] [--] [files...]
	-r	Reverse pages.
	-o	Output only page-range physical pages.
	-num,.. or -O num,..
		Reorder every max(num,...) pages in the order given.
";

$badargs=0;
$reverse=0;
$feedback=0;
@Shuffles=();
@Select=();
ARGV:
  while (@ARGV)
	{ $_=$ARGV[0];
	  if ($_ eq '-r' || /^-\d+(,\d+)*$/)
				{ s/^-//;
				  push(@Shuffles,$_);
				  shift;
				}
	  elsif (/^-O/)		{ push(@Shuffles,shift(@ARGV)); }
	  elsif (/^-o/)		{ shift;

				  if (/^-o(.+)/)	{ $range=$1; }
				  else			{ $range=shift; }

				  if (! defined $range)
					{ warn "$cmd: missing page range for -o option\n";
					  $badargs=1;
					}
				  elsif (defined(@sel=&numrange($range)))
					{ push(@Select,@sel);
					}
				  else
				  { warn "$cmd: bad page range ($range) for -o option\n";
				    $badargs=1;
				  }
				}
	  elsif ($_ eq '--')	{ shift; last ARGV; }
	  elsif (/^-/)		{ warn "$cmd: unknown option '$_'\n";
				  $badargs=1;
				  shift;
				}
	  else
	  { last ARGV;
	  }
	}

die $usage if $badrags;

$tmp="/tmp/$cmd.$$";
open(TMP,"+>$tmp") || die "$cmd: can't open temporary file: $!\n";
unlink($tmp) || warn "$cmd: warning: can't unlink($tmp): $!\n";

$feedback && print STDERR "reading ";
undef $theTrailer;
@Offsets=();
@Pages=();
while (<>)
	{ if (/^%%Page:\s*\S+\s+(\d+)/)
		{ $feedback && print STDERR ".";
		  $page=$1;
		  push(@Offsets,tell(TMP));
		  push(@Pages,$page);
		}
	  elsif (/^%%Trailer/)
		{ $feedback && print STDERR "T";
		  $theTrailer=$_;
		  last;
		}

	  print TMP $_;
	}

$feedback && print STDERR "\n";
die "$cmd: no page markers found\n" if $#Offsets < 0;

for (@Shuffles)
	{ if ($_ eq 'r')
		{ @Offsets=reverse @Offsets;
		  @Pages=reverse @Pages;
		}
	  else
	  # num,...
	  { @nums=split(/,/);
	    warn "nums=[@nums]\n";
	    $max=0;
	    for (@nums)
		{ die "zeroes not permitted in range\n" if $_ == 0;

		  if ($_ > $max)
			{ $max=$_; }
		}

	    # finish off the list if it's incomplete
	    if ($#nums != $max-1)
		{ for ($i=1; $i <= $max; $i++)
			{ $ok=0;
			  for (@nums)
				{ if ($_ == $i)
					{ $ok=1;
					  last;
					}
				}

			  # add missing number
			  if (!$ok)
				{ push(@nums,$i);
				}
			}

	    	  warn " -> nums=@nums\n";
		}

	    # warn "max=$max\n";
	    # pad array with dummy pages - XXX: this may be a misfeature
	    $pad=$max - ($#Offsets+1) % $max;
	    # warn "pad=$pad\n";
	    if ($pad)
		{ for ($i=0; $i < $pad; $i++)
			{ push(@Offsets,&addpage(TMP));
			  push(@Pages,0);
			}
		}

	    # walk through offsets in chunks of size $max
	    for ($i=0; $i <= $#Offsets; $i+=$max)
		{ warn "[@Offsets[$i..($i+$max-1)]] -> ";
		  for (@chunk=(), @pchunk=(), $j=0; $j<$max; $j++)
			{ push(@chunk,$Offsets[$i+$nums[$j]-1]);
			  push(@pchunk,$Pages[$i+$nums[$j]-1]);
			}

		  @Offsets[$i..($i+$max-1)]=@chunk;
		  @Pages[$i..($i+$max-1)]=@pchunk;
		  warn "[@Offsets[$i..($i+$max-1)]]\n";
		}
	  }
	}

seek(TMP,0,0) || die "$cmd: can't rewind temporary file\n";

# Emit prolog.
$feedback && print STDERR "prolog ...";
&copypage(TMP);
$feedback && print STDERR "\n";

warn "\$#Pages ($#Pages) != \$#Offsets ($#Offsets)\n" if $#Pages != $#Offsets;
for ($n=$[; $n <= $#Offsets; $n++)
	{ next if (!&selected($Pages[$n]));

	  $_=$Offsets[$n];
	  if (!seek(TMP,$_,0))
		{ warn "$cmd: can't seek to $_ in temporary file: $!\n";
		}
	  else
	  { # warn "seek($_) ok\n";
	    &copypage(TMP);
	  }
	}

if (defined($theTrailer))
	{ $feedback && print STDERR "trailer ...";
	  print $theTrailer;
	  while (<>)
		{ print;
		}

	  $feedback && print STDERR "\n";
	}

####################

sub copypage	# (FILE) -> void
	{ local($FILE)=$_[0];

	  if (defined($_=<$FILE>))
		{ print;
		  while (<$FILE>)
			{ last if /^%%Page:\s*\d+\s+\d/;
			  print;
			}
		}
	}

# Make a dummy page as filler.
sub addpage	# (FILE) -> offset
	{ local($FILE)=$_[0];
	  local($where,$oldFILE)=(tell($FILE),select($FILE));

	  print "%%Page: 9999 9999\nshowpage\n";

	  select($oldFILE);

	  # warn "addpage returns $where\n";
	  $where;
	}

# Convert a page range to a list of numbers.
sub numrange	# (range-string) -> @numberlist
	{ local($_)=@_;
	  local(@list);
	  local($first,$last,$n);

	  s/^\s+//;
	  while (/^(\d+)\s*/)
		{ $first=$1;
		  $_=$';
		  if (/^-\s*(\d+)\s*/)
			{ $last=$1;
			  $_=$';
			  for ($n=$first; $n <= $last; $n++)
				{ push(@list,$n);
				}
			}
		  else
		  { push(@list,$first);
		  }

		  s/^,\s*//;	# permit comma separators
		}

	  return length($_) ? undef : @list;
	}

# Is a page a selected page? Not very fast.
sub selected	# (pagenum) -> selected
	{ if ($#Select < $[)
		{ return 1;
		}

	  local($n)=@_;

	  for (@Select)
		{ return 1 if ($n == $_);
		}

	  return 0;
	}
