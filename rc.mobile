#!/bin/sh
#
# rc.mobile	Site specific network config.
#
# For a roving laptop.
# Some more doco here:
#	http://www.cskk.ezoshosting.com/cs/css/#rc.mobile
# - Cameron Simpson <cs@zip.com.au>
#
# =head1 NAME
#
# rc.mobile - run system startup scripts in various combinations for mobile hosts
#
# =head1 SYNOPSIS
#
# rc.mobile {start|stop|restart} [-n] [-y] [-s] [-S] [-f config] [-E envfile] [@where]
#
# =head1 DESCRIPTION
#
# I<rc.mobile> runs startup scripts
# for a machine that may startup in various locations,
# and therefore require multiple configurations and combinations of services.
# There is a little discussion of its installation here:
#
#	http://www.cskk.ezoshosting.com/cs/css/#rc.mobile
#
# In addition to choosing different configurations based on location or circumstance,
# I<rc.mobile> also starts the services in parallel,
# yielding significantly faster boot times.
# There are facilities for specifying that one service depends on another
# and for running arbitrary shell commands
# for actions not encapsulated in standard startup files.
# In a sense
# the locations represent a generalisation of the idea of run levels.
#

where=${SYSTEMID:-home}
cf=/etc/rc.mobile.conf
envfile=
async=1
asyncall=1
trace=set-x
int=1

cmd=$0
usage="Usage: $cmd {start|stop|restart} [-n] [-f config] [@where]
	-n		No action. Recite proposed actions.
	-y		Yes: proceed with the default location without asking.
	-s		Synchronous. Default: asynchronous.
	-S		Really synchronous. Default: asynchronous.
	-f config	Specify config file.
			Default: $cf
	@where		Default location. Falls back to \$SYSTEMID or \"home\".
			Default: $where"

LC_ALL=C
PATH=$PATH:/sbin:/opt/css/bin
export PATH LC_ALL

# See how we were called.
mode=$1; shift

# =head1 ACTIONS
#
# =over 4
#
case "$mode" in
  # =item start
  #
  # Run the startup actions.
  # 
  start)action=up
	int=1
        ;;
  # =item stop
  #
  # Unimplemented.
  #
  stop) action=down
	echo "$cmd: action $mode unsupported" >&2
	exit 2
        ;;
  # =item restart
  #
  # Run B<rc.mobile stop> and then B<rc.mobile start>.
  #
  restart)
	$trace "$cmd" stop && $trace "$cmd" start ${1+"$@"}
	exit $?
	;;
  *)	echo "$usage" >&2
        exit 1
esac

# =back
#
# =head1 OPTIONS
#
# =over 4
#

badopts=
while :
do  case $1 in
	# =item B<-f> I<config>
	#
	# Specify a configuration file to use instead of B</etc/rc.mobile.conf>.
	#
	-f)   cf=$2; shift ;;
	# =item B<-n>
	#
	# No action.
	# Recite proposed actions.
	# handy for debugging configuration file changes.
	#
	-n)   trace=echo ;;
	# =item B<-y>
	#
	# Yes.
	# Proceed with the default location without asking.
	#
	-y)   int= ;;
	# =item B<-s>
	#
	# Synchronous.
	# Wait for all dispatched actions to complete before exiting B<rc.mobile>.
	# Normally the script will quit after everything is dispatched
	# so as to have the system offer a login prompt as soon as possible.
	# Some users find the completion messages appearing after the
	# login prompt annoying, thus this option.
	#
	-s)   async= ;;
	# =item B<-S>
	#
	# Really synchronous.
	# In addition to waiting before exit,
	# wait for each service script to complete.
	# This pretty much obviates the speed advantages of B<rc.mobile>
	# but might be useful during debugging.
	#
	-S)   async= asyncall= ;;
	# =item B<-E> I<envfile>
	#
	# Save environment settings to the file I<envfile>.
	# Configuration lines of the form "I<var>B<=>I<value>"
	# set environment variables
	# available to further startup actions issued by B<rc.mobile>.
	# If the B<-E> option is supplied
	# a shell script named I<envfile> is created containing
	# these settings.
	# For example, the option "C<-E /etc/profile.d/rc.mobile.sh>"
	# might be used to stash these settings where (on RedHat machines)
	# login shells will automatically use them.
	# Further, the first line of the file defines a shell function called
	# B<setenv> that acts like the csh directive of that name,
	# and the settings are then perfomred with that function.
	# Therefore, the C</etc/login> file may obtain the same
	# startup settings with the simple incantation:
	#
	#	eval `sed 1d /etc/profile.d/rc.mobile.sh`
	#
	# suitably adjusted to match your B<-E> option setting,
	# thus performing this function for csh(1) and tcsh(1) users.
	# 
	-E)   envfile=$2; shift
	      echo 'setenv(){ eval "export $1=\$2"; }' >"$envfile" \
	      || { echo "$cmd: can't write to $envfile" >&2
		   badopts=1
		   envfile=
		 }
	      ;;
	--)   shift; break ;;
	-?*)  echo "$cmd: unrecognised option: $1" >&2
	      badopts=1
	      ;;
	*)    break
	      ;;
    esac
    shift
done

# =back
#
# =head1 LOCATION
#
# If the optional argument B<@I<where>> is supplied after the options above,
# use that as the default location.
#
case "$1" in
  @?*)
    where=`expr "x$1" : 'x@\(.*\)'`
    shift
    ;;
esac

[ $# = 0 ] || { echo "$cmd: extra arguments: $*" >&2; badopts=1; }

[ $badopts ] && { echo "$usage" >&2; exit 2; }

[ -s "$cf" ] || { echo "$cmd: missing config file $cf" >&2; exit 1; }

locations=`sed -n -e '/^#/d' -e 's/^\\[@\\([a-z].*\\)\\]$/\\1/p' "$cf"`

# =head1 OPERATION
#
# B<rc.mobile> asks the user where it it running
# (unless the B<-y> option is supplied).
# The locations offered are taken from the clauses whose names commence with an "@",
# discarding the "@".
# The default location comes from the environment variable B<$SYSTEMID>,
# defaulting to "B<home>" if this is not set.
#
# After obtaining the current location
# (referring to as "I<where>" below)
# the clauses B<GLOBAL> and I<where> are in that order.
#

if [ $int ]
then
    echo "$cmd - bring up interface according to location"
    echo -n "I know ["$locations"] Where am I [$where]? "
    read iwhere || { echo; exit 1; }
    [ -n "$iwhere" ] && where=$iwhere
fi

doclause()
{
  for clause
  do
    winclause "$cf" "$clause" \
    | sed -e 'y/	/ /' \
	  -e 's/^  *//' \
	  -e '/^#/d' \
	  -e '/^$/d' \
    | while read op etc
      do
	if [ "x$op" = xuse ]
	then
	  doclause $etc
	else
	  echo "$op $etc"
	fi
      done
  done
}

doops()
{
  while read op etc
  do
    # =head1 CONFIGURATION FILE FORMAT
    #
    # The configuration file file
    # resembles a Windows ".ini" file.
    # Blank lines and lines commencing with an octothorpe (`#')
    # are comments, and discarded.
    #
    # The remainder consists of clauses marked out by lines of the form:
    #
    #	[name]
    #
    # where I<name> is the clause name.
    #
    # Clauses contain the following types of lines:
    #
    # =over 4
    #
    # =item B<use> I<clauses...>
    #
    # Process the named I<clauses> in order at this point.
    #
    case "$op" in
      # =item I<var>B<=>I<value>
      #
      # Set the environment variable named I<var> to the value I<value>.
      # If the B<-E> option was used, also record the value in I<envfile>.
      #
      [a-zA-Z]*=*)
	      var=`expr "$op" : '\([^=]*\)=.*'`
	      eval "$op"
	      export $var
	      if [ -n "$envfile" ]
	      then
		  eval "val=\$$var"
		  case "$val" in
		      *\'*) val=`echo "$val" | sed "s/'/'\\\\\\\\''/g"` ;;
		  esac
		  echo "setenv $var '$val';" >>"$envfile"
	      fi
	      ;;
      # =item /path/to/dir/
      #
      # Prepare the spacified directory
      # from a template.
      # The template is the directory named
      # B</path/to/dir.>I<where> or B</path/to/dir.DFLT>
      # if the former is not present.
      # If neither is present, the target directory is unchanged.
      # Otherwise, the directory is made identical to the template
      # with rsync(1).
      #
      /*/)    to=`expr "x$op" : 'x\(.*\)/'`
	      from=
	      for d in $from.$where $from.DFLT
	      do  [ -d "$d/." ] && { from=$d; break; }
	      done
	      if [ -n "$from" ]
	      then
		$trace rsync -aH "$from/." "$to/."
	      else
		echo "no master dir @$where for $to" >&2
	      fi
	      ;;
      # =item /path/to/file
      #
      # Prepare the specified file
      # from a template.
      # Files and directories are distinguished
      # by the directory's trailing slash (`/').
      # The template is the file named
      # B</path/to/file.>I<where> or B</path/to/file.DFLT>
      # if the former is not present.
      # If neither is present, the target file is unchanged.
      # Otherwise, the file is made identical to the template with cp(1).
      #
      /*)     to=$op
	      from=
	      for f in $to.$where $to.DFLT
	      do  [ -f "$f" ] && { from=$f; break; }
	      done
	      if [ -n "$from" ]
	      then
		$trace cp -p "$from" "$to"
	      else
		echo "no master file @$where for $to" >&2
	      fi
	      ;;
      # =item ! I<shell command...>
      #
      # The specified I<shell command> is run synchronously.
      #
      \!*)	shcmd=`expr "x$op $etc" : 'x.\(.*\)'`
	      $trace /bin/sh -c "$shcmd"
	      ;;
      # =item svc I<services...>
      #
      # The named services are started asynchronously.
      # They are dispatched by running the command:
      #
      #	/etc/init.d/service start
      #
      # in the background.
      #
      svc)    bgsvc $etc
	      ;;
      # =item need I<services...>
      #
      # Require the named services' startup scripts
      # to have completed before proceeding.
      # If any of the services have not been dispatched,
      # dispatch them as for the B<svc> directive
      # and then wait for them.
      #
      need)   needsvc $etc
	      ;;
      *)      echo "$cmd: unrecognised operator \"$op\": $op $etc" >&2
	      ;;
    esac
    # =back
    #
  done
}

bgsvc()
{
  for bgsvc
  do
    bgrc=/etc/init.d/$bgsvc
    if [ -s "$bgrc" ]
    then
      $trace "$bgrc" "$mode" &
      eval "pid_$bgsvc=$!"
      [ $asyncall ] || wait4pid $!
    else
      echo "$cmd: no init file named $bgrc" >&2
    fi
  done
}

needsvc()
{
  # dispatch undispatched services
  for needsvc
  do
    eval "nsvcpid=\$pid_$needsvc"
    [ -n "$nsvcpid" ] || bgsvc "$needsvc"
  done

  # wait for all the services
  for needsvc
  do
    wait4svc "$needsvc" 
  done
}
  
wait4svc()
{
  for waitsvc
  do  eval "wsvcpid=\$pid_$waitsvc"
      if [ -n "$wsvcpid" ]
      then  echo "Wait for $waitsvc ..."
	    wait4pid "$wsvcpid"
      fi
  done
}

wait4pid()
{
  for waitpid
  do
    while kill -0 "$waitpid" 2>/dev/null
    do  sleep 1
    done
  done
}

doclause GLOBAL "@$where" | { doops; [ $async ] || wait; }

# =head1 FILES
#
# B</etc/rc.mobile.conf>, the default configuration file
#
# =head1 ENVIRONMENT
#
# B<$SYSTEMID>, the default boot location
#
# =head1 SEE ALSO
#
# rsync(1), winclause(1cs)
#
# =head1 AUTHOR
#
# Cameron Simpson E<lt>cs@zip.com.auE<gt> July 2003
#
