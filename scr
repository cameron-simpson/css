#!/bin/sh -u
#
# Attach to specified screen or make new one of specified name.
#	- Cameron Simpson <cs@zip.com.au> 18may2002
#

: ${TMPDIR:=/tmp}
: ${SHELL:=/bin/sh}
: ${SCR_PREARGV='ssh-agent'}
: ${LANG:=en_US.UTF-8}

new=
detached=
rcfile=$HOME/.screenrc
tmprc=
screen=screen
case "$LANG" in
  *.[Uu][Tt][Ff]*)
    screen="$screen -U"
    ;;
esac

cmd=$0
usage="Usage:
    $cmd
	List sessions.
    $cmd -A [[!]regexp...]
	Put up terms for all matching screen sessions.
    $cmd [-c scrcmd]... [-l logfile] [-dm] -e cmd [args...]
	Start new session running the supplied command.
    $cmd [-c scrcmd]... [-l logfile] [-dm] session [cmd [args...]]
	Join named session, creating it if missing.
        -dm         Start the session detached.
	-c scrcmd  Run the supplied screen command in addition to the .screenrc
	-l logfile Log session to the named file.
		   You still need to turn logging on _in_ the session:-("

# nothing? list active sessions
[ $# = 0 ] \
    && { $screen -ls \
	 | sed '/^	/!d; s/^	\([^	]*\).*/\1/' \
	 | awk '{ print NR, $0 }'	## printf("%d %s\n",NR,$0) }'
	 exit 0
       }

# catch the "all sessions" mode early
if [ "x$1" = x-A ]
then
    shift
    [ -n "$DISPLAY" ] || { echo "$cmd: no \$DISPLAY!" >&2; exit 1; }
    grepfor=
    grepnot=
    for re
    do  case "$re" in
	  !*)	re=`expr "x$re" : 'x.\(.*\)'`
		if [ -n "$grepnot" ]
		then  grepnot="$grepnot|$re"
		else  grepnot=$re
		fi
		;;
	  *)	if [ -n "$grepfor" ]
		then  grepfor="$grepfor|$re"
		else  grepfor=$re
		fi
		;;
	esac
    done
    choose=scr
    [ -n "$grepnot" ] && choose="$choose | egrep -iv \"\$grepnot\""
    [ -n "$grepfor" ] && choose="$choose | egrep -i \"\$grepfor\""
    xit=0
    for scr in `eval "$choose" | awk '{print$1}'`
    do  term -iconic -e scr "$scr" || xit=1
    done
    exit $xit
fi

badopts=

addscrcmds()
{ for scrcmd
  do
    if [ -z "$tmprc" ]
    then
      tmprc=$TMPDIR/screenrc$$
      cat "$rcfile" >"$tmprc" 2>/dev/null
      rcfile=$tmprc
    fi
    echo "$scrcmd" >>"$tmprc"
  done
}

sess=
havecmd=

while [ $# -gt 0 ]
do
  case $1 in
    -c)	addscrcmds "$2"; shift ;;
    -dm)detached=1 ;;
    -e)	shift
	havecmd=1
	[ $# = 0 ] && { echo "$cmd: -e: missing command" >&2
			badopts=1
		      }
	break
	;;
    -l)	addscrcmds "logfile $2" "logfile flush 1" "log on"; shift ;;
    --)	shift; break ;;
    -?*)echo "$cmd: unrecognised option: $1" >&2
	badopts=1
	;;
    *)	break ;;
  esac
  shift
done

# no -e option? grab possible session and cmd
if [ -z "$havecmd" ]
then
  [ $# -gt 0 ] && { sess=$1; shift; }
  [ $# = 0 ] && set -- "$SHELL"
  set -- $SCR_PREARGV "$@"
fi

[ $badopts ] && { echo "$usage" >&2; exit 2; }

which screen >/dev/null \
|| { [ $detached ] && set -- acon "$@"
     echo "$cmd: no screen command? just running: $*" >&2
     set -x
     exec "$@"
   }

case "$TERM" in
  rxvt-*) TERM=rxvt ;;
esac

[ $detached ] && screen="$screen -d -m"

(
  # look for matching session if supplied
  if [ -n "$sess" ]
  then
    # otherwise convert $sess into session name to join
    case "$sess" in
      [1-9]|[1-9][0-9]|[1-9][0-9][0-9])
	# numeric - pull name from listing
	nsess=`scr | sed -n "s/^ *$sess //p"`
	[ -n "$nsess" ] || { echo "$cmd: no screen numbered $sess" >&2
			     exit 1
			   }
	# matched - join the session
	exec $screen -c "$rcfile" -x "$nsess"
	;;
    esac

    # not numeric - look up in listing

    # slashes forbidden in session - triggers multiuser mode
    case "$sess" in */*) sess=`printf "%s" "$sess" | tr / _` ;; esac

    case "$sess" in
      *[\\.]*)
	sessre=`printf "%s" "$sess" | sed 's/[\\.]/\\&/g'`
	;;
      *)sessre=$sess
	;;
    esac
    match=`scr | sed "/^ *[1-9][0-9]* [1-9][0-9]*\\.$sessre\$/!d;"'s/^ *[1-9][0-9]*  *//; q'`

    # match found - join it
    [ -n "$match" ] && exec $screen -c "$rcfile" -x "$sess"
  else
    sess=$*
    case "$sess" in */*) sess=`printf "%s" "$sess" | tr / _` ;; esac
  fi

  # start new session
  exec $screen -S "$sess" -c "$rcfile" -- "$@"
)
xit=$?

[ -z "$tmprc" ] || rm "$tmprc" || xit=1

exit $xit
