#!/usr/bin/perl
#
# Script to compute various environment parameters.
# Must be sourced, and defines the shell function setvar() as a consequence.
#	- Cameron Simpson, 18may93
#
# Removed -n option.
# Recoded not to recurse to bypass Sys5 shell braindamage. - cameron, 30jul93
# Recoded in Perl to bypass more shell braindamage.
# You don't source it anymore. - cameron, 07jan94
# Added -f to force resetting variables. - cameron, 11jan94
# Generalisation. - cameron, 02dec98
#

use Cwd;
use cs::Glob;
use cs::Misc;
use cs::Upd;
use cs::Net;
use cs::Shell;
use cs::Source;
use cs::Pathname;
use cs::Hier;

undef %::did;

# bootstrap some values
chomp($_=`pwd`);			setenv(PWD,$_);
chomp($_=`hostname`);			setenv(HOSTNAME,$_);
($_=$ENV{HOSTNAME}) =~ s/\..*//;	setenv(HOST,$_);
($_=$ENV{HOSTNAME}) =~ s/^[^.]*\.//;	setenv(HOSTDOMAIN,$_);
$_=(length($ENV{HOME}) ? $ENV{HOME} : userdir('cameron')); setenv(HOME,$_);

@ENVPATH=( length $ENV{ENVPATH}
	 ? grep(length,split(/:+/,$ENV{ENVPATH}))
	 : ("$ENV{HOME}/.setvar", "/opt/shell/env")
	 );

$usage="Usage:\t$::cmd [-f] varnames command [args...]
	$::cmd [-f] -n varnames...
	-c		Emit assignments in csh syntax.
	-d dir		Env dir (default: $ENVDIR).
	-f		Force. Rebuild variables even if set.
	-n		No exec, print shell assignments suitable for eval.
	-N file		No exec, print shell assignments suitable for eval to named file.
	-s		Silent. No non-fatal errors.
	-v		Verbose.
	-x		Turn on tracing in no-exec mode.
	varnames	Space separated list of environment variables needed.
";

$noexec=0;
$force=0;
$trace=0;
$verbose = -t STDOUT;
$silent  = ! $verbose;
$CshMode=0;
$badopts=0;
undef $outfile;
$keepOutfile=0;
ARGV:
  while (@ARGV)
  { $_=shift(@ARGV);
    last ARGV if $_ eq '--';
    (unshift(@ARGV,$_), last ARGV) unless /^-./;

    if ($_ eq '-n')	{ $noexec=1; $outfile="/tmp/$::cmd.$$"; }
    elsif ($_ eq '-N')	{ $noexec=1; $outfile=shift(@ARGV); $keepOutfile=1; }
    elsif ($_ eq '-f')	{ $force=1; }
    elsif ($_ eq '-d')	{ unshift(@ENVPATH,shift(@ARGV)); }
    elsif ($_ eq '-s')	{ $silent=1; $verbose=0; }
    elsif ($_ eq '-v')	{ $silent=0; $verbose=1; }
    elsif ($_ eq '-x')	{ $trace=1; }
    elsif ($_ eq '-c')	{ $CshMode=1; }
    else
    { err("$::cmd: $_: unrecognised option\n");
      $badopts=1;
    }
  }

if ($noexec)			{ @vars=@ARGV;
				}
elsif (!defined($_=shift))	{ err "$::cmd: missing varnames\n";
				  $badopts=1;
				}
elsif (!/^\s*[_\w]+(\s+[_\w]+)*\s*$/) { err "$::cmd: $_: bad varname list\n";
				  $badopts=1;
				}
else				{ @vars=grep(length,split(/,+/));
				}

die $usage if $badopts;

$::UseExtant=0;

envstuff();

if ($noexec)	{ if (defined($outfile))
		  { if (!open(OUTFILE,"> $outfile\0"))
		    { err "$::cmd: can't write to $outfile: $!\n";
		      undef $outfile;
		    }
		    else
		    { chmod(0755,$outfile);
		      select(OUTFILE);
		    }
		  }

		  # XXX - csh mode for -vx if ever restored
		  # print "set -vx\n" if $trace;

		  setvar(0,@vars);
		  # print "set +vx\n" if $trace;
		  finalvars();
		  strippaths();
		  putvars();

		  if (defined($outfile))
		  {
		    close(OUTFILE);

		    if ($CshMode)
		    { print STDOUT "source '$outfile'";
		    }
		    else
		    { print STDOUT ". '$outfile'";
		    }

		    if (! $keepOutfile)
		    { print STDOUT "; /bin/rm -f '$outfile'";
		    }

		    print STDOUT "\n";

		    stat($outfile) || warn "$::cmd: stat($outfile): $!\n";
		    # system("exec >&2; ls -ld $outfile; cat $outfile");
		  }
		}
else		{
	          setvar(0,@vars);
		  finalvars();
		  strippaths();
		  exec @ARGV;
		}

exit $::Xit;

sub envstuff
{
  my %env=();

  sub loadenvpath()
  {
    for my $dir (@ENVPATH)
    { my $vardir="$dir/var";

      if (-d "$vardir/.")
      # get files from dir
      {
	for my $f (cs::Pathname::dirents($vardir))
	{ $env{$f}="<$vardir/$f" if ! exists $env{$f};
	}
      }
      else
      # load file
      { if (open(LOADENV,"< $vardir\0"))
	{ local($_);

	  ENVLINE:
	  while (defined($_=<LOADENV>))
	  { chomp;
	    s/^\s+//;
	    s/^#.*//;
	    next ENVLINE if ! length;

	    if (! /^([^=]+)=/)
	    { warn "$::cmd: $vardir, line $.: bad format: $_\n";
	    }
	    else
	    { if (! exists $env{$1})
	      { $env{$1}="\"$'";
		## warn "loadenv: $1=\"$'";
	      }
	    }
	  }

	  close(LOADENV);
	}
      }
    }
  }

  sub needenv($)
  { my($var)=@_;
    return if defined($ENV{$var}) && length($ENV{$var});
    setvar(1,$var);
  }

  sub fetchenv($;$)
  { my($var,$missok)=@_;
    $missok=0 if ! defined $missok;

    my @extlist=
	 grep(length,
	 (
	  "$ENV{HOST}\@$ENV{SYSTEMID}",
	  "$ENV{ARCH}\@$ENV{SYSTEMID}",
	  $ENV{HOSTNAME},
	  $ENV{HOST},
	  $ENV{SYSTEMID},
	  $ENV{HOSTDOMAIN},
	  $ENV{OS},
	  $ENV{ARCH},
	 ))
	 ;

    for my $ext (@extlist, '')
    {
      my $key = length($ext) ? "$var.$ext" : $var;

      ## warn "key=[$key]";
      if (exists $env{$key})
      {
	my $val = $env{$key};
	## warn "hit on $key [$val]";
	my $type = substr($val,$[,1);
	substr($val,$[,1)='';

	if ($type eq '<')
	{ $val=efromfile($val);
	}
	else
	{ $val=estring($val,$missok);
	}

	return $val;
      }
    }

    if (! $missok)
    { warn "$::cmd: can't fetchenv(\$$var)\n";
    }
    return undef;
  }

  loadenvpath();
  for my $needvar (OS,ARCH,SYSTEMID)
  { needenv($needvar);
  }
}

sub setvar
{
  my(@vars)=@_;

  my $missok;
  if (@vars && $vars[0] =~ /^\d/)
  { $missok=shift(@vars)+0;
  }
  else
  { $missok=0;
  }

  return undef if ! @vars;

  my $lastvar = $vars[$#vars];

  local($_);
  local($::cmd)="$::cmd: setvar(@vars)";

  VAR:
  while (@vars)
  {
    $_=shift(@vars);

    $trace && out $_;

    if (/^use\s+/)
    { $_=$';
      map(usefile($_,0),grep(length,split(/\s+/)));
      next VAR;
    }

    if (/^try\s+/)
    { $_=$';
      map(usefile($_,1),grep(length,split(/\s+/)));
      next VAR;
    }

    next VAR if $::did{$_};
    $::did{$_}=1;

    if (!$force && defined($ENV{$_}) && length($ENV{$_}))
    # already set
    { next VAR;
    }

    $trace && out "$_=";

    my $val = fetchenv($_,$missok);
    if (defined $val)
    { setenv($_,$val);
    }
  }

  return $ENV{$lastvar};
}

sub fromfile
{ ## warn "fromfile(@_)";
  if (!open(FROMFILE,"< $_[0]\0"))
  { warn "$::cmd: can't open $_[0] for read: $!\n";
    return undef;
  }

  warn "$::cmd; $_[0] is not a file" unless -f FROMFILE;
  local($_)=join('',<FROMFILE>);
  close(FROMFILE);
  chomp;

  warn "fromfile($_[0])=[$_]" if /\n/;

  $_;
}

sub untilde($)
{ local($_)=@_;

  s;\~(\w*);(! length($`) || substr($`,-1,1) eq ':')
		? (length($1) ? userdir($1) : $ENV{HOME})
		: $&;eg;

  $_;
}

sub efromfile($$)
{ my($file,$missok)=@_;
  estring(fromfile($file),$missok);
}

sub estring($$)
{ my($str,$missok)=@_;
  $str =~ s;\$(\$|[_\w]+|\{[_\w]+\});varval($1,$missok);eg;
  return untilde($str);
}

sub varval($$)
{ local($var,$missok)=@_;

  return '$' if $var eq '$';

  local($::UseExtant)=1;
  
  /^\{(.*)\}$/
  ? setvar($missok,$1)
  : setvar($missok,$var)
  ;
}

sub shfile
{ if (!open(SHFILE,"< $_[0]\0"))
  { warn "$::cmd: can't open $_[0] for read: $!\n";
    return undef;
  }

  SHFILE:
    while (<SHFILE>)
    { chomp;
      next SHFILE if /^#/;
      if (/^\s*([a-zA-Z_][_\w]*)='([^']*)'/
       || /^\s*([a-zA-Z_][_\w]*)=(\S*)/
	 )
      { eval "\$$1=\$2";
      }
      else
      { warn "$::cmd: $SHFILE, line $.: can't parse: $_\n";
      }
    }

  close(SHFILE);
}

sub forget
{ ## warn "\nforget [@_]\n";
  for (@_)
  { $::did{$_}=$_;
    eval "\$$_=''";
  }
}

sub paths
{ my($pathvar)=@_;

  my @m=();

  for my $c (map(untilde($_), split(/:/,$pathvar)))
  {
    if ($c =~ /\*/)
    { push(@m,sort &cs::Glob::glob($c)); }
    else
    { push(@m,$c); }
  }

  @m;
}

sub strippaths
{ my(@vars)=@_;
  @vars=grep(/PATH$/, keys %ENV) if ! @vars;

  for my $var (@vars)
  { $ENV{$var}=cs::Shell::statpath(paths($ENV{$var}));
  }
}

sub userdir
{ my($u)=shift;
  my(@pw);

  if (! defined $_pw{$u})
  { $_pw{$u}=[ getpwnam($u) ];
    if (! @{$_pw{$u}})
    { ## warn "$::cmd: userdir($u): who is $u?\n";
      return undef;
    }
  }

  @pw=@{$_pw{$u}};

  return undef unless @pw;

  $pw[7];
}

sub usefile($;$)
{ my($ufile,$missok)=@_;
  $missok=0 if ! defined $missok;

  $trace && out("use $ufile");

  if (substr($ufile,0,1) ne '/')
  { my $found = 0;

   FINDIT:
    for my $udir (@ENVPATH)
    { if (stat "$udir/$ufile" && -f _ && -r _)
      { $ufile="$udir/$ufile";
	$ufile="$ENV{PWD}/$ufile" if substr($ufile,0,1) ne '/';
	$found=1;
	last FINDIT;
      }
      elsif (stat "$udir/$ufile/STANDARD" && -f _ && -r _)
      { $ufile="$udir/$ufile/STANDARD";
	$ufile="$ENV{PWD}/$ufile" if substr($ufile,0,1) ne '/';
	$found=1;
	last FINDIT;
      }
    }

    if (! $found)
    { if (! $missok)
      { warn "$::cmd: can't find file for \"use $ufile\" in @ENVPATH\n";
      }
      return;
    }
  }

  $trace && out("use $ufile");

  if ($::using{$ufile})
  { warn "$::cmd: use recursion aborted for use \"$ufile\"\n";
  }
  else
  { $::using{$ufile}=1;

    my $s = cs::Source::open($ufile);
    if (! defined $s)
    { warn "$::cmd: use $ufile: $!\n";
    }
    else
    {
      local $_;
      local($::cmd)="$::cmd: use($ufile)";

      # hack to make local paths work
      local @ENVPATH = (cs::Pathname::dirname($ufile), @ENVPATH);

      while (defined ($_=$s->GetContLine()) && length)
      { chomp;
	s/^\s+//;
	s/^#.*//;
	next if ! length;
	useline($_)
	  || warn "$::cmd: $ufile: syntax error: $_\n";
      }
    }

    $::using{$ufile}=0;
  }
}

sub useline($)
{ local($_)=@_;
  local($::cmd)="$::cmd:\n  $_:\n  ";

  if (/^eval\s+/)
  { $_=$';
    eval;
    warn "$::cmd: $@" if $@;
  }
  elsif (/^use\s+/)
  { $_=$';
    map(usefile($_,0),
	grep(length,
	     split(/\s+/,
		   estring($_,0))));
  }
  elsif (/^try\s+/)
  { $_=$';
    map(usefile($_,1),
	grep(length,
	     split(/\s+/,
		   estring($_,1))));
  }
  elsif (/^var\s+/)
  { $_=$';
    setvar(0,grep(length,
		split(/\s+/,
		      estring($_,0))));
  }
  elsif (/^tryvar\s+/)
  { $_=$';
    setvar(1,grep(length,
		split(/\s+/,
		      estring($_,0))));
  }
  elsif (/^final\s+/)
  { push(@::final,$');
  }
  elsif (/^perl\s+([_\w]+)\s+/)
  { my $var = $1;
    my @value = eval $';
    if ($@)
    { warn "$@ in:\n$'";
      $::Xit=1;
    }
    else
    { setenv($var,join(' ', @value));
    }
  }
  elsif (/^csh\s+/)
  {
    my $cshcmd = $';
    my $shcmd = cs::Shell::quote(
		  'tcsh','-c',
		  "$cshcmd; /opt/script/dumpenv -f -persist");
    ## warn "shcmd=[$shcmd]";
    strippaths();
    if (! open(CSH," set -x; exec $shcmd |"))
    { warn "$::cmd: popen-csh($cshcmd): $!\n";
      $::Xit=1;
    }
    else
    { my $csh = new cs::Source (FILE,::CSH);
      my $var; my $value;
      while ( ($var,$value)=cs::Hier::getKVLine($csh) )
      { setenv($var,$value);
	warn "read $var from csh\n";
      }
      close(CSH);
    }
  }
  elsif (/^([_\w]+)(\??)=/)
  { (! length $2 || ! length $ENV{$1}) && setenv($1,estring($',1));
  }
  else
  { return 0;
  }

  1;
}

sub setenv($$)
{ my($var,$val)=@_;
  $ENV{$var}=$val;
  $::did{$var}=1;
  $trace && nl("setenv $var=$val");
  $val;
}

sub finalvars
{ for (@::final)
  { useline($_)
	  || warn "$::cmd: final: syntax error: $_\n";
  }
}

sub putvars
{ my(@vars)=@_;
  @vars=keys %::did if ! @vars;

  @vars=grep($_ ne PWD, @vars);	# a r/o variable in some shells :-(

  cs::Shell::putvars($force,$CshMode ? CSH : SH,@vars);
}
