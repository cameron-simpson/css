#!/usr/bin/python -tt
#
# Command script for venti-ish implementation.
#       - Cameron Simpson <cs@zip.com.au> 01may2007
#
# =head1 NAME
#
# vt - access vt stores, a venti-like content addressed storage pool
#
# =head1 SYNOPSIS
#
#   vt [options...] cat filerefs...
#   vt [options...] catblock [-i] hashcodes...
#   vt [options...] listen port
#   vt [options...] ls [-R] dirrefs...
#   vt [options...] mount dirref mountpoint
#   vt [options...] scan datafile
#   vt [options...] pack paths...
#   vt [options...] pack -o file.vt path
#   vt [options...] unpack -
#   vt [options...] unpack file.vt
#
# =head1 DESCRIPTION
#
# I<vt> is a command accessing vt stores in various ways.
#
# A store is a content addressed pool of blocks
# with a filesystem abstraction layered on top of it.
#

from sys import argv, exit, stdin, stderr, stdout, exit
import os
import os.path
import atexit
from getopt import getopt, GetoptError
from cs.venti import tohex, fromhex
from cs.venti.store import Store
from cs.venti.cache import CacheStore, MemCacheStore
from cs.misc import cmd, cmderr, setcmd, warn, debug, progress
import cs.upd; cs.upd.default()

usage='''Usage:
  %s [options...] cat filerefs...
  %s [options...] catblock [-i] hashcodes...
  %s [options...] listen port
  %s [options...] ls [-R] dirrefs...
  %s [options...] mount dirref mountpoint
  %s [options...] scan datafile
  %s [options...] pack paths...
  %s [options...] pack -o file.vt path
  %s [options...] unpack -
  %s [options...] unpack file.vt
  Options:
    -C store    Use this as a front end cache store.
                "-" means no front end cache.
    -M          Don't use an additional MemCacheStore front end.
    -S store    Specify the store to use:
                  /path/to/dir  GDBMStore
                  tcp:host:port TCPStore
                  |sh-command   StreamStore via sh-command
''' % (cmd,cmd,cmd,cmd,cmd,cmd,cmd,cmd,cmd,cmd)

badopts=False

dflt_cache=os.environ.get('VT_STORE_CACHE')
dflt_vt_store=os.environ.get('VT_STORE')
useMemCache=True

S=None
def closeStore():
  if S is not None:
    S.close()
atexit.register(closeStore)

try:
  (opts,args)=getopt(argv[1:],'C:MS:')
except GetoptError, e:
  cmderr("unrecognised option: %s: %s"% (e.opt, e.msg))
  badopts=True

# =head1 OPTIONS
#
# =over 4
#
for (opt,val) in opts:
  # =item B<-C> I<store>
  #
  # Specify a caching store.
  # The special name "-" means no caching stope should be used.
  # If B<-C> is not used
  # the environment variable B<VT_STORE_CACHE> may specify the caching store.
  #
  if opt == '-C':
    if val == '-':
      dflt_cache=None
    else:
      dflt_cache=val
  # =item B<-M>
  #
  # Do not use the in-memory caching store.
  # Default is to place an in-memory cache ahead of the other stores.
  #
  elif opt == '-M':
    useMemCache=False
  # =item B<-S> I<store>
  #
  # Use the specified I<store>.
  # If B<-S> is not used
  # the environment variable B<VT_STORE> specifies the store.
  #
  elif opt == '-S':
    dflt_vt_store=val
  else:
    assert False, "unsupported option: %s" % opt

# =back
#
# =head1 Store Names
#
# Three store names are supported at present:
#
# =over 4
#
# =item B</>I<pathname>
#
# A full path to a directory specifies a local filesystem store
# in the directory B</>I<pathname>.
#
# =item B<tcp:>I<host>B<:>I<port>
#
# A name commencing with B<tcp:> specifies a TCP connection to a vt daemon
# listening on the specified I<host> and I<port>.
#
# =item B<unix:/>I<pathname>
#
# B<UNIMPLEMENTED>.
# A name commencing with B<unix:> specifies the pathname of a UNIX domain socket
# on which a vt daemon is listening.
#
# =item B<|>I<shell-command>
#
# A name commencing with shell pipe symbol specifies a proxy command
# to connect to a vt daemon. The command string is handed to B</bin/sh>
# and should accept vt requests on standard input and write vt responses to
# standard output.
#
# =back
#

if len(args) < 1:
  cmderr("missing command")
  badopts=True
else:
  # =head1 COMMANDS
  #
  # =over 4
  #
  op=args.pop(0)
  setcmd("%s: %s" % (cmd,op))
  if op == "cat":
    # =item B<cat> I<filerefs...>
    #
    # Emit the data content of the supplied I<filerefs> on the standard output.
    #
    if len(args) < 1:
      cmderr("missing filerefs")
      badopts=True
  elif op == "catblock":
    # =item B<catblock> [B<-i>] I<hashcodes...>
    #
    # Emit the content of the blocks specified by the supplied I<hashcodes>.
    # If the B<-i> (indirect) option is supplied,
    # consider the hashcode to specify an indirect block and emit
    # the data content of the leaf blocks.
    #
    indirect=False
    if len(args) > 0 and args[0] == "-i":
      indirect=True
      args.pop(0)
    if len(args) < 1:
      cmderr("missing hashcodes")
      badopts=True
  elif op == "listen":
    # =item B<listen> {B<->|[I<host>]B<:>I<port>}
    #
    # Start a vt daemon.
    #
    # The argument "-" specifie a single use daemon reading vt requests from
    # its standard input and writing replies to its standard output,
    # as it might run from inetd(8) or xinetd(8).
    #
    # An argument of the form I<host>B:>I<port> specifies that the daemon
    # should listen on the specified I<host> address and I<port> for connections.
    # if I<host> is omitted it defaults to B<127.0.0.1>.
    #
    if len(args) != 1:
      cmderr("expected a port")
      badopts=True
  elif op == "ls":
    # =item B<ls> [B<-R>] I<dirrefs...>
    #
    # Do a directory listing of the specified I<dirrefs>.
    # The B<-R> (recursive) option requests a recurive directory listing.
    #
    recurse=False
    if len(args) > 0 and args[0] == "-R":
      recurse=True
      args.pop(0)
    if len(args) < 1:
      cmderr("missing dirrefs")
      badopts=True
  elif op == "mount":
    # =item B<mount> I<dirref> I<mountpoint>
    #
    # B<INCOMPLETE>.
    # Mount the specified I<dirref> as on the specified I<mountpoint> directory.
    # Requires FUSE support.
    #
    if len(args) != 2:
      cmderr("expected dirref and mountpoint")
      badopts=True
  elif op == "pack":
    # =item B<pack> {B<-o> I<file.vt> I<pathname> | I<pathnames...>}
    #
    # Store each specified I<pathname> in the store.
    #
    # With the B<-o> (output) option, store a single pathname
    # in the store and record the resulting I<dirref> in the file I<file.vt>.
    # If the file I<file.vt> already exists,
    # do an incremental store against the last I<dirref> currently stored in the I<file.vt>;
    # files with the same size and mtime in I<pathname> as in their copies in the store
    # are not opened - they are presumed to be unchanged.
    # This is similar to the vac(1) command in the Venti system.
    #
    # Without the B<-o> option,
    # each I<pathname> is stored and the resulting I<dirref> reported on the standard output.
    #
    if len(args) > 0 and args[0] == "-o":
      if len(args) < 2:
        cmderr("-o: missing file.vt")
        badopts=True
      elif len(args) < 3:
        cmderr("missing path")
        badopts=True
      elif len(args) > 3:
        cmderr("extra arguments after path: %s" % " ".join(args[3:]))
        badopts=True
    elif len(args) < 1:
      cmderr("missing paths")
      badopts=True
  elif op == "scan":
    # =item B<scan> I<datafile>
    #
    # Read the specified I<datafile> as a vt block storage file,
    # a sequence of compressed data blocks.
    # Report on standard output
    # the block hashcode, I<datafile> file offset and compressed size.
    #
    if len(args) != 1:
      cmderr("missing datafile")
      badopts=True
  elif op == "unpack":
    # =item B<unpack> I<dirrefs...>
    #
    # Unpack the directory specified by each I<dirref> into the current working directory.
    # This is the inverse of the B<pack> command.
    # Currently, to unpack a B<.vt> file the most succinct command is this:
    #
    #   vt unpack `awk '{ hash=$1 } END { print hash }' file.vt`
    #
    if len(args) < 1:
      cmderr("missing dirrefs")
      badopts=True
  else:
    cmderr("unrecognised command")
    badopts=True
  # =back
  #

if dflt_vt_store is None:
  if op != "scan":
    cmderr("no $VT_STORE and no -S option")
    badopts=True

if badopts:
  stderr.write(usage)
  exit(2)

S=Store(dflt_vt_store)

if dflt_cache is not None:
  ##progress("push cache store %s" % dflt_cache)
  C=Store(dflt_cache)
  S=CacheStore(S,C)

# put an in-memory cache in front of the main cache
if useMemCache:
  S=CacheStore(S,MemCacheStore())

##progress("S=%s"%S)

def gethexarg(path):
  slash=path.find('/')
  if slash < 0:
    hexarg=path
    path=''
  else:
    hexarg=path[:slash]
    slash+=1
    while slash < len(path) and path[slash] == '/':
      slash+=1
    path=path[slash:]
  from cs.venti.blocks import str2BlockRef
  debug("fromhex(%s)..." % hexarg)
  fhex=fromhex(hexarg)
  bref=str2BlockRef(fhex)
  return bref, path

def resolve(path, domkdir=False):
  bref, path = gethexarg(path)
  from cs.venti.fs import FS
  return FS(S,bref).root.resolve(path,domkdir)

def path2bref(path,domkdir=False):
  bref, path = gethexarg(path)
  debug("bref=%s, path=%s"%(bref,path))
  if len(path) > 0:
    from cs.venti.fs import FS
    F=FS(S,bref)
    debug("F=%s, F.root=%s" % (F,F.root))
    D, name = F.root.resolve(path,domkdir)
    if D is None or name not in D:
      debug("resolve fails")
      return None
    return D.name2bref(name)
  return bref

def vtopen(path, mode='r', domkdir=False):
  bref, path = gethexarg(path)
  if len(path) > 0:
    D, name = FS(S,bref).root.resolve(path,domkdir)
    return D.open(name,mode)
  import cs.venti.file
  return cs.venti.file.open(S,mode,bref)

def ls(path,D,recurse,fp=None):
  if fp is None:
    fp=stdout
  ##warn("ls %s: bref=%s"%(path,("s:"+tohex(bref) if type(bref) is str else "bref.h:"+tohex(bref.h))))
  fp.write(path)
  fp.write(":\n")
  if not recurse:
    names=D.dirs()+D.files()
    names.sort()
    for name in names:
      E=D[name]
      bref=E.bref()
      fp.write("%c %-41s %-6d %s\n" % (('d' if D.isdir(name) else 'f'), bref, bref.span, name))
  else:
    dirs=D.dirs(); dirs.sort()
    files=D.files(); files.sort()
    for name in files:
      E=D[name]
      bref=E.bref()
      fp.write("%c %-41s %-6d %s\n" % (('d' if D.isdir(name) else 'f'), bref, bref.span, name))
      assert not D.isdir(name), name+" should not be a directory!"
    for name in dirs:
      fp.write("\n")
      ls(os.path.join(path,name),D.chdir1(name),recurse,fp)

def cat(path,fp=None):
  if fp is None:
    fp=stdout
  bref=path2bref(path)
  if bref is None:
    cmderr("%s: no such file or directory" % path)
  else:
    for b in bref.leaves(S):
      fp.write(b)

def storePath(path,targetRef=None,ignoreTimes=False,deleteMissing=False,overWrite=False):
  from cs.venti.fs import FS
  import cs.venti.store
  assert isinstance(S, cs.venti.store.BasicStore), "S=%s"%S
  D=FS(S,targetRef).updateDir(path,
                    ignoreTimes=ignoreTimes,
                    deleteMissing=deleteMissing,
                    overWrite=overWrite)
  return D.sync()

if op == "pack":
  if len(args) == 0 or args[0] != '-o':
    for path in args:
      ref=storePath(path)
      stdout.write(tohex(ref.encode()))
      if len(args) > 1:
        stdout.write('\t')
        stdout.write(path)
      stdout.write('\n')
  else:
    archive=args[1]
    path=args[2]
    from cs.venti.blocks import str2BlockRef
    import datetime
    if archive is None:
      archive="%s.vt" % os.path.basename(path)
    target=None
    if os.path.isfile(archive):
      hexarg=None
      for line in open(archive):
        assert line[-1] == '\n'
        words=line[:-1].strip().split(' ')
        if len(words) == 0:
          continue
        if words[0].startswith("#"):
          continue
        hexarg=words[0]
      if hexarg is not None:
        target=str2BlockRef(fromhex(hexarg))
    saved=storePath(path,targetRef=target,ignoreTimes=False,deleteMissing=True,overWrite=True)
    open(archive,mode='a').write("%s %s %s\n" % (saved, datetime.datetime.now(), path))

elif op == "cat":
  for path in args:
    cat(path)

elif op == "catblock":
  for hexarg in args:
    if indirect:
      bl
    else:
      stdout.write(S[fromhex(hexarg)])

elif op == "scan":
  from cs.venti.datafile import scanFile
  for h, offset, zsize in scanFile(open(args[0])):
    print tohex(h), offset, zsize

elif op == "listen":
  assert len(args) == 1
  arg=args[0]
  if arg == '-':
    from cs.venti.stream import StreamDaemon
    daemon=StreamDaemon(S,stdin,stdout)
    daemon.start()
    daemon.join()
  else:
    cpos=arg.rfind(':')
    if cpos >= 0:
      host=arg[:cpos]
      port=arg[cpos+1:]
      if len(host) == 0:
        host='127.0.0.1'
      port=int(port)
      import cs.venti.tcp
      srv=cs.venti.tcp.Server((host,port),S)
      srv.serve_forever()
    else:
      cmderr("invalid listen argument, I expect \"-\" or \"[host]:port\", got \"%s\"" % arg)
      exit(1)

elif op == "ls":
  first=True
  for path in args:
    if first:
      first=False
    else:
      print
    print "ls", path, "..."
    D, name = resolve(path)
    D=D.chdir1(name)
    ls(path,D,recurse,stdout)

elif op == "mount":
  print "mount", args[0], args[1], "..."
  if not os.path.isdir(args[1]):
    cmderr("%s: mountpoint is not a directory" % args[1])
    exit(1)
  E=S.namei(args[0]+'/')
  assert E.isdir, "%s: %s: expected directory, not file"%(cmd,args[0])
  import cs.venti.vtfuse
  cs.venti.vtfuse.fusemount(args[1],S,E)

elif op == "unpack":
  for path in args:
    D, name = resolve(path)
    if len(name) > 0:
      D=D.chdir1(name)
    for subD, dirs, files in D.walk(topdown=True):
      if len(subD.path) > 0 and not os.path.isdir(subD.path):
        print "mkdir", subD.path
        os.makedirs(subD.path)
      files.sort()
      for fname in files:
        assert len(fname) > 0 and fname != '.' and fname != '..' and fname.find('/') < 0, \
          "%s: unpack: %s: illegal filename \"%s\"" % (cmd, subD.path, fname)
        fpath=os.path.join(subD.path,fname)
        print "extract", fpath
        outfp=open(fpath,mode='w')
        for b in subD[fname].bref().leaves(S):
          outfp.write(b)
        outfp.close()

else:
  cmderr("unsupported command")
  exit(2)

S.close()
debug("%s: exit main command"%cmd)
