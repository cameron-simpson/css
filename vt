#!/usr/bin/python -tt
#
# Command script for venti-ish implementation.
#       - Cameron Simpson <cs@zip.com.au> 01may2007
#

from sys import argv, exit, stdin, stderr, stdout, exit
import os
import os.path
import atexit
from getopt import getopt, GetoptError
from cs.venti import tohex, fromhex
from cs.venti.store import Store
from cs.venti.cache import CacheStore, MemCacheStore
from cs.misc import cmd, cmderr, setcmd, warn, debug, progress
import cs.upd; cs.upd.default()

usage='''Usage:
  %s [options...] cat filerefs...
  %s [options...] catblock [-i] hashcodes...
  %s [options...] listen port
  %s [options...] ls [-R] dirrefs...
  %s [options...] mount dirref mountpoint
  %s [options...] store pathnames...
  %s [options...] update [-o file.vt] path
  %s [options...] unpack dirref
  Options:
    -C store    Use this as a front end cache store.
                "-" means no front end cache.
    -M          Don't use an additional MemCacheStore front end.
    -S store    Specify the store to use:
                  /path/to/dir  GDBMStore
                  tcp:host:port TCPStore
                  |sh-command   StreamStore via sh-command
''' % (cmd,cmd,cmd,cmd,cmd,cmd,cmd,cmd)

badopts=False

dflt_cache=os.environ.get('VT_STORE_CACHE')
dflt_vt_store=os.environ.get('VT_STORE')
useMemCache=True

S=None
def closeStore():
  if S is not None:
    S.close()
atexit.register(closeStore)

try:
  (opts,args)=getopt(argv[1:],'C:MS:')
except GetoptError, e:
  cmderr("unrecognised option: %s: %s"% (e.opt, e.msg))
  badopts=True

for (opt,val) in opts:
  if opt == '-C':
    if val == '-':
      dflt_cache=None
    else:
      dflt_cache=val
  elif opt == '-M':
    useMemCache=False
  elif opt == '-S':
    dflt_vt_store=val
  else:
    assert False, "unsupported option: %s" % opt

if dflt_vt_store is None:
  cmderr("no $VT_STORE and no -S option")
  badopts=True

if len(args) < 1:
  cmderr("missing command")
  badopts=True
else:
  op=args.pop(0)
  setcmd("%s: %s" % (cmd,op))
  if op == "store":
    if len(args) < 1:
      cmderr("missing pathnames")
      badopts=True
  elif op == "update":
    archive=None
    if len(args) >= 2 and args[0] == "-o":
      archive=args[1]
      args=args[2:]
    if len(args) == 0:
      cmderr("missing path")
      badopts=True
    elif len(args) > 1:
      cmderr("extra arguments after path: %s" % " ".join(args[1:]))
      badopts=True
  elif op == "cat":
    if len(args) < 1:
      cmderr("missing filerefs")
      badopts=True
  elif op == "catblock":
    indirect=False
    if len(args) > 0 and args[0] == "-i":
      indirect=True
      args.pop(0)
    if len(args) < 1:
      cmderr("missing hashcodes")
      badopts=True
  elif op == "listen":
    if len(args) != 1:
      cmderr("expected a port")
      badopts=True
  elif op == "ls":
    recurse=False
    if len(args) > 0 and args[0] == "-R":
      recurse=True
      args.pop(0)
    if len(args) < 1:
      cmderr("missing dirrefs")
      badopts=True
  elif op == "mount":
    if len(args) != 2:
      cmderr("expected dirref and mountpoint")
      badopts=True
  elif op == "unpack":
    if len(args) != 1:
      cmderr("expected exactly one dirref")
      badopts=True
  else:
    cmderr("unrecognised command")
    badopts=True

if badopts:
  stderr.write(usage)
  exit(2)

S=Store(dflt_vt_store)

if dflt_cache is not None:
  ##progress("push cache store %s" % dflt_cache)
  C=Store(dflt_cache)
  S=CacheStore(S,C)

# put an in-memory cache in front of the main cache
if useMemCache:
  S=CacheStore(S,MemCacheStore())

##progress("S=%s"%S)

def gethexarg(path):
  slash=path.find('/')
  if slash < 0:
    hexarg=path
    path=''
  else:
    hexarg=path[:slash]
    slash+=1
    while slash < len(path) and path[slash] == '/':
      slash+=1
    path=path[slash:]
  from cs.venti.blocks import str2BlockRef
  debug("fromhex(%s)..." % hexarg)
  fhex=fromhex(hexarg)
  bref=str2BlockRef(fhex)
  return bref, path

def resolve(path, domkdir=False):
  bref, path = gethexarg(path)
  from cs.venti.fs import FS
  return FS(S,bref).root.resolve(path,domkdir)

def path2bref(path,domkdir=False):
  bref, path = gethexarg(path)
  debug("bref=%s, path=%s"%(bref,path))
  if len(path) > 0:
    from cs.venti.fs import FS
    F=FS(S,bref)
    debug("F=%s, F.root=%s" % (F,F.root))
    D, name = F.root.resolve(path,domkdir)
    if D is None or name not in D:
      debug("resolve fails")
      return None
    return D.name2bref(name)
  return bref

def vtopen(path, mode='r', domkdir=False):
  bref, path = gethexarg(path)
  if len(path) > 0:
    D, name = FS(S,bref).root.resolve(path,domkdir)
    return D.open(name,mode)
  import cs.venti.file
  return cs.venti.file.open(S,mode,bref)

def ls(path,D,recurse,fp=None):
  if fp is None:
    fp=stdout
  ##warn("ls %s: bref=%s"%(path,("s:"+tohex(bref) if type(bref) is str else "bref.h:"+tohex(bref.h))))
  fp.write(path)
  fp.write(":\n")
  if not recurse:
    names=D.dirs()+D.files()
    names.sort()
    for name in names:
      E=D[name]
      bref=E.bref()
      fp.write("%c %-41s %-6d %s\n" % (('d' if D.isdir(name) else 'f'), bref, bref.span, name))
  else:
    dirs=D.dirs(); dirs.sort()
    files=D.files(); files.sort()
    for name in files:
      E=D[name]
      bref=E.bref()
      fp.write("%c %-41s %-6d %s\n" % (('d' if D.isdir(name) else 'f'), bref, bref.span, name))
      assert not D.isdir(name), name+" should not be a directory!"
    for name in dirs:
      fp.write("\n")
      ls(os.path.join(path,name),D.chdir1(name),recurse,fp)

def cat(path,fp=None):
  if fp is None:
    fp=stdout
  bref=path2bref(path)
  if bref is None:
    cmderr("%s: no such file or directory" % path)
  else:
    for b in bref.leaves(S):
      fp.write(b)

def storePath(path,targetRef=None,ignoreTimes=False,deleteMissing=False,overWrite=False):
  from cs.venti.fs import FS
  import cs.venti.store
  assert isinstance(S, cs.venti.store.BasicStore), "S=%s"%S
  D=FS(S,targetRef).updateDir(path,
                    ignoreTimes=ignoreTimes,
                    deleteMissing=deleteMissing,
                    overWrite=overWrite)
  return D.sync()

if op == "store":
  for path in args:
    ref=storePath(path)
    stdout.write(tohex(ref.encode()))
    if len(args) > 1:
      stdout.write('\t')
      stdout.write(path)
    stdout.write('\n')
  S.sync()

elif op == "update":
  from cs.venti.blocks import str2BlockRef
  import datetime
  path=args[0]
  if archive is None:
    archive="%s.vt" % os.path.basename(path)
  target=None
  if os.path.isfile(archive):
    hexarg=None
    for line in open(archive):
      assert line[-1] == '\n'
      words=line[:-1].strip().split(' ')
      if len(words) == 0:
        continue
      if words[0].startswith("#"):
        continue
      hexarg=words[0]
    if hexarg is not None:
      target=str2BlockRef(fromhex(hexarg))
  saved=storePath(path,targetRef=target,ignoreTimes=False,deleteMissing=True,overWrite=True)
  open(archive,mode='a').write("%s %s %s\n" % (saved, datetime.datetime.now(), path))

elif op == "cat":
  for path in args:
    cat(path)

elif op == "catblock":
  for hexarg in args:
    if indirect:
      bl
    else:
      stdout.write(S[fromhex(hexarg)])

elif op == "listen":
  assert len(args) == 1
  arg=args[0]
  if arg == '-':
    from cs.venti.stream import StreamDaemon
    daemon=StreamDaemon(S,stdin,stdout)
    daemon.start()
    daemon.join()
  else:
    cpos=arg.rfind(':')
    if cpos >= 0:
      host=arg[:cpos]
      port=arg[cpos+1:]
      if len(host) == 0:
        host='127.0.0.1'
      port=int(port)
      import cs.venti.tcp
      srv=cs.venti.tcp.Server((host,port),S)
      srv.serve_forever()
    else:
      cmderr("invalid listen argument, I expect \"-\" or \"[host]:port\", got \"%s\"" % arg)
      exit(1)

elif op == "ls":
  first=True
  for path in args:
    if first:
      first=False
    else:
      print
    print "ls", path, "..."
    D, name = resolve(path)
    D=D.chdir1(name)
    ls(path,D,recurse,stdout)

elif op == "mount":
  print "mount", args[0], args[1], "..."
  if not os.path.isdir(args[1]):
    cmderr("%s: mountpoint is not a directory" % args[1])
    exit(1)
  E=S.namei(args[0]+'/')
  assert E.isdir, "%s: %s: expected directory, not file"%(cmd,args[0])
  import cs.venti.vtfuse
  cs.venti.vtfuse.fusemount(args[1],S,E)

elif op == "unpack":
  for path in args:
    D, name = resolve(path)
    if len(name) > 0:
      D=D.chdir1(name)
    for subD, dirs, files in D.walk(topdown=True):
      if len(subD.path) > 0 and not os.path.isdir(subD.path):
        print "mkdir", subD.path
        os.makedirs(subD.path)
      files.sort()
      for fname in files:
        assert len(fname) > 0 and fname != '.' and fname != '..' and fname.find('/') < 0, \
          "%s: unpack: %s: illegal filename \"%s\"" % (cmd, subD.path, fname)
        fpath=os.path.join(subD.path,fname)
        print "extract", fpath
        outfp=open(fpath,mode='w')
        for b in subD[fname].bref().leaves(S):
          outfp.write(b)
        outfp.close()

else:
  cmderr("unsupported command")
  exit(2)

S.close()
debug("%s: exit main command"%cmd)
