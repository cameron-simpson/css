#!/usr/bin/python -tt
#
# Command script for venti-ish implementation.
#       - Cameron Simpson <cs@zip.com.au> 01may2007
#

from sys import argv, exit, stderr, stdout, exit
import os
import os.path
from cs.venti import tohex, fromhex
import cs.misc
from cs.misc import cmd, cmderr, setcmd, warn

usage='''Usage:
  %s [-S store] cat filerefs...
  %s [-S store] catblock [-i] hashcodes...
  %s [-S store] listen port
  %s [-S store] ls [-R] dirrefs...
  %s [-S store] mount dirref mountpoint
  %s [-S store] store pathnames...
  %s [-S store] update [-o file.vt] path
  %s [-S store] unpack dirref
''' % (cmd,cmd,cmd,cmd,cmd,cmd,cmd,cmd)

badopts=False

S=None

args=argv[1:]
if len(args) > 0 and args[0] == '-S':
  S=Store(args[1])
  args=arg[2:]

if len(args) < 1:
  cmderr("missing command")
  badopts=True
else:
  op=args.pop(0)
  setcmd("%s: %s" % (cmd,op))
  if op == "store":
    if len(args) < 1:
      cmderr("missing pathnames")
      badopts=True
  elif op == "update":
    archive=None
    if len(args) >= 2 and args[0] == "-o":
      archive=args[1]
      args=args[2:]
    if len(args) == 0:
      cmderr("missing path")
      badopts=True
    elif len(args) > 1:
      cmderr("extra arguments after path: %s" % " ".join(args[1:]))
      badopts=True
  elif op == "cat":
    if len(args) < 1:
      cmderr("missing filerefs")
      badopts=True
  elif op == "catblock":
    indirect=False
    if len(args) > 0 and args[0] == "-i":
      indirect=True
      args.pop(0)
    if len(args) < 1:
      cmderr("missing hashcodes")
      badopts=True
  elif op == "listen":
    if len(args) != 1:
      cmderr("expected a port")
      badopts=True
  elif op == "ls":
    recurse=False
    if len(args) > 0 and args[0] == "-R":
      recurse=True
      args.pop(0)
    if len(args) < 1:
      cmderr("missing dirrefs")
      badopts=True
  elif op == "mount":
    if len(args) != 2:
      cmderr("expected dirref and mountpoint")
      badopts=True
  elif op == "unpack":
    if len(args) != 1:
      cmderr("expected exactly one dirref")
      badopts=True
  else:
    cmderr("unrecognised command")
    badopts=True

if S is None:
  dflt_vt_store=os.environ.get('VT_STORE')
  if dflt_vt_store is None:
    cmderr("no $VT_STORE and no -S option")
    badopts=True
  else:
    from cs.venti.store import Store
    S=Store(dflt_vt_store)

if badopts:
  stderr.write(usage)
  exit(2)

def gethexarg(path):
  slash=path.find('/')
  if slash < 0:
    hexarg=path
    path=''
  else:
    hexarg=path[:slash]
    slash+=1
    while slash < len(path) and path[slash] == '/':
      slash+=1
    path=path[slash:]
  from cs.venti.blocks import str2BlockRef
  bref=str2BlockRef(fromhex(hexarg))
  return bref, path

def resolve(path, domkdir=False):
  bref, path = gethexarg(path)
  from cs.venti.fs import FS
  return FS(S,bref).root.resolve(path,domkdir)

def path2bref(path):
  bref, path = gethexarg(path)
  if len(path) > 0:
    D, name = FS(S,bref).root.resolve(path,domkdir)
    return D.name2bref(name)
  return bref

def vtopen(path, mode='r', domkdir=False):
  bref, path = gethexarg(path)
  if len(path) > 0:
    D, name = FS(S,bref).root.resolve(path,domkdir)
    return D.open(name,mode)
  import cs.venti.file
  return cs.venti.file.open(S,mode,bref)

def ls(path,D,recurse,fp=None):
  if fp is None:
    fp=stdout
  ##warn("ls %s: bref=%s"%(path,("s:"+tohex(bref) if type(bref) is str else "bref.h:"+tohex(bref.h))))
  fp.write(path)
  fp.write(":\n")
  if not recurse:
    names=D.dirs()+D.files()
    names.sort()
    for name in names:
      E=D[name]
      bref=E.bref()
      fp.write("%c %-41s %-6d %s\n" % (('d' if D.isdir(name) else 'f'), bref, bref.span, name))
  else:
    dirs=D.dirs(); dirs.sort()
    files=D.files(); files.sort()
    for name in files:
      E=D[name]
      bref=E.bref()
      fp.write("%c %-41s %-6d %s\n" % (('d' if D.isdir(name) else 'f'), bref, bref.span, name))
      assert not D.isdir(name), name+" should not be a directory!"
    for name in dirs:
      fp.write("\n")
      ls(os.path.join(path,name),D.chdir1(name),recurse,fp)

def cat(path,fp=None):
  if fp is None:
    fp=stdout
  bref=path2bref(path)
  for b in bref.leaves(S):
    fp.write(b)

def storePath(path,targetRef=None,ignoreTimes=False,deleteMissing=False,overWrite=False):
  from cs.venti.fs import FS
  import cs.venti.store
  assert type(S) is not cs.venti.store.Store, "S=%s"%S
  D=FS(S,targetRef).updateDir(path,
                    ignoreTimes=ignoreTimes,
                    deleteMissing=deleteMissing,
                    overWrite=overWrite)
  return D.sync()

if op == "store":
  for path in args:
    ref=storePath(path)
    stdout.write(tohex(ref.encode()))
    if len(args) > 1:
      stdout.write('\t')
      stdout.write(path)
    stdout.write('\n')
  S.sync()

elif op == "update":
  from cs.venti.blocks import str2BlockRef
  import datetime
  path=args[0]
  if archive is None:
    archive="%s.vt" % os.path.basename(path)
  target=None
  if os.path.isfile(archive):
    hexarg=None
    for line in open(archive):
      assert line[-1] == '\n'
      words=line[:-1].strip().split(' ')
      if len(words) == 0:
        continue
      if words[0].startswith("#"):
        continue
      hexarg=words[0]
    if hexarg is not None:
      target=str2BlockRef(fromhex(hexarg))
  saved=storePath(path,targetRef=target,ignoreTimes=False,deleteMissing=True,overWrite=True)
  open(archive,mode='a').write("%s %s\n" % (saved, datetime.datetime.now()))

elif op == "cat":
  for path in args:
    cat(path)

elif op == "catblock":
  for hexarg in args:
    if indirect:
      bl
    else:
      stdout.write(S[fromhex(hexarg)])

elif op == "listen":
  from cs.venti.tcp import Server
  assert len(args) == 1
  srv=Server(('127.0.0.1',int(args[0])),S)
  srv.serve_forever()

elif op == "ls":
  first=True
  for path in args:
    if first:
      first=False
    else:
      print
    print "ls", path, "..."
    D, name = resolve(path)
    D=D.chdir1(name)
    ls(path,D,recurse,stdout)

elif op == "mount":
  print "mount", args[0], args[1], "..."
  if not os.path.isdir(args[1]):
    cmderr("%s: mountpoint is not a directory" % args[1])
    exit(1)
  E=S.namei(args[0]+'/')
  assert E.isdir, "%s: %s: expected directory, not file"%(cmd,args[0])
  import cs.venti.vtfuse
  cs.venti.vtfuse.fusemount(args[1],S,E)

elif op == "unpack":
  for path in args:
    D, name = resolve(path)
    if len(name) > 0:
      D=D.chdir1(name)
    for subD, dirs, files in D.walk(topdown=True):
      if len(subD.path) > 0 and not os.path.isdir(subD.path):
        print "mkdir", subD.path
        os.makedirs(subD.path)
      files.sort()
      for fname in files:
        assert len(fname) > 0 and fname != '.' and fname != '..' and fname.find('/') < 0, \
          "%s: unpack: %s: illegal filename \"%s\"" % (cmd, subD.path, fname)
        fpath=os.path.join(subD.path,fname)
        print "extract", fpath
        outfp=open(fpath,mode='w')
        for b in subD[fname].bref().leaves(S):
          outfp.write(b)
        outfp.close()

else:
  cmderr("unsupported command")
  exit(2)
