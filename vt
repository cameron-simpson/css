#!/usr/bin/python -tt
#
# Command script for venti-ish implementation.
#       - Cameron Simpson <cs@zip.com.au> 01may2007
#

from sys import argv, exit, stdin, stderr, stdout, exit
import os
import os.path
from cs.venti import tohex, fromhex
from cs.venti.store import Store
import cs.misc
from cs.misc import cmd, cmderr, setcmd, warn

usage='''Usage:
  %s [-S store] cat filerefs...
  %s [-S store] catblock [-i] hashcodes...
  %s [-S store] listen port
  %s [-S store] ls [-R] dirrefs...
  %s [-S store] mount dirref mountpoint
  %s [-S store] store pathnames...
  %s [-S store] update [-o file.vt] path
  %s [-S store] unpack dirref
''' % (cmd,cmd,cmd,cmd,cmd,cmd,cmd,cmd)

badopts=False

S=None

args=argv[1:]
if len(args) > 0 and args[0] == '-S':
  S=Store(args[1])
  args=args[2:]

if len(args) < 1:
  cmderr("missing command")
  badopts=True
else:
  op=args.pop(0)
  setcmd("%s: %s" % (cmd,op))
  if op == "store":
    if len(args) < 1:
      cmderr("missing pathnames")
      badopts=True
  elif op == "update":
    archive=None
    if len(args) >= 2 and args[0] == "-o":
      archive=args[1]
      args=args[2:]
    if len(args) == 0:
      cmderr("missing path")
      badopts=True
    elif len(args) > 1:
      cmderr("extra arguments after path: %s" % " ".join(args[1:]))
      badopts=True
  elif op == "cat":
    if len(args) < 1:
      cmderr("missing filerefs")
      badopts=True
  elif op == "catblock":
    indirect=False
    if len(args) > 0 and args[0] == "-i":
      indirect=True
      args.pop(0)
    if len(args) < 1:
      cmderr("missing hashcodes")
      badopts=True
  elif op == "listen":
    if len(args) != 1:
      cmderr("expected a port")
      badopts=True
  elif op == "ls":
    recurse=False
    if len(args) > 0 and args[0] == "-R":
      recurse=True
      args.pop(0)
    if len(args) < 1:
      cmderr("missing dirrefs")
      badopts=True
  elif op == "mount":
    if len(args) != 2:
      cmderr("expected dirref and mountpoint")
      badopts=True
  elif op == "unpack":
    if len(args) != 1:
      cmderr("expected exactly one dirref")
      badopts=True
  else:
    cmderr("unrecognised command")
    badopts=True

if S is None:
  dflt_vt_store=os.environ.get('VT_STORE')
  if dflt_vt_store is None:
    cmderr("no $VT_STORE and no -S option")
    badopts=True
  else:
    S=Store(dflt_vt_store)

if badopts:
  stderr.write(usage)
  exit(2)

def gethexarg(path):
  slash=path.find('/')
  if slash < 0:
    hexarg=path
    path=''
  else:
    hexarg=path[:slash]
    slash+=1
    while slash < len(path) and path[slash] == '/':
      slash+=1
    path=path[slash:]
  from cs.venti.blocks import str2BlockRef
  bref=str2BlockRef(fromhex(hexarg))
  return bref, path

def resolve(path, domkdir=False):
  bref, path = gethexarg(path)
  from cs.venti.fs import FS
  return FS(S,bref).root.resolve(path,domkdir)

def path2bref(path):
  bref, path = gethexarg(path)
  if len(path) > 0:
    D, name = FS(S,bref).root.resolve(path,domkdir)
    return D.name2bref(name)
  return bref

def vtopen(path, mode='r', domkdir=False):
  bref, path = gethexarg(path)
  if len(path) > 0:
    D, name = FS(S,bref).root.resolve(path,domkdir)
    return D.open(name,mode)
  import cs.venti.file
  return cs.venti.file.open(S,mode,bref)

def ls(path,D,recurse,fp=None):
  if fp is None:
    fp=stdout
  ##warn("ls %s: bref=%s"%(path,("s:"+tohex(bref) if type(bref) is str else "bref.h:"+tohex(bref.h))))
  fp.write(path)
  fp.write(":\n")
  if not recurse:
    names=D.dirs()+D.files()
    names.sort()
    for name in names:
      E=D[name]
      bref=E.bref()
      fp.write("%c %-41s %-6d %s\n" % (('d' if D.isdir(name) else 'f'), bref, bref.span, name))
  else:
    dirs=D.dirs(); dirs.sort()
    files=D.files(); files.sort()
    for name in files:
      E=D[name]
      bref=E.bref()
      fp.write("%c %-41s %-6d %s\n" % (('d' if D.isdir(name) else 'f'), bref, bref.span, name))
      assert not D.isdir(name), name+" should not be a directory!"
    for name in dirs:
      fp.write("\n")
      ls(os.path.join(path,name),D.chdir1(name),recurse,fp)

def cat(path,fp=None):
  if fp is None:
    fp=stdout
  bref=path2bref(path)
  for b in bref.leaves(S):
    fp.write(b)

def storePath(path,targetRef=None,ignoreTimes=False,deleteMissing=False,overWrite=False):
  from cs.venti.fs import FS
  import cs.venti.store
  assert isinstance(S, cs.venti.store.BasicStore), "S=%s"%S
  D=FS(S,targetRef).updateDir(path,
                    ignoreTimes=ignoreTimes,
                    deleteMissing=deleteMissing,
                    overWrite=overWrite)
  return D.sync()

if op == "store":
  for path in args:
    ref=storePath(path)
    stdout.write(tohex(ref.encode()))
    if len(args) > 1:
      stdout.write('\t')
      stdout.write(path)
    stdout.write('\n')
  S.sync()

elif op == "update":
  from cs.venti.blocks import str2BlockRef
  import datetime
  path=args[0]
  if archive is None:
    archive="%s.vt" % os.path.basename(path)
  target=None
  if os.path.isfile(archive):
    hexarg=None
    for line in open(archive):
      assert line[-1] == '\n'
      words=line[:-1].strip().split(' ')
      if len(words) == 0:
        continue
      if words[0].startswith("#"):
        continue
      hexarg=words[0]
    if hexarg is not None:
      target=str2BlockRef(fromhex(hexarg))
  saved=storePath(path,targetRef=target,ignoreTimes=False,deleteMissing=True,overWrite=True)
  open(archive,mode='a').write("%s %s\n" % (saved, datetime.datetime.now()))

elif op == "cat":
  for path in args:
    cat(path)

elif op == "catblock":
  for hexarg in args:
    if indirect:
      bl
    else:
      stdout.write(S[fromhex(hexarg)])

elif op == "listen":
  assert len(args) == 1
  arg=args[0]
  if arg == '-':
    from cs.venti.stream import StreamDaemon
    StreamDaemon(S,stdin,stdout)
  else:
    cpos=arg.rfind(':')
    if cpos >= 0:
      host=arg[:cpos]
      port=arg[cpos+1:]
      if len(host) == 0:
        host='127.0.0.1'
      port=int(port)
      srv=Server((host,port),S)
      srv.serve_forever()
    else:
      cmderr("invalid listen argument, I expect \"-\" or \"[host]:port\", got \"%s\"" % arg)
      exit(1)

elif op == "ls":
  first=True
  for path in args:
    if first:
      first=False
    else:
      print
    print "ls", path, "..."
    D, name = resolve(path)
    D=D.chdir1(name)
    ls(path,D,recurse,stdout)

elif op == "mount":
  print "mount", args[0], args[1], "..."
  if not os.path.isdir(args[1]):
    cmderr("%s: mountpoint is not a directory" % args[1])
    exit(1)
  E=S.namei(args[0]+'/')
  assert E.isdir, "%s: %s: expected directory, not file"%(cmd,args[0])
  import cs.venti.vtfuse
  cs.venti.vtfuse.fusemount(args[1],S,E)

elif op == "unpack":
  for path in args:
    D, name = resolve(path)
    if len(name) > 0:
      D=D.chdir1(name)
    for subD, dirs, files in D.walk(topdown=True):
      if len(subD.path) > 0 and not os.path.isdir(subD.path):
        print "mkdir", subD.path
        os.makedirs(subD.path)
      files.sort()
      for fname in files:
        assert len(fname) > 0 and fname != '.' and fname != '..' and fname.find('/') < 0, \
          "%s: unpack: %s: illegal filename \"%s\"" % (cmd, subD.path, fname)
        fpath=os.path.join(subD.path,fname)
        print "extract", fpath
        outfp=open(fpath,mode='w')
        for b in subD[fname].bref().leaves(S):
          outfp.write(b)
        outfp.close()

else:
  cmderr("unsupported command")
  exit(2)
