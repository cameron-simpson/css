#!/bin/sh
#
# Make a scratch checkout, run a command, throw the checkout away.
# Runs:
#	command path-to-checkout [args...]
# so typically you'd go
#       withco module incd command args...
#   or  withco -f module/file incd command args...
#   or  inco module command args...
#   or  inco -f module/file command args...
# to run command _in_ the checkout.
# - Cameron Simpson <cs@zip.com.au> 04jul2003
#

cmd=`basename "$0"`
usage="Usage: $cmd [-f] module command [args...]
	-f	Assume \"module\" is a file and thus use its parent directory."

badopts=

isfile=
[ "x$1" = x-f ] && { isfile=1; shift; }

if [ $# = 0 ]
then
  echo "$cmd: missing module" >&2
  badopts=1
else
  module=$1; shift
  case "$module" in
    /*)	echo "$cmd: bad module name \"$module\" - must be relative path" >&2
	badopts=1
	;;
  esac

  if [ $# = 0 ]
  then
    echo "$cmd: missing command" >&2
    badopts=1
  else
    command=$1; shift
  fi
fi

[ $badopts ] && { echo "$usage" >&2; exit 2; }

trap '[ -z "$dir" ] || rm -rf "$dir"' 0 1 2 3 15
dir=`mkdirn "${TMPDIR:-/tmp}/$cmd"` || exit 1

( cd "$dir" || exit 1
  cvs co "$module" || exit 1
) || exit 1

where=$dir/$module
[ $isfile ] && where=`dirname "$where"`

"$command" "$where" ${1+"$@"}
exit $?
